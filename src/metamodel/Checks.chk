import guigen;

extension org::openarchitectureware::util::stdlib::naming;
extension template::GenericExtensions;
extension template::struts2::Struts2Extensions;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check indipendenti dalla piattaforma target                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

context TargetPlatform WARNING "L'interazione 'ricca' non è abilitata: se si desidera abilitarla impostare a true "+
	"l'attributo 'enableRichUIBehavior' nell'oggetto TargetPlatform" :
	enableRichUIBehavior == true;

context TargetPlatform WARNING "L'interazione 'ricca' è una feature sperimentale: se si desidera disabilitarla impostare a false "+
	"l'attributo 'enableRichUIBehavior' nell'oggetto TargetPlatform" :
	enableRichUIBehavior != true;

// validazioni generali (prodotto/componente etc..)
context GUIModel ERROR "E' necessario specificare il codice prodotto (max 10 caratteri)" :
	codProdotto!=null && codProdotto.length<=10;

context GUIModel ERROR "E' necessario specificare il codice componente (max 20 caratteri)" :
	codComponente!=null && codComponente.length<=20;

context GUIModel ERROR "E' necessario specificare la versione del prodotto nel formato major.minor.bugfix" :
	versioneProdotto!=null && isVersioneFormalmenteCorretta(versioneProdotto);

context GUIModel ERROR "E' necessario specificare la versione del componente nel formato major.minor.bugfix" :
	versioneComponente!=null && isVersioneFormalmenteCorretta(versioneComponente);

context GUIModel ERROR "E' necessario scegliere la Target Platform" :
	targetPlatform!=null;

// [AM] warning per incoraggiare l'uso della modularizzazione
context GUIModel WARNING "Per una migliore gestione del progetto di consiglia di definire il SecurityModel in un modello separato, "+
	"includerlo come risorsa e referenziarlo in 'extSecurityModel': "+loc() :
	securityModel==null;

context GUIModel ERROR "E' possibile specificare solo una dei due elementi 'securityModel' (deprecato) e 'extSecurityModel' (consigliato):"+loc() :
	securityModel==null || extSecurityModel==null;	

context Header ERROR "E' necessario impostare i codici 'canale' e 'applicativo' nell'oggetto Header "+
					 "(servono per referenziare le risorse remote)" :
	codCanale != null && codCanale != "" && codApplicativo != null && codApplicativo != "";

context Header ERROR "E' necessario impostare i nomi descrittivi del 'canale' e dell' 'applicativo' nell'oggetto Header "+
					 "(servono per il filo d'arianna)" :
	nomeCanale != null && nomeCanale != "" && nomeApplicativo != null && nomeApplicativo != "";
	
context Header ERROR "E'necessario impostare il link (di produzione) del canale nell'oggetto Header (viene inserito nel filo d'arianna)" :
	linkCanale != null && linkCanale.length>0;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Validazione su AppModule context AppModule


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Validazione su pannelli

context ApplicationArea ERROR "Deve essere definito il content panel di homePage: " + loc() :
	this.homePage!=null;

context ApplicationArea WARNING "Per una migliore gesitone del progetto si consiglia di modellare gli AppModule in modelli separati, includere il modello e "+
	"referenziarlo nell'ApplicationArea, invece che definire AppModule direttamente nell'ApplicationArea."+
	"AppModules candidati all'esternalizzazione: "+this.modules.name :
	modules.size==0;

context ApplicationArea WARNING "Per una migliore gesitone del progetto si consiglia di suddividere il modello in AppModule mantenuti in modelli separati, includere i modelli e "+
	"referenziarlo nell'ApplicationArea, invece che definire ContentPanel direttamente nell'ApplicationArea.":
	contentPanels.size==0;

	
context ContentPanel ERROR "occorre specificare il nome del contentPanel:"+loc() :
	name!=null;

context ContentPanel if eRootContainer.metaType == GUIModel ERROR "Il nome dei content panel deve essere univoco all'interno dell'applicazione " + loc() :
	isContentPanelUnique(this); 

context ContentPanel ERROR "E'necessario definire il pannello principale nel content panel:"+loc() :
	panels!=null;
	
context Panel ERROR "E'necessario impostare l'attributo 'name' del pannello " + loc():
	this.name != null && this.name != "";

context Panel if findParentContentPanel(this)!=null ERROR "il nome di un pannello deve essere univoco all'interno di un ContentPanel "+loc() :
    findParentContentPanel(this).eAllContents.typeSelect(Panel).select(p|p.name==this.name).size==1;

context Panel if findParentPanelDef(this)!=null ERROR "il nome di un pannello deve essere univoco all'interno di un PanelDef "+loc() :
    findParentPanelDef(this).eAllContents.typeSelect(Panel).select(p|p.name==this.name).size==1;

// Con l'introduzione del WidgetsLayout, ha senso che un FormPanel abbia un layout solo se è di primo livello, 
// ovvero se è figlio diretto di un ContentPanel. In tal caso può essere solo:
//   - VerticalFlowPanelLayout => 1 colonna
//   - UDLRCPanelLayout        => 2 o 3 colonne
context FormPanel if this.eContainer.metaType == ContentPanel ERROR "Il FormPanel di primo livello deve avere un layout di tipo VerticalFlowPanelLayout o UDLRCPanelLayout " + loc() :
	this.layout != null && (this.layout.metaType == VerticalFlowPanelLayout || this.layout.metaType == UDLRCPanelLayout);

// In tutti gli altri casi, anche se il layout è ininfluente(al momento viene ignorato, visto che il layout dei widgets 
// passa come competenza al WidgetsPanel), imponiamo che sia obbligatorio e sia VerticalFlowPanelLayout
// -> MODIFICATO: VARIA A SECONDA DELLA CARTUCCIA
//context FormPanel if this.eContainer.metaType != ContentPanel ERROR "Il FormPanel di livello inferiore al primo deve avere un layout di tipo VerticalFlowPanelLayout " + loc() :
//	this.layout != null && this.layout.metaType == VerticalFlowPanelLayout;

context FormPanel ERROR "E' necessario impostare lo specificatore del layout NSEWC per tutti i sottopannelli "+loc() :
    (this.layout.metaType!=UDLRCPanelLayout) 
    ||
    (
    	(
    		this.layout.metaType==UDLRCPanelLayout 
    		&& 
    		this.subpanels.select(w|w.layoutSpec==null).size==0
    		&&
    		this.subpanels.select(w|w.layoutSpec.metaType!=UDLRCWidgetLayoutSpec).size==0
    	)
    );

// Con l'introduzione del WidgetsPanel, il FormPanel non deve più contenere widgets.
context FormPanel ERROR "Un FormPanel non può contenere Widgets. L'attributo widgets è stato mantenuto solo per retrocompatibilità. " + loc() :
	this.widgets.size == 0;


context TabSetPanel ERROR "Un TabSetPanel deve avere almeno un tab " + loc() :
	this.panels.size>0;


context MultiPanel ERROR "Un MultiPanel deve avere almeno un pannello interno " + loc() :
	this.panels.size>0;
	
context MultiPanel ERROR "Un multipanel può contenere solo FormPanel/CommandPanel/StdMessagePanel come pannelli interni "+loc() :
	this.panels.select(p|(
			!p.metaType.isAssignableFrom(FormPanel)
			&&
			!p.metaType.isAssignableFrom(CommandPanel)
			&&
			!p.metaType.isAssignableFrom(StdMessagePanel)
			&&
			!p.metaType.isAssignableFrom(UserDefinedPanel)
			)
	).size==0;

context MultiPanel ERROR "Gli item dei multi panel non possono contenere DataWidget dichiarati required: " + loc() :
	findAllWidgetsInPanel(this).select(w|DataWidget.isAssignableFrom(w.metaType) && ((DataWidget)w).required==true).size==0;

context MultiPanel ERROR "Un Multi/TabSet/Wizard non può essere contenuto in un PanelDef:"+loc() :
	findParentPanelDef() == null;

// [DM] check su CommandPanel
// 1) deve essere contenuto in un FormPanel (es il panel master con layout UDLRC)
// 2) può contenere solo CommandWidget (o al massimo HiddenValue)
// 3) può avere solo due tipi di layout: [a] horizontal flow, [b] UDLRC ristretto (solo L ed R, tipico delle barre di navigazione)
// 4) non deve avere label (*da verificare*) 
// 1
context CommandPanel ERROR "Un CommandPanel deve essere contenuto in un FormPanel, in un DialogPanel o in un MultiPanel/TabSetPanel/WizardPanel " + loc() :
	this.eContainer.metaType == FormPanel ||
	this.eContainer.metaType == DialogPanel ||
	this.eContainer.metaType.isAssignableFrom(MultiPanel);
// 2
context CommandPanel ERROR "Un CommandPanel può contenere solo CommandWidget o HiddenValue " + loc() :
	commandPanelCommandWidgetCheck(this);
// 3 -> MODIFICATO: VARIA A SECONDA DELLA CARTUCCIA
//context CommandPanel ERROR "Un CommandPanel può avere solo due tipi di layout: [a] HorizontalFlowPanelLayout, [b] UDLRCPanelLayout ristretto (solo LEFT ed RIGHT) " + loc() :
//	commandPanelLayoutCheck(this);
// 4
context CommandPanel ERROR "Un CommandPanel non deve avere label " + loc() :
	isNullOrEmpty(this.label); // TODO: verificare se è corretto che sia così


// [DM] check su MenuPanel
// 1) deve essere contenuto in un FormPanel (es il panel master con layout UDLRC)
// 2) può contenere solo widget di tipo MenuView o TreeView
// 4) può avere solo un layout Vertical
// 5) non deve avere label (*da verificare*)
// 1
context MenuPanel ERROR "Un MenuPanel deve essere contenuto in un FormPanel " + loc() :
	this.eContainer.metaType == FormPanel;
// 2
context MenuPanel ERROR "Un MenuPanel può contenere solo widget di tipo MenuView o TreeView " + loc() :
	menuPanelWidgetCheck(this);
// 4
context MenuPanel ERROR "Un MenuPanel può avere solo un layout di tipo VerticalFlowPanelLayout " + loc() :
	this.layout.metaType == VerticalFlowPanelLayout;
// 5
context MenuPanel ERROR "Un MenuPanel non deve avere label " + loc() :
	isNullOrEmpty(this.label); // TODO: verificare se è corretto che sia così

	
// [DM] check su DialogPanel	
context DialogPanel ERROR "Un DialogPanel può essere inserito solo in un ContentPanel " + loc() :
	this.eContainer.metaType == ContentPanel;

context DialogPanel ERROR "Un DialogPanel deve contenere almeno un MsgBoxPanel " + loc() :
	this.msgBoxes != null && this.msgBoxes.size > 0;


// [DM] check su MsgBoxPanel
context MsgBoxPanel ERROR "Un MsgBoxPanel può essere inserito solo all'interno di un un DialogPanel o di un FormPanel " + loc() :
	this.eContainer.metaType == DialogPanel || this.eContainer.metaType == FormPanel;

context MsgBoxPanel ERROR "Un MsgBoxPanel deve contenere almeno un PlainText " + loc() :
	this.textMessages != null && this.textMessages.size > 0;


// [DM] check su WidgetsPanel
context WidgetsPanel ERROR "Un WidgetsPanel deve essere contenuto in un FormPanel " + loc() :
	this.eContainer.metaType == FormPanel;

context WidgetsPanel ERROR "E' necessario impostare il layout su ogni WidgetsPanel " + loc() :
	this.layout != null;

context WidgetsPanel ERROR "Un WidgetsPanel può avere i seguenti layout: HorizontalFlow, VerticalFlowPanelLayout o GridPanelLayout " + loc() :
	this.layout.metaType == HorizontalFlowPanelLayout || this.layout.metaType == VerticalFlowPanelLayout || this.layout.metaType == GridPanelLayout;

context WidgetsPanel ERROR "Il WidgetsPanel ha il layout 'Grid': e' necessario impostare la posizione in griglia per tutti i widget " + loc() :
	this.layout.metaType != GridPanelLayout 
	||
    (
    	(
    		this.layout.metaType==GridPanelLayout 
    		&& 
    		this.widgets.select(w|w.layoutSpec==null).size==0
    		&&
    		this.widgets.select(w|w.layoutSpec.metaType!=GridWidgetLayoutSpec).size==0
    	)
    );

context WidgetsPanel if !isNullOrEmpty(this.layout.columnSizes) ERROR "L'attributo columnSizes non è formalmente corretto, il numero di colonne non corrisponde al numero atteso, la somma delle colonne non è 100 " + loc() :
	columnSizesWidgetsPanelCheck(this);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Validazioni su struttura menu

// [MA] univocità name Menu/MenuItem
context Menu ERROR "Il nome dei menu deve essere univoco all'interno del modello: "+loc() : 
	isMenuNameUnique(name, ((GUIModel)eRootContainer).structure.appWindow.appArea.menubar);

context Menu WARNING "Il menu "+this.name+" non ha nessun EventHandler associato ed è quindi inattivo " + loc() :
	this.eventHandler != null; 

// [DM] STDMDD-241: razionalizzazione e completamento gestione casistiche rendering menu -> MenuItem DEPRECATO
context MenuItem ERROR "MenuItem è DEPRECATO! Utilizzare Menu al posto: " + loc() : 
	false;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Validazione su widget

context Widget ERROR "E'necessario impostare l'attributo 'name' del widget "+loc() :
	this.name != null && this.name != "";

context Widget if findParentContentPanel()!=null ERROR "il name dei widgets in un content panel (eccettuati singoli radiobutton) deve essere univoco " + loc() :
     this.metaType==RadioButton ||
     findAllWidgetsInContentPanel(findParentContentPanel(this)).select(w|((Widget)w).name==this.name).size == 1;

context Widget if findParentPanelDef()!=null ERROR "il name dei widgets in un panel def (eccettuati singoli radiobutton) deve essere univoco " + loc() :
     this.metaType==RadioButton ||
     findParentPanelDef().eAllContents.typeSelect(Widget).select(p|p.name==this.name).size==1;

     
context Table ERROR "Non è stato impostato lo schema delle colonne"+loc() :
	this.columnModel!=null;

// [AM] perr ora questa feature è sospesa
context Table ERROR "Una table inclusa in un PanelDef non può avere un custom decorator:"+loc() :
	findParentPanelDef()==null || this.customDecorator == false;

context ColumnModel ERROR "Lo schema delle colonne deve contenere almeno una colonna " + loc() :
	columns != null && columns.size>0;
 
// [DM] una colonna non può essere contemporaneamente editabile e cliccabile
context Column ERROR "Una colonna non puo' essere contemporaneamente editabile e cliccabile " + loc() :
!(this.editable && this.eventActive);

context Column if !editable ERROR "Non si puo' specificare l'attributo 'editableFlagSelector' se la colonna non e' editabile " + loc() :
	editableFlagSelector == null;

context Column if multiDataBinding !=null ERROR "configurare in alternativa il multidataBinding o il multidataPropertySelector " + loc () :
	multidataPropertySelector == null;
	
context Column if multidataPropertySelector !=null ERROR "configurare in alternativa il multidataBinding o il multidataPropertySelector " + loc () :
	multiDataBinding == null;

	 	
// [DM] HiddenValue puo' essere inserito solo in un CommandPanel (per il momento...): questo per non complicare le cose con i layout
context HiddenValue ERROR "Il widget HiddenValue puo' essere inserito solo in un Pannello con Vertical o Horizontal layout " + loc() :
 	((Panel)this.eContainer).layout.metaType == VerticalFlowPanelLayout || ((Panel)this.eContainer).layout.metaType == HorizontalFlowPanelLayout;
 
// [DM] Button
context Button WARNING "Ogni Button dovrebbe essere contenuto in un CommandPanel: il rendering di questo Button è indefinito " + loc() :
	this.eContainer.metaType == CommandPanel;
 
 // [DM] Calendar
 context Calendar ERROR "Un Calendar deve avere un DataType di tipo DATE " + loc() :
 	this.dataType.metaType == SimpleType && ((SimpleType)(this.dataType)).code == guigen::SimpleTypeCodes::DATE;

 context Calendar if (this.databinding != null) ERROR "Il DataBinding di un Calendar deve essere di tipo Date " + loc() :
	calendarDataBindingTypeCheck(this);


  context TabSwitcher ERROR "Il Tab Switcher può essere associato solo ad un TabSetPanel o a un WizardPanel:" +loc() :
  	this.eContainer.metaType == TabSetPanel || this.eContainer.metaType == WizardPanel;
  	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Validazione su azioni e listener

context MenuItem ERROR "Un menu item può generare solo eventi di tipo CLICKED "+loc() :
	this.eventHandler==null || this.eventHandler.eventType == EventTypes::CLICKED;

context EventHandler ERROR "Un action Listener deve innescare un comando a fronte di un tipo di evento "+loc() :
	this.command!=null;
	
context JumpCommand ERROR "E'necessario impostare il pannello target di un Jump Command "+loc() :
	this.jumpTo != null;
	
context JumpCommand WARNING "L'utilizzo di JumpCommand sullo stesso pannello di partenza è deprecato. Preferibile NOPCommand: "+loc() :
	!jumpToSameContentPanel(this);

context ShowDialogCommand ERROR "E'necessario impostare il dialog target di uno ShowDialogCommand "+loc() :
    this.dialog != null;
    
context ExecCommand ERROR "Un ExecCommand deve avere almeno un CommandOutcome associato "+loc() :
	this.results!=null && this.results.size>0;

context ExecCommand ERROR "E'necessario specificare il nome del metodo associato all'esecuzione "+loc() :
	this.methodName!=null && this.methodName.length>0;

context ActivateMultiPanelItemCommand ERROR "E'necessario specificare il multi panel "+loc() :
	this.multipanel!=null;
		
context ActivateMultiPanelItemCommand ERROR "Il sottopannello (activeItem) non è un item del MultiPanel specificato "+loc() :
	this.activeItem==null || 
	this.multipanel.panels.select(p|p==this.activeItem).size>0;

context JumpExtCommand ERROR "E'necessario specificare un url statico o un application data a cui puntare a runtime "+loc() :
	this.staticUrl!=null && this.runtimeUrlProvider==null 
	||
	(this.staticUrl==null || this.staticUrl.length==0) && this.runtimeUrlProvider!=null;

context JumpExtCommand ERROR "E'necessario fornire un codice identificativo/descrittivo dell'url esterno a cui saltare "+loc() :
	this.locationCode!=null && this.locationCode.length>0;
	
context JumpExtCommand ERROR "JumpExtCommand può utilizzare solo un appData di tipo string come runtime url provider "+loc() :
	this.runtimeUrlProvider==null ||
	this.runtimeUrlProvider.type.metaType==SimpleType &&
	((SimpleType)(this.runtimeUrlProvider.type)).code==guigen::SimpleTypeCodes::STRING;

context VisibilityCommand ERROR "Il comando di commutazione di visibilità è incomaptibile con i widget dichiarati required "+loc() :
	this.targetWidgets.select(w|DataWidget.isAssignableFrom(w.metaType) && ((DataWidget)w).required==true).size==0;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// constraints su azioni

// un menu view non può avere event handler associati (eredita quelli del menu vero e proprio di cui
// è segnaposto
context MenuView ERROR "ad una MenuView non è possibile associare evnet handler, in quanto eredita gli event handler"+
						" della struttura menu globale (di cui funge solo da segnaposto) "+loc() :
	this.eventHandlers.size == 0;

// un Treeview può avere solo un event handler di tipo click
context TreeView ERROR "ad una TreeView è possibile associare solo la gestione di un evento CLICKED "+loc() :
	this.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size==(this.eventHandlers.size);

// per rendere "eventActive" una colonna di una table occorre specificare un event handler clicked nella table
context Column ERROR "una colonna di una Table può essere dichiarata 'eventActive' solo se la tabella "+
	"definisce un Event Handler di tipo CLICKED: "+loc() :
	!eventActive ||
	(eventActive)
	&& 
	((Table)(((ColumnModel)this.eContainer).eContainer))
		.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size == 1;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// constraints su binding
context ContentPanel if (panels!=null) ERROR "Il content panel "+name+" non referenzia tutti gli Application Data "+
	"referenziati dai widget in esso contenuti. AppData mancanti: "+findUnresolvedAppDataBinding() :
	findUnresolvedAppDataBinding().size == 0; 
	
context AppDataBinding ERROR "E'necessario specificare il dato associato ad un DataBinding "+loc() :
	this.appData != null;

context ApplicationData ERROR "E' necessario specificare il nome dell Application Data "+loc() :
	this.name != null && this.name.length > 0;

context ApplicationData ERROR "E' necessario specificare il tipo dell Application Data "+loc() :
	this.type != null;
 
context TreeView ERROR "La fonte dati di un TreeView può solo essere un application data di tipo TreeNode e invece è "+this.multiDataBinding.appData.type+", "+loc() :
	this.multiDataBinding == null ||
	(
		this.multiDataBinding.appData != null 
	 	&& 
	 	this.multiDataBinding.appData.type.metaType == SimpleType 
	 	&&
	 	((SimpleType)this.multiDataBinding.appData.type).code == SimpleTypeCodes::TREE_NODE
	 );

//context MultiDataWidget ERROR "Il tipo del binding di un MultiDataWidget deve essere un array di tipo complesso, invece è "+this.multiDataBinding.appData.type+", "+loc() :
//	this.multiDataBinding.appData.type.metaType==TypedArray && 
//	((TypedArray)multiDataBinding.appData.type).componentType.metaType==ComplexType;	
	
context DataWidget ERROR "E' necessario specificare il tipo del Widget "+loc() :
	this.dataType != null;

//context DataWidget ERROR "Il tipo del widget non corrisponde con il tipo del databinding "+loc() :
//	(this.dataType==null 
//	 || this.databinding == null 
//	 || (this.databinding!=null && this.databinding.appData==null)
//	 || (this.databinding!=null && this.databinding.appData!=null && this.databinding.appData.type == null))
//	 || (this.databinding!=null 
//	 	&& this.databinding.appData!=null 
//	 	&& this.databinding.appData.type!=null 
//	 	&& ""!=(this.databinding.path))
//	 || (
//	 	this.dataType!=null 
//	 	&& this.databinding!=null 
//	 	&& this.databinding.appData!=null 
//	 	&& this.databinding.appData.type!=null
//	 	&& this.dataType==this.databinding.appData.type
//	 );

//context DataWidget WARNING "Non è possibile verificare a priori la corrispondenza di tipo tra widget e binding "+
//	"poichè è impostato l'attributo path: verificare manualmente "+loc() :
//	(this.dataType==null 
//	 || this.databinding == null 
//	 || (this.databinding!=null && this.databinding.appData==null)
//	 || (this.databinding!=null && this.databinding.appData!=null && this.databinding.appData.type==null))
//	 || (this.databinding!=null 
//	 	&& this.databinding.appData!=null 
//	 	&& this.databinding.appData.type!=null 
//	 	&& ""==(this.databinding.path))
//	 || (
//	 	this.dataType!=null 
//	 	&& this.databinding!=null 
//	 	&& this.databinding.appData!=null 
//	 	&& this.databinding.appData.type!=null
//	 	&& this.dataType==this.databinding.appData.type
//	 );

context DataWidget if (this.databinding != null && this.metaType != Table) WARNING "Il tipo del widget non corrisponde con il tipo del databinding "+loc() : 
	widgetDataBindingCorrispondenceCheck(this);

context Table ERROR "Non è stato specificato il binding alla collection per la table "+name :
	this.multiDataBinding != null;
	
// [DM] Un TypeNamespace puo' contenere solo ComplexType o TypedArray, non SimpleType
context TypeNamespace ERROR "Un TypeNamespace puo' contenere solo ComplexType o TypedArray, non SimpleType " + loc() :
	this.types.select(t|t.metaType == SimpleType).size == 0; 


//////////////////////////////////////////////////////////////////////////////
//// constraints su PanelDef
//////////////////////////////////////////////////////////////////////////////
context AppDataMappingPDefVal ERROR "il parametro indicato per la valorizzazione deve essere un AppDataMappingParam:"+loc() :
	this.param.metaType == AppDataMappingParam;

context TypeDefMappingPDefVal ERROR "il parametro indicato per la valorizzazione deve essere un TypeDefMappingParam:"+loc() :
	this.param.metaType == TypeDefMappingParam;

context ActorMappingPDefVal ERROR "il parametro indicato per la valorizzazione deve essere un ActorMappingParam:"+loc() :
	this.param.metaType == ActorMappingParam;

context RoleMappingPDefVal ERROR "il parametro indicato per la valorizzazione deve essere un RoleMappingParam:"+loc() :
	this.param.metaType == RoleMappingParam;
	
context UCMappingPDefVal ERROR "il parametro indicato per la valorizzazione deve essere un UseCaseMappingParam:"+loc() :
	this.param.metaType == UseCaseMappingParam;

context PDefParamVal ERROR "occorre specificare il parametro valorizzato:"+loc() :
	this.param != null;
	
context AppDataMappingPDefVal ERROR "occorre specificare l'application data target:"+loc() :
	actualAppData!=null;
	
context TypeDefMappingPDefVal ERROR "occorre specificare il tipo target:"+loc() :
	actualTypeDef!=null;
	
context ActorMappingPDefVal ERROR "occorre specificare l' 'Actor' target:"+loc() :
	actualActor!=null;			
	
context RoleMappingPDefVal ERROR "occorre specificare il 'Role' target:"+loc() :
	actualRole!=null;
	
context UCMappingPDefVal ERROR "occorre specificare lo 'UseCase' target:"+loc() :
	actualUseCase!=null;

context PanelDefUse if this.panelDef!=null && this.panelDef.params.size>0 ERROR 
	"occorre valorizzare tutti i "+this.panelDef.params.size+" parametri del PanelDef:"+loc() :
	this.config != null && this.config.paramValues.size == this.panelDef.params.size;	

context PanelDef ERROR "Non è possibile utilizzare un PanelDefUse all'interno di un PanelDef:"+loc() :
	this.eAllContents.typeSelect(PanelDefUse).size==0;

// [AM] rimuovere il check quando sarà implementata la funzione
context PanelDef ERROR "onRefreshCommand su PanelDef: feature non implementata:"+loc() :
	this.onRefreshCommand == null;

//////////////////////////////////////////////////////////////////////////////
//// constraints su commands
//////////////////////////////////////////////////////////////////////////////	
context CommandOutcome ERROR "Un CommandOutcome deve avere associata un comando effettivo "+loc() :  
	this.command != null;
	
context SequenceCommand ERROR "Una SequenceCommand deve prevedere almeno uno step nella sequenza di comandi "+loc() :
	this.commands!= null && this.commands.size>0;

context SequenceCommand ERROR "Solo l'ultimo step di un SequenceCommand può essere un JumpCommand "+loc() :
	(this.commands.select(a|a.metaType == JumpCommand).size==0) ||
	  (this.commands.select(a|a.metaType == JumpCommand).size==1) && (this.commands.last().metaType == JumpCommand)
	;

context SequenceCommand ERROR "Solo l'ultimo step di un SequenceCommand può essere un JumpExtCommand "+loc() :
	(this.commands.select(a|a.metaType == JumpExtCommand).size==0) ||
	  (this.commands.select(a|a.metaType == JumpExtCommand).size==1) && (this.commands.last().metaType == JumpExtCommand)
	;

context SequenceCommand ERROR "Solo l'ultimo step di un SequenceCommand può essere un JumpBackCommand "+loc() :
	(this.commands.select(a|a.metaType == JumpBackCommand).size==0) ||
	  (this.commands.select(a|a.metaType == JumpBackCommand).size==1) && (this.commands.last().metaType == JumpBackCommand);

//context SequenceAction ERROR "Solo l'ultimo step di una SequenceAction può essere una ShowDialogAction "+loc() :
//	(this.actions.select(a|a.metaType == ShowDialogAction).size==0) ||
//	  (this.actions.select(a|a.metaType == ShowDialogAction).size==1) && (this.actions.last().metaType == ShowDialogAction);

context CommandOnWidgets ERROR "I comandi che hanno come oggeto un widget devono essere associati ad almeno un widget "+loc() :
	this.targetWidgets != null && this.targetWidgets.size>0;


////////////////////////////////////////////////////////////////////////////////////////
/// constraints su security model
////////////////////////////////////////////////////////////////////////////////////////

context SecurityModel ERROR "Occorre specificare il codice identificativo dell'applicazione per il sistema di sicurezza (es. id app. per IRIDE2) "+loc() :
	this.securityAppID!=null;

context OPAUTHSSO ERROR "I liveli minimi di autenticazione possibili sono: [1]=username+passwd, [2]=username+passwd+pin, [3]=certificato "+loc() :
	this.minAuthLevel>=1 && this.minAuthLevel<=3;

context CustomAuthentication ERROR "Il meccanismo di autenticazione custom non è attualmente implementato " :
	false;

context CustomSecurityConstraint ERROR "E' necessario specificare il nome del metodo: "+loc() :
	!isNullOrEmpty(this.methodNameSuffix);

context UISecurityConstraint if (this.eRootContainer.metaType==GUIModel) ERROR "Non è possibile specificare constraint di AUTORIZZAZIONE "+
"se non è specificato un metodo di AUTENTICAZIONE "+loc() :
	((GUIModel)this.eRootContainer).securityModel.autenticationMethod != null ||
	((GUIModel)this.eRootContainer).extSecurityModel.autenticationMethod != null;

context UISecurityConstraint if (this.eRootContainer.metaType==AppModule) ERROR "Non è possibile specificare constraint di AUTORIZZAZIONE "+
"se non è specificato un metodo di AUTENTICAZIONE "+loc() :
	((AppModule)this.eRootContainer).extSecurityModel.autenticationMethod != null;


	
context Actor ERROR "E'necessario specificare il codice IRIDE2 dell'actor "+loc() :
	code!=null;

context Role ERROR "E'necessario specificare il codice IRIDE2 del role "+loc() :
	code!=null;

context UseCase ERROR "E'necessario specificare il codice IRIDE2 dello use-case "+loc() :
	code!=null;
	
context UCBasedSecurityConstraint ERROR "E' necessario specificare lo use-case a cui il security constraint si riferisce "+loc() :
	this.useCase!=null;

context ActorBasedSecurityConstraint ERROR "E' necessario specificare l'actor a cui il security constraint si riferisce "+loc() :
	this.actor!=null;

context RoleBasedSecurityConstraint ERROR "E' necessario specificare il role a cui il security constraint si riferisce "+loc() :
	this.role!=null;

	
context UISecurityConstraint ERROR "Non è possibile specificare un UI security constraint in cui il widget"+
" deve essere abilitato e contemporaneamente invisibile "+loc() :
	this.enabled==false || !(enabled==true && visible==true);

context UISecurityConstraint ERROR "Non è possibile specificare un UI security constraint su un widget dichiarato required: "+loc() :
	(DataWidget.isAssignableFrom(eContainer.metaType)?
		(((DataWidget)eContainer).required==false) 
		:
	 	true
	);

/// verifica se sono presenti il tipo UserInfo e l'app data currentUser
context SecurityModel ERROR "Se è presente l'autenticazione deve essere definito il tipo 'UserInfo'" :
	((List[Type])getAllTypes((GUIModel)this.eRootContainer)).findByName("UserInfo") != null;	
	
context SecurityModel ERROR "Se è presente l'autenticazione deve essere definito l'application data 'currentUser'" :
	((List[ApplicationData])getAllApplicationData((GUIModel)this.eRootContainer)).findByName("currentUser") != null;


// check di referenziazione dell'Appdata currentUser dai pannelli interni al GUIModel
context ContentPanel if (eRootContainer.metaType==GUIModel) ERROR "Se è presente l'autenticazione ogni content panel deve referenziare l'application data \"currentUser\"" :
	((GUIModel)this.eRootContainer).securityModel==null ||
	appData.select(ab|ab.name=="currentUser").size==1;

// check di referenziazione dell'appdata current user dai pannelli inclusi (usa feature avanzate di extend!)
context ApplicationArea if (extModules.size>0 && ((GUIModel)eRootContainer).securityModel!=null) ERROR 
"Se è presente l'autenticazione ogni content panel deve referenziare l'application data \"currentUser\""+
"- pannelli ch enon referenziano:"+extModules.contentPanels.select(cp|cp.appData.select(ab|ab.name=="currentUser").size==0).name :
	extModules.contentPanels.appData.select(ab|ab.name=="currentUser").size==extModules.contentPanels.size;
	
	
	
///// ActivationModel

context ActivationParam ERROR "E'necessario specificare il nome del paramtero di attivazione:"+loc() :
	!isNullOrEmpty(name);

context ActivationParam ERROR "E'necessario specificare il tipo del parametro di attivazione:"+loc() :
	type != null;
	
/// check per evitare che i parametri vadano in conflitto con app data o property implicite dei widget
context ActivationParam if (!isNullOrEmpty(name))ERROR "Un paramtero di attivazione non puo avere un nome che inizia con 'AppData/appData' o 'widg_/Widg_':"+loc() :
	!name.toLowerCase().startsWith("appdata") && !name.toLowerCase().startsWith("widg_");