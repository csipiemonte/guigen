«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR AutenticationMethod»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR SSOBARTSSO»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR CustomAuthentication»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR OPAUTHSSO»
	<!-- ############################################################### 
         definizione filter per autentication con OPAUTH (oracle portal) 
         ###############################################################
    -->
	<filter>
		<filter-name>OP Filter</filter-name>
		<filter-class>it.csi.opauth.filter.OPFilter</filter-class>
		<init-param>
			<param-name>it.csi.opauth.filter.loginAccessUrl</param-name>
			<param-value>
				http://@OP_SERVER@/portal/pls/portal/csi_custom.ext_login
			</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.minAuthLevel</param-name>
			<param-value>«this.minAuthLevel»</param-value>
		</init-param>
		<init-param>
			<param-name>logger</param-name>
			<param-value>@APP_PREFIX@.OPclient</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.serverName</param-name>
			<param-value>@DEFAULT_APP_SERVER@</param-value>
		</init-param>
	</filter>

    «EXPAND irideIdFilterDef(model) FOR this»
    
	<!-- ################################################################
	     il filter di autenticazione e' il primo ad essere innescato
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>OP Filter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
	«EXPAND irideIdFilterMap(model) FOR this»
«ENDDEFINE»

«DEFINE irideIdFilterDef(GUIModel model) FOR AutenticationMethod»
	<filter>
		<filter-name>IRIDE ID Adapter</filter-name>
		<filter-class>«getIrideIdAdapterFilterFQN(model)»</filter-class>
	</filter>
«ENDDEFINE»

«DEFINE irideIdFilterMap(GUIModel model) FOR AutenticationMethod»
	
	<!-- ################################################################
	     il filter di adattamento iride e' il successivo dopo 
	     l'autenticazione
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>IRIDE ID Adapter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR OPAUTHSSO»
	<!-- replace variabili di environment per opauth -->
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@OP_SERVER@"  
		value="${opauth.server.url}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@APP_PREFIX@"  
		value="${componente}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@DEFAULT_APP_SERVER@"  
		value="${opauth.default.appserver}"/>	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE envConfigForAuthorization(GUIModel model) FOR SecurityModel»
	<!-- replace variabili di environment per opauth -->
	<replace file="${build}/temp/«getSpringIRIDE2PDConfig(model)»" 
		token="@IRIDE_PROVIDER_URL@"  
		value="${iride2.pep.provider.url}"/>	
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR OPAUTHSSO»
#-[configurazione opauth]--------------------------------------------------
opauth.server.url = spintest.csi.it:7778
opauth.default.appserver = localhost:8078
opauth.logout.url = http://spintest.csi.it:7778/portal/page/portal/sistemapiemonte/logout
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE templatePropsForAuthorization(GUIModel model) FOR SecurityModel»
#-[configurazione iride2]--------------------------------------------------
iride2.pep.provider.url = t3://dev-exp01wls1.csi.it, dev-exp02wls2.csi.it:7111

«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR OPAUTHSSO»
	
	<!-- ############################################################## -->
    <!-- # OPAUTH                                                     # -->
    <!-- ############################################################## -->
	<dependency org="csipiemonte" name="opauth4j" rev="1.0.2" />
    <!-- <dependency org="csipiemonte" name="iride-simulation" rev="1.1.0" /> -->
    <!-- <dependency org="csipiemonte" name="simula" rev="1.1.0" /> -->    
    <!-- ############################################################## -->
    <!-- # IBM                                                        # -->
    <!-- ############################################################## -->
    <!--  -->
    <dependency org="ibm" name="xml" rev="1.0.0" />
    
«ENDDEFINE»

«REM»le librerie client weblogic sono da aggiungere solo se la target
	 platform è JBOSS
«ENDREM»
«DEFINE ivyDependenciesForAuthorization(GUIModel model) FOR SecurityModel-»
«IF model.targetPlatform.code==TargetPlatformCodes::JBoss43-»
	<!-- ############################################################## -->
    <!-- # WEBLOGIC CLIENT (solo per JBoss)                           # -->
    <!-- ############################################################## -->
    <!--  -->
    <dependency org="csipiemonte" name="weblogic-client" rev="3.0.0" />
«ENDIF-»   
«ENDDEFINE»

«DEFINE securityJavaFiles(boolean skip) FOR GUIModel»
«IF this.securityModel.autenticationMethod!=null»
«EXPAND IrideIdMaterializerFilter(this) FOR this.securityModel.autenticationMethod»
«EXPAND constraintJavaFiles FOR this»
«EXPAND springSecurityHelperClasses FOR this»
«EXPAND iride2PDFile FOR this»
«ENDIF»
«ENDDEFINE»

«DEFINE constraintJavaFiles FOR GUIModel»
«FILE getSecurityJavaSrcDir(this,true)+"/UISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage(this)+".business.*;"»

public interface UISecConstraint {

	public static final int ONOFF_CONSTRAINED_BEHAVIOR = 1;
	public static final int VISIB_CONSTRAINED_BEHAVIOR = 2;
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh);
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/AbstractUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public abstract class AbstractUISecConstraint implements UISecConstraint{

protected int constrainedBehavior = UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR;
protected boolean defaultState;
protected String nomeContainer;
protected String nomeWidget;

public AbstractUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
	if (nomeContainer==null||nomeWidget==null)
		throw new IllegalArgumentException("Errore interno: nome container e nome widget obbligatori per constraint");
	if (constrainedBehavior!=UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR && 
		constrainedBehavior!=UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR)
		throw new IllegalArgumentException("Errore interno: comportamento oggetto di constraint non gestibile:"+constrainedBehavior);
	this.nomeContainer=nomeContainer;
	this.nomeWidget=nomeWidget;
	this.constrainedBehavior=constrainedBehavior;
	this.defaultState=defaultState;
}
	/**
	 * Combina adeguatamente:
	 * <ul>
	 * <li>l'esito della verifica specifica
	 * <li>lo stato di default (relativo al comportamento oggetto di constraint - visibilità o abilitazione)
	 * <li>lo stato corrente  (relativo al comportamento oggetto di constraint - visibilità o abilitazione)
	 * </ul>
	 * In sintesi il comportamento oggetto di constraint sarà così valutato:
	 * <ul>
	 * <li>se lo stato corrente non è specificato (il widget non è stato impostato esplicitamente
	 *     ad invisibile o disabilitato) viene utilizzato come stato corrente lo stato di default
	 * <li>se lo stato corrente combinato (corrente effettivo + default) è OFF (invisibile o disabilitato)
	 *     lo stato finale o OFF
	 * <li>se lo stato corrente combinato (corrente effettivo + default) è ON, viene eseguito
	 *     il check specifico (che dipende dat tipo di constraint) e lo stato finale è 
	 *     ON (visibile o abilitato) se il check specifico è verificato, OFF altrimenti.
	 * </ul>
	 * @param session mantiene lo stato corrente del widget
	 * @return
	 */
	protected boolean combineAll(Map session, int checkedBehavior, SecurityHelper sh) {
		if(checkedBehavior!=this.constrainedBehavior)
			return false; // se il comportamento osservato è un'altro passo oltre
		else{
			Boolean currentState = getCurrentState(session);
			if (currentState == null)
				currentState = new Boolean(defaultState);
			if (currentState.booleanValue() == false)
				return false;
			else
				return specificCheck(session, sh);
		}
	}

	/**
	 * Cerca in sessione lo stato corrente.
	 * @return null se lo stato (per il comportamento in osservazione) non è impostato oppure
	 * il valore effettivo se questo è impostato.
	 */
	protected Boolean getCurrentState(Map session){
		String behaviorSuffix = "";
		switch (constrainedBehavior) {
		case UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_enabled";
			break;
		case UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_visible";
			break;
		default:
			break;
		} 
		Map cpData = (Map) session.get(nomeContainer);
		if (cpData != null) {
			Boolean behaviorFlag = (Boolean) cpData.get(nomeWidget
					+ behaviorSuffix);
			if (behaviorFlag != null) {
				return behaviorFlag.booleanValue();
			} else
				return null; // unspecified current state
		} else
			return null; // unspecified current state
	}
	
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh) {
		
		return combineAll(session, checkedBehavior, sh);
	}
	
	/**
	 * Questo metodo è ridefinito nelle varie tipologie di constraint e implementa
	 * i check specifici
	 * @param session
	 * @return
	 */
	public abstract boolean specificCheck(Map session, SecurityHelper sh);
	
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/CustomUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class CustomUISecConstraint extends AbstractUISecConstraint {

	public CustomUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
		super(nomeContainer,nomeWidget,constrainedBehavior,defaultState);
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh) {
		// TODO Auto-generated method stub
		return true;
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ActorBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class ActorBasedUISecConstraint extends AbstractUISecConstraint {

	private String actorCode;
	
	public ActorBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String actorCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.actorCode=actorCode;
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh) {
		return sh.verifyCurrentUserForActor(session, actorCode);
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/UCBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class UCBasedUISecConstraint extends AbstractUISecConstraint {

	private String useCaseCode;
	
	public UCBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String useCaseCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.useCaseCode=useCaseCode;
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh) {
		return sh.verifyCurrentUserForUC(session, useCaseCode);
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ComplexUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class ComplexUISecConstraint implements UISecConstraint {

	protected UISecConstraint [] constraints = null;
	
	public ComplexUISecConstraint(UISecConstraint [] constraints) {
		this.constraints=constraints;
	}
	
	/**
	 * Verifica se almeno uno dei constraints è soddisfatto.
	 */
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh) {
		if (constraints!=null && constraints.length>0){
			boolean verified = false;
			for (int i = 0; i < constraints.length || verified; i++) {
				UISecConstraint currCtr = constraints[i];
				verified |= currCtr.verifyConstraint(session, checkedBehavior, sh);
			}
			return verified;
		}
		else
			return true;
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE IrideIdMaterializerFilter(GUIModel model) FOR AutenticationMethod»
«FILE getIrideIdAdapterFilterJavaFile(model, true)»package «getFiltersJavaPackage(model)»;

import it.csi.iride2.policy.entity.Identita;
import it.csi.iride2.policy.exceptions.MalformedIdTokenException;

import java.io.IOException;
import java.util.StringTokenizer;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import «getBaseJavaPackage(model)+".business.*;"»

/**
 * Inserisce in sessione l'identità digitale relativa all'utente autenticato.
 * Funge da adapter tra il filter del metodo di autenticaizone previsto e la
 * logica applicativa.
 * @author CSIPiemonte
 *
 */
public class IrideIdAdapterFilter implements Filter{

	public static final String IRIDE_ID_SESSIONATTR = "iride2_id";
	
	public static final String AUTH_ID_MARKER = "it.csi.opauth.filter.identita";
	
	public void doFilter(ServletRequest req, ServletResponse resp,
			FilterChain fchn) throws IOException, ServletException {
		HttpServletRequest hreq = (HttpServletRequest)req;
		if (hreq.getSession().getAttribute(IRIDE_ID_SESSIONATTR)==null){
			String marker = (String)hreq.getSession().getAttribute(AUTH_ID_MARKER);
			if (marker!=null){
				try {
					Identita identita = new Identita(normalizeToken(marker));
					System.out.println("Inserito in sessione marcatore IRIDE:"+identita);
					hreq.getSession().setAttribute(IRIDE_ID_SESSIONATTR, identita);
				} catch (MalformedIdTokenException e) {
					// TODO mettere a posto messaggio
					e.printStackTrace();
				}
			}
		}
		
		fchn.doFilter(req, resp);
		
	}

	public void destroy() {
		// NOP
	}

	public void init(FilterConfig arg0) throws ServletException {
		// NOP
	}

	private String normalizeToken(String token){
		String tmp = null;
		
		if(token.indexOf("~") == -1){
			return token;
		}else{
			String[] tok = token.split("~");
			tmp = tok[6]+"/"+tok[4];
		}
				
		return tmp;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE getPageUIConstraintDef(GUIModel model) FOR ContentPanel»
	protected Map<String, UISecConstraint> getPageVisibilityUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "VISIB") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
	
	protected Map<String, UISecConstraint> getPageONOFFUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "ONOFF") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
«ENDDEFINE»


«DEFINE uiConstraint(GUIModel model, String behavior) FOR Widget-»
«IF securityConstraints.size>0-»
		// constraints per «this»
«FOREACH this.securityConstraints AS currConstraint-»
		UISecConstraint «name»_«securityConstraints.indexOf(currConstraint)»_ctr =
		«EXPAND uiConstraintNew(model) FOR currConstraint-» 
«ENDFOREACH-»
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
		«LET (behavior=="VISIB" ? securityConstraints.select(c|c.visible): securityConstraints.select(c|c.enabled)) AS selectedConstraints-»
			«FOREACH selectedConstraints AS currConstraint-»
			«name»_«securityConstraints.indexOf(currConstraint)»_ctr«IF securityConstraints.last()!=currConstraint»,«ENDIF»
			«ENDFOREACH-»
		«ENDLET-»
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ENDIF-»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR UISecurityConstraint»
 			null; /// ERRORE: constraint non gestito «this»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR CustomSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new CustomUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»
 			){
 				@Override
					public boolean specificCheck(Map session, SecurityHelper sh) {
						return getSpringSecurityHelper().customCheck«methodNameSuffix.toFirstUpper()»(session);
					}
 			};
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE uiConstraintNew(GUIModel model) FOR UCBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new UCBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.useCase.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR ActorBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new ActorBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.actor.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE securedWidgetCheck(GUIModel modle) FOR ContentPanel»
// ridefinizione dei metodi di verifica visibilità/validazione
// per supportare i security check

	public boolean isWidgetDisabled(String cpName, String widgShortName) {
		UISecConstraint ctr = allOnOffConstraints.get(widgShortName);
		if (ctr!=null)
			return !ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
		else
			return super.isWidgetDisabled(cpName, widgShortName);
	}
	
	public boolean isWidgetVisible(String cpName, String widgShortName) {
		UISecConstraint ctr = allVisibilityConstraints.get(widgShortName);
		if (ctr!=null)
			return ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
		else
			return super.isWidgetVisible(cpName, widgShortName);
	}

«ENDDEFINE»



«DEFINE springSecurityHelperClasses FOR GUIModel-»
«FILE getSpringSecurityHelperJavaFile()»
package «getBaseJavaPackage()».business;

import java.util.*;
import java.io.*;
import it.csi.csi.porte.InfoPortaDelegata;
import it.csi.csi.porte.proxy.PDProxy;
import it.csi.csi.util.xml.PDConfigReader;
import it.csi.csi.wrapper.SystemException;
import it.csi.csi.wrapper.UnrecoverableException;
import it.csi.iride2.policy.entity.*;
import it.csi.iride2.policy.exceptions.*;
import it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService;
import «getDTOBaseJavaPackage()».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperImports")»

«ENDPROTECT»

public class «getSpringSecurityHelperClassName()»{

       

    //////////////////////////////////////////////////////////////////////////////
	/// Metodi di supporto alla sicurezza.
	//////////////////////////////////////////////////////////////////////////////
	«EXPAND springSecurityHelperMethods FOR this»
	
	//////////////////////////////////////////////////////////////////////////////
	/// Property aggiuntive del bean
	//////////////////////////////////////////////////////////////////////////////
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperProperties")»
	//// inserire qui le property che si vogliono iniettare in questo bean (es. dao, proxy di pd, ...) 
«ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»

«DEFINE springSecurityHelperMethods FOR GUIModel»
	«EXPAND irideHelperMethods FOR this»
	«EXPAND customConstraintsMethods FOR this»
«ENDDEFINE»

«DEFINE irideHelperMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza basata su IRIDE2
	///////////////////////////////////////////////////////////////////////////////
	
	public final static String IRIDE_PEP_RESOURCE = "/META-INF/iride2_pep_defPD_ejb.xml";
	
	it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService iride = null;
	
	protected PolicyEnforcerBaseService getIridePEP(){
		if (this.iride==null){
			InputStream is = getClass().getResourceAsStream(IRIDE_PEP_RESOURCE);
			if (is != null){
				try {
					InfoPortaDelegata info = PDConfigReader.read(is);
					this.iride = (PolicyEnforcerBaseService)PDProxy.newInstance(info);
					return this.iride;
				} 
				catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
					throw new IllegalArgumentException("errore nella parsificazione della configurazione di IRIDE2");
				}
			}
			else 
				// TODO gestire log
				throw new IllegalArgumentException("configurazione di IRIDE2 non trovata");
		} 
		else
			return this.iride;
	}
	
	public static final String IRIDE_ID_SESSIONATTR = "iride2_id";
	
	protected Identita getCurrentUser(Map session){
		Identita id = (Identita)session.get(IRIDE_ID_SESSIONATTR);
		if (id == null){
			// TODO log
			throw new IllegalStateException("Errore nel reperimento del current user dalla sessione: attributo non trovato");
		}
		else{
			return id;
		}
	}
	
	public final static Application IRIDE2_APPLICATION = new Application("«this.securityModel.securityAppID»");;
	
	public boolean verifyCurrentUserForUC(Map session, String useCaseCode){
		Identita currentUser = getCurrentUser(session);
		UseCase uc = new UseCase();
		 
		uc.setAppId(IRIDE2_APPLICATION);
		uc.setId(useCaseCode);
		try {
			return getIridePEP().isPersonaAutorizzataInUseCase(getCurrentUser(session), uc);
		} catch (InternalException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore interno in verifyCurrentUserForUC:"+e);
		} catch (IdentitaNonAutenticaException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("verifyCurrentUserForUC: identità non autentica ["+currentUser+"],"+e);
		} catch (NoSuchUseCaseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("verifyCurrentUserForUC: use case ["+uc+"] non valido"+e);
		} catch (NoSuchApplicationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("verifyCurrentUserForUC: applicazione "+IRIDE2_APPLICATION+" non valida"+e);
		} catch (UnrecoverableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore non recuperabile in verifyCurrentUserForUC:"+e);
		} catch (SystemException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore di sistema in verifyCurrentUserForUC:"+e);
		}
		catch(Throwable e){
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore interno in verifyCurrentUserForUC:"+e);
		}
	}
	
	public boolean verifyCurrentUserForActor(Map session, String actorCode){
		Identita currentUser = getCurrentUser(session);
		Actor act = new Actor();
		 
		act.setAppId(IRIDE2_APPLICATION);
		act.setId(actorCode);
		try {
			Actor [] actors = getIridePEP().findActorsForPersonaInApplication(currentUser, IRIDE2_APPLICATION);
			if (actors!=null){
				for (int i = 0; i < actors.length; i++) {
					Actor actor = actors[i];
					if (actor.equals(act))
						return true;
				}
				return false;
			}
			else
				return false;
		} catch (InternalException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore interno in verifyCurrentUserForUC:"+e);
		} catch (IdentitaNonAutenticaException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("verifyCurrentUserForUC: identità non autentica ["+currentUser+"],"+e);
		} catch (NoSuchApplicationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("verifyCurrentUserForUC: applicazione "+IRIDE2_APPLICATION+" non valida"+e);
		} catch (UnrecoverableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore non recuperabile in verifyCurrentUserForUC:"+e);
		} catch (SystemException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore di sistema in verifyCurrentUserForUC:"+e);
		}
		catch(Throwable e){
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException("Errore interno in verifyCurrentUserForUC:"+e);
		}
	}
«ENDDEFINE»

«DEFINE customConstraintsMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza custom
	///////////////////////////////////////////////////////////////////////////////
	
	«FOREACH structure.appWindow.appArea.contentPanels AS cp-»
	«LET (List[Widget])findAllWidgetsInContentPanel(cp) AS cpWidgets-»
	«LET cpWidgets.select(w|w.securityConstraints.select(c|c.metaType==CustomSecurityConstraint).size>0) AS allCustomConstrainedWidgets-»
	«FOREACH (List[CustomSecurityConstraint])(allCustomConstrainedWidgets.securityConstraints.select(c|c.metaType==CustomSecurityConstraint)) AS currCustomSC-»
	public boolean customCheck«currCustomSC.methodNameSuffix.toFirstUpper()» (Map session){
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("customCheck"+currCustomSC.methodNameSuffix)-»
		/// inserire qui il codice del controllo custom
		return true;
		«ENDPROTECT»
	}
	«ENDFOREACH-»
	«ENDLET-»
	«ENDLET-»
	«ENDFOREACH-»
«ENDDEFINE»


«DEFINE iride2PDFile FOR GUIModel»
«FILE getSpringIRIDE2PDConfig()»<porta-delegata name="PolicyEnforcerBase">
  <services>
    <service
      name="PolicyEnforcerBase"
      public-interface-class="it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService">
      <operations>
        <operation name="identificaUserPassword" type="synch-call">
          <param-list>
            <param name="username" type="java.lang.String" />
            <param name="password" type="java.lang.String" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="identificaUserPasswordPIN" type="synch-call">
          <param-list>
            <param name="username" type="java.lang.String" />
            <param name="password" type="java.lang.String" />
            <param name="pin" type="java.lang.String" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="identificaCertificato" type="synch-call">
          <param-list>
            <param name="certificato" type="byte[]" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="isPersonaAutorizzataInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="isPersonaInRuolo" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="ruolo" type="it.csi.iride2.iridefed.entity.Ruolo" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="getInfoPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="java.lang.String"/>
        </operation>
        <operation name="findRuoliForPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="it.csi.iride2.iridefed.entity.Ruolo[]"/>
        </operation>
        <operation name="findRuoliForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.iridefed.entity.Ruolo[]"/>
        </operation>
        <operation name="findUseCasesForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.UseCase[]"/>
        </operation>
        <operation name="findActorsForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Actor[]"/>
        </operation>
        <operation name="isIdentitaAutentica" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="getInfoPersonaSchema" type="synch-call">
          <param-list>
            <param name="codRuolo" type="it.csi.iride2.iridefed.entity.Ruolo" />
          </param-list>
          <ret-val type="java.lang.String"/>
        </operation>
        <operation name="findActorsForPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Actor[]"/>
        </operation>
      </operations>
    </service>
  </services>
  <config>
    <url-pa>multi://pc41012.csi.it</url-pa>
    <pluggable-pd-list chooser-class="it.csi.csi.porte.FixedDelegateChooser">
      <pluggable-pd
        name="policyEnf"
        class="it.csi.csi.porte.ejb.PortaDelegataEJB"
        url-pa="iride2/policy/PolicyEnforcementPoint_PA" >
        <properties>
          <property name="java.naming.provider.url" value="@IRIDE_PROVIDER_URL@" />
          <property name="java.naming.factory.initial" value="weblogic.jndi.WLInitialContextFactory" />
          <property name="csi.auth.jaas.client.class" value="it.csi.csi.porte.ejb.jaas.weblogic.WeblogicJAASNativeClient" />
          <property name="csi.auth.basic" value="" />
        </properties>
      </pluggable-pd>
    </pluggable-pd-list>
    <queue-manager url="rmi://:2001/QMgrCli"/>
  </config>
</porta-delegata>
«ENDFILE»
«ENDDEFINE»