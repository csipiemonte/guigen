«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE securityRelatedContextParams(GUIModel model) FOR AutenticationMethod»
«ERROR "authentication method non supportato:" + this.metaType»»
«ENDDEFINE»

«DEFINE securityRelatedContextParams(GUIModel model) FOR SSOBARTSSO»
«ERROR "authentication method non supportato:" + this.metaType»»
«ENDDEFINE»

«DEFINE securityRelatedContextParams(GUIModel model) FOR OPAUTHSSO»
	<context-param>
		<param-name>logoutURL</param-name>
		<param-value>@LOGOUT_URL@</param-value>
	</context-param>
«ENDDEFINE»


«DEFINE securityRelatedContextParams(GUIModel model) FOR CustomAuthentication»
«ERROR "authentication method non supportato:" + this.metaType»»
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR AutenticationMethod»
«ERROR "authentication method non supportato:" + this.metaType»»
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR SSOBARTSSO»
	<context-param>
		<param-name>logoutURL</param-name>
		<param-value>@LOGOUT_URL@</param-value>
	</context-param>
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR CustomAuthentication»
«ERROR "authentication method non supportato:" + this.metaType»
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR OPAUTHSSO»
	<!-- ############################################################### 
         definizione filter per autentication con OPAUTH (oracle portal) 
         ###############################################################
    -->
	<filter>
		<filter-name>OP Filter</filter-name>
		<filter-class>it.csi.opauth.filter.OPFilter</filter-class>
		<init-param>
			<param-name>it.csi.opauth.filter.loginAccessUrl</param-name>
			<param-value>
				http://@OP_SERVER@/portal/pls/portal/csi_custom.ext_login
			</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.minAuthLevel</param-name>
			<param-value>«this.minAuthLevel»</param-value>
		</init-param>
		<init-param>
			<param-name>logger</param-name>
			<param-value>@APP_PREFIX@.OPclient</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.serverName</param-name>
			<param-value>@DEFAULT_APP_SERVER@</param-value>
		</init-param>
	</filter>

    «EXPAND irideIdFilterDef(model) FOR this»
    
	<!-- ################################################################
	     il filter di autenticazione e' il primo ad essere innescato
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>OP Filter</filter-name>
		<url-pattern>/HomePage.do</url-pattern>
	</filter-mapping>
	
	«EXPAND irideIdFilterMap(model) FOR this»
«ENDDEFINE»

«DEFINE irideIdFilterDef(GUIModel model) FOR AutenticationMethod»
	<filter>
		<filter-name>IRIDE ID Adapter</filter-name>
		<filter-class>«getIrideIdAdapterFilterFQN(model)»</filter-class>
	</filter>
«ENDDEFINE»

«DEFINE irideIdFilterMap(GUIModel model) FOR AutenticationMethod»
	
	<!-- ################################################################
	     il filter di adattamento iride e' il successivo dopo 
	     l'autenticazione
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>IRIDE ID Adapter</filter-name>
		<url-pattern>/HomePage.do</url-pattern>
	</filter-mapping>
	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR OPAUTHSSO»
	<!-- replace variabili di environment per opauth -->
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@OP_SERVER@"  
		value="${opauth.server.url}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@APP_PREFIX@"  
		value="${componente}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@DEFAULT_APP_SERVER@"  
		value="${opauth.default.appserver}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@LOGOUT_URL@"  
		value="${opauth.logout.url}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/struts-global.xml" 
		token="@LOGOUT_URL@"  
		value="${opauth.logout.url}"/>	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE envConfigForAuthorization(GUIModel model) FOR SecurityModel»
	<!-- replace variabili di environment per opauth -->
	<replace file="${build}/temp/«getSpringIRIDE2PDConfig(model)»" 
		token="@IRIDE_PROVIDER_URL@"  
		value="${iride2.pep.provider.url}"/>	
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR OPAUTHSSO»
#-[configurazione opauth]--------------------------------------------------
opauth.server.url = spintest.csi.it:7778
opauth.default.appserver = localhost:8078
opauth.logout.url = http://spintest.csi.it:7778/portal/page/portal/sistemapiemonte/logout
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE templatePropsForAuthorization(GUIModel model) FOR SecurityModel»
#-[configurazione iride2]--------------------------------------------------
iride2.pep.provider.url = t3://dev-exp01wls1.csi.it, dev-exp02wls2.csi.it:7111

«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR OPAUTHSSO»
	
	<!-- ############################################################## -->
    <!-- # OPAUTH                                                     # -->
    <!-- ############################################################## -->
	<dependency org="csipiemonte" name="opauth4j" rev="1.0.2" />
    <!-- <dependency org="csipiemonte" name="iride-simulation" rev="1.1.0" /> -->
    <!-- <dependency org="csipiemonte" name="simula" rev="1.1.0" /> -->    
    <!-- ############################################################## -->
    <!-- # IBM                                                        # -->
    <!-- ############################################################## -->
    <!--  -->
    <dependency org="ibm" name="xml" rev="1.0.0" />
    
«ENDDEFINE»

«REM»le librerie client weblogic sono da aggiungere solo se la target
	 platform è JBOSS
«ENDREM»
«DEFINE ivyDependenciesForAuthorization(GUIModel model) FOR SecurityModel-»
«IF model.targetPlatform.code==TargetPlatformCodes::JBoss43-»
	<!-- ############################################################## -->
    <!-- # WEBLOGIC CLIENT (solo per JBoss)                           # -->
    <!-- ############################################################## -->
    <!--  -->
    <dependency org="csipiemonte" name="weblogic-client" rev="3.0.0" />
«ENDIF-»   
«ENDDEFINE»

«DEFINE securityJavaFiles(boolean skip) FOR GUIModel»
«EXPAND ApplSessGuardFilter FOR this»
«IF this.securityModel.autenticationMethod!=null»
«EXPAND IrideIdMaterializerFilter(this) FOR this.securityModel.autenticationMethod»
«EXPAND iridePDCacheClass(this) FOR this.securityModel»
«EXPAND iride2PDFile FOR this»
«ENDIF»
«EXPAND constraintJavaFiles FOR this»
«EXPAND springSecurityHelperClasses FOR this»
«ENDDEFINE»

«DEFINE constraintJavaFiles FOR GUIModel»
«FILE getSecurityJavaSrcDir(this,true)+"/UISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage(this)+".business.*;"»

public interface UISecConstraint {

	public static final int ONOFF_CONSTRAINED_BEHAVIOR = 1;
	public static final int VISIB_CONSTRAINED_BEHAVIOR = 2;
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh) throws BEException;
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/AbstractUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public abstract class AbstractUISecConstraint implements UISecConstraint{

protected int constrainedBehavior = UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR;
protected boolean defaultState;
protected String nomeContainer;
protected String nomeWidget;

public AbstractUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
	if (nomeContainer==null||nomeWidget==null)
		throw new IllegalArgumentException("Errore interno: nome container e nome widget obbligatori per constraint");
	if (constrainedBehavior!=UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR && 
		constrainedBehavior!=UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR)
		throw new IllegalArgumentException("Errore interno: comportamento oggetto di constraint non gestibile:"+constrainedBehavior);
	this.nomeContainer=nomeContainer;
	this.nomeWidget=nomeWidget;
	this.constrainedBehavior=constrainedBehavior;
	this.defaultState=defaultState;
}
	/**
	 * Combina adeguatamente:
	 * <ul>
	 * <li>l'esito della verifica specifica
	 * <li>lo stato di default (relativo al comportamento oggetto di constraint - visibilit&agrave; o abilitazione)
	 * <li>lo stato corrente  (relativo al comportamento oggetto di constraint - visibilit&agrave; o abilitazione)
	 * </ul>
	 * In sintesi il comportamento oggetto di constraint sar&agrave; cos&igrave; valutato:
	 * <ul>
	 * <li>se lo stato corrente non &egrave; specificato (il widget non &egrave; stato impostato esplicitamente
	 *     ad invisibile o disabilitato) viene utilizzato come stato corrente lo stato di default
	 * <li>se lo stato corrente combinato (corrente effettivo + default) &egrave; OFF (invisibile o disabilitato)
	 *     lo stato finale o OFF
	 * <li>se lo stato corrente combinato (corrente effettivo + default) &egrave; ON, viene eseguito
	 *     il check specifico (che dipende dat tipo di constraint) e lo stato finale &egrave; 
	 *     ON (visibile o abilitato) se il check specifico &egrave; verificato, OFF altrimenti.
	 * </ul>
	 * @param session mantiene lo stato corrente del widget
	 * @return
	 */
	protected boolean combineAll(Map session, int checkedBehavior, SecurityHelper sh)  throws BEException{
		if(checkedBehavior!=this.constrainedBehavior)
			return false; // se il comportamento osservato e' un'altro passo oltre
		else{
			Boolean currentState = getCurrentState(session);
			if (currentState == null)
				currentState = new Boolean(defaultState);
			if (currentState.booleanValue() == false)
				return false;
			else
				return specificCheck(session, sh);
		}
	}

	/**
	 * Cerca in sessione lo stato corrente.
	 * @return null se lo stato (per il comportamento in osservazione) non &egrave; impostato oppure
	 * il valore effettivo se questo &egrave; impostato.
	 */
	protected Boolean getCurrentState(Map session){
		String behaviorSuffix = "";
		switch (constrainedBehavior) {
		case UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_enabled";
			break;
		case UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_visible";
			break;
		default:
			break;
		} 
		Map cpData = (Map) session.get(nomeContainer);
		if (cpData != null) {
			Boolean behaviorFlag = (Boolean) cpData.get(nomeWidget
					+ behaviorSuffix);
			if (behaviorFlag != null) {
				return behaviorFlag.booleanValue();
			} else
				return null; // unspecified current state
		} else
			return null; // unspecified current state
	}
	
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh)  throws BEException{
		
		return combineAll(session, checkedBehavior, sh);
	}
	
	/**
	 * Questo metodo &egrave;ridefinito nelle varie tipologie di constraint e implementa
	 * i check specifici
	 * @param session
	 * @return
	 */
	public abstract boolean specificCheck(Map session, SecurityHelper sh) throws BEException;
	
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/CustomUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class CustomUISecConstraint extends AbstractUISecConstraint {

	public CustomUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
		super(nomeContainer,nomeWidget,constrainedBehavior,defaultState);
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh)  throws BEException{
		// viene sempre ridefinito
		return true;
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ActorBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class ActorBasedUISecConstraint extends AbstractUISecConstraint {

	private String actorCode;
	
	public ActorBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String actorCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.actorCode=actorCode;
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh)  throws BEException{
		return sh.verifyCurrentUserForActor(session, actorCode);
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/UCBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class UCBasedUISecConstraint extends AbstractUISecConstraint {

	private String useCaseCode;
	
	public UCBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String useCaseCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.useCaseCode=useCaseCode;
	}
	
	@Override
	public boolean specificCheck(Map session, SecurityHelper sh)  throws BEException{
		return sh.verifyCurrentUserForUC(session, useCaseCode);
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ComplexUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;
import «getBaseJavaPackage()+".business.*;"»

public class ComplexUISecConstraint implements UISecConstraint {

	protected UISecConstraint [] constraints = null;
	
	public ComplexUISecConstraint(UISecConstraint [] constraints) {
		this.constraints=constraints;
	}
	
	/**
	 * Verifica se almeno uno dei constraints &egrave; soddisfatto.
	 */
	public boolean verifyConstraint(Map session, int checkedBehavior, SecurityHelper sh)  throws BEException{
		if (constraints!=null && constraints.length>0){
			boolean verified = false;
			for (int i = 0; i < constraints.length && !verified; i++) {
				UISecConstraint currCtr = constraints[i];
				verified |= currCtr.verifyConstraint(session, checkedBehavior, sh);
			}
			return verified;
		}
		else
			return true;
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE iridePDCacheClass(GUIModel model) FOR SecurityModel»
«FILE getIridePDCacheJavaFile(model,true)»package «getBaseJavaPackage(model)».business;

import java.util.HashMap;
import java.util.Hashtable;

import it.csi.csi.pfh.FHResult;
import it.csi.csi.pfh.FunctHandler;
import it.csi.csi.util.Param;
import it.csi.csi.wrapper.CSIException;
import it.csi.iride2.policy.entity.*;

public class «getIridePDCacheClassName()» implements FunctHandler{

	static HashMap<Iride2CallKey, Iride2CallValue> cache = new HashMap<Iride2CallKey, Iride2CallValue>();

	static final long TTL = 60*60*1000; // TTL = 1h
	
	public FHResult doOnInvokeSynch(String methodName, Param[] params,
			FHResult prevres, Hashtable bag, boolean inPreChain)
			throws CSIException {
		Iride2CallKey call = new Iride2CallKey(methodName, params);
		if (inPreChain) {
			Iride2CallValue cachedResult = cache.get(call);
			if (cachedResult != null) {
				//System.out.println("PDCache: found result for " + call);
				if ((System.currentTimeMillis()-cachedResult.birthTime) < TTL){
					prevres.setResult(cachedResult.result);
					prevres.setSkipInvoke(true);
				}
				else
					cache.remove(call);
			}
			// else continue and call PA...
		}

		else { // post chain
			if (prevres.getException() == null) {
				// metti in cache il risultato
				//System.out.println("PDCache: caching result for " + call);
				Iride2CallValue newVal = new Iride2CallValue(System.currentTimeMillis(), prevres.getResult());
				cache.put(call, newVal);
			}
		}
		return prevres;
	}

	class Iride2CallValue {
		public long birthTime;
		public Param result;
		
		public Iride2CallValue(long bt, Param p){
			birthTime=bt;
			result=p;
		}
	}
	
	class Iride2CallKey {
		public String paramsKey;
		
		public Iride2CallKey(String methodName, Param [] params){
			paramsKey+=methodName+":";
			Identita id = (Identita)(params[0].getValue());
			paramsKey+=id.getCodFiscale();
			if (params[1].getType()==UseCase.class){
				paramsKey+=",UC:"+((UseCase)(params[1].getValue())).getId();
			}
			else if (params[1].getType()==Actor.class){
				paramsKey+=",ACT:"+((Actor)(params[1].getValue())).getId();
			}
		}

		@Override
		public boolean equals(Object obj) {
			if (obj instanceof Iride2CallKey){
				Iride2CallKey other = (Iride2CallKey)obj;
				return paramsKey.equals(other.paramsKey);
			}
			else
				return false;
		}

		@Override
		public int hashCode() {
			
			return paramsKey.hashCode();
		}

		@Override
		public String toString() {
			return paramsKey;
		}
		
		
	}
}
«ENDFILE»
«ENDDEFINE»


«DEFINE ApplSessGuardFilter FOR GUIModel»
«FILE getSessionGuardFilterJavaFile(this, true)»package «getFiltersJavaPackage(this)»;

import it.csi.iride2.policy.entity.Identita;
import it.csi.iride2.policy.exceptions.MalformedIdTokenException;

import java.io.IOException;
import java.util.StringTokenizer;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.*;
import «getBaseJavaPackage()».util.*;

/**
 * Gestisce la validit&agrave; della sessione applicativa. 
 *
 * @author CSIPiemonte
 */
public class «getSessionGuardFilterClassName()» implements Filter {

	public static final String VALID_APP_SESSION_SESSIONATTR = "valid_app_session";

	/**  */
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE
			+ ".security");

	public void doFilter(ServletRequest req, ServletResponse resp,
			FilterChain fchn) throws IOException, ServletException{
		HttpServletRequest hreq = (HttpServletRequest) req;
		String sessMark = (String)hreq.getSession().getAttribute(VALID_APP_SESSION_SESSIONATTR);
		if (sessMark != null){
			// sessione gia' valida: vai avanti
			log.debug("[AppSessionGuardFilter::doFilter] sessione applicativa valida. proseguo ");
			fchn.doFilter(req, resp);
			return;
		}
		else{
			// se la sessione non e' valida si discrimina in base alla pagina richiesta:
			// HomePage, error &co o altra pagina?
			if (isHomePage(hreq.getRequestURI())){
				log.info("[AppSessionGuardFilter::doFilter] richiesta home page a sessione applicativa non valida: proseguo e imposto la validita'");
				hreq.getSession().setAttribute(VALID_APP_SESSION_SESSIONATTR, VALID_APP_SESSION_SESSIONATTR);
				fchn.doFilter(req, resp);
				return;
			}
			else{
			    // siamo gia' nella pagina di sessione scaduta?
			    if (!mustCheckPage(hreq.getRequestURI())){
			    	fchn.doFilter(req, resp);
					return;
			    }
			    else{ 
					log.info("[AppSessionGuardFilter::doFilter] richiesta pagina differente dalla home a sessione applicativa non valida: redirezione alla pagina di sessione scaduta");
					/// REDIRECT....
					HttpServletResponse hresp = (HttpServletResponse)resp;
					hresp.sendRedirect("sessionExpired.do");
					return;
				}
			}
		}

	}
				
	private boolean isHomePage(String requestURI) {
		if (requestURI.indexOf("HomePage.do") > -1 || requestURI.endsWith("/") || requestURI.indexOf("index.jsp") > -1)
			return true;
		else
			return false;
	}
	
	private boolean mustCheckPage(String requestURI){
		if (
			requestURI.indexOf("HomePage.do")>-1 ||
			requestURI.indexOf("sessionExpired.do")>-1 ||
			requestURI.indexOf("fatalError")>-1 ||
			requestURI.indexOf("notFoundError")>-1 ||
			requestURI.indexOf("sessionExpired.jsp")>-1 ||
			requestURI.indexOf("Logout")>-1
		   )
		   return false;
		else
		   return true;
	}
	
	public void destroy() {
		// NOP
	}

	public void init(FilterConfig arg0) throws ServletException {
		// NOP
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE IrideIdMaterializerFilter(GUIModel model) FOR AutenticationMethod»
«FILE getIrideIdAdapterFilterJavaFile(model, true)»package «getFiltersJavaPackage(model)»;

import it.csi.iride2.policy.entity.Identita;
import it.csi.iride2.policy.exceptions.MalformedIdTokenException;

import java.io.IOException;
import java.util.StringTokenizer;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import «getBaseJavaPackage(model)+".business.*;"»
import org.apache.log4j.*;
import «getBaseJavaPackage(model)».util.*;

/**
 * Inserisce in sessione:
 * <ul> 
 *  <li>l'identit&agrave; digitale relativa all'utente autenticato.
 *  <li>l'oggetto <code>currentUser</code>
 * </ul>
 * Funge da adapter tra il filter del metodo di autenticaizone previsto e la
 * logica applicativa.
 *
 * @author CSIPiemonte
 */
public class «getIrideIdAdapterFilterClassName()» implements Filter{

	public static final String IRIDE_ID_SESSIONATTR = "iride2_id";
	«LET ((GUIModel)this.eRootContainer).appDataDefs AS appDataDefs-»
	«LET (ApplicationData)(((List[ApplicationData])getAllApplicationData(appDataDefs)).select(ad|ad.name=="currentUser").first()) AS currentUserAD-»
	public static final String USERINFO_SESSIONATTR = "«getAppDataKey(currentUserAD)»";
	«ENDLET-»
	«ENDLET-»
	public static final String AUTH_ID_MARKER = "it.csi.opauth.filter.identita";
	
	/**  */
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE + ".security");
	
	public void doFilter(ServletRequest req, ServletResponse resp,
			FilterChain fchn) throws IOException, ServletException {
		HttpServletRequest hreq = (HttpServletRequest)req;
		if (hreq.getSession().getAttribute(IRIDE_ID_SESSIONATTR)==null){
			String marker = (String)hreq.getSession().getAttribute(AUTH_ID_MARKER);
			if (marker!=null){
				try {
					Identita identita = new Identita(normalizeToken(marker));
					log.debug("[IrideIdAdapterFilter::doFilter] Inserito in sessione marcatore IRIDE:"+identita);
					hreq.getSession().setAttribute(IRIDE_ID_SESSIONATTR, identita);
					«getDTOBaseJavaPackage(model)».UserInfo userInfo = new «getDTOBaseJavaPackage(model)».UserInfo();
					userInfo.setNome(identita.getNome());
					userInfo.setCognome(identita.getCognome());
					userInfo.setEnte("--");
					userInfo.setRuolo("--");
					userInfo.setCodFisc(identita.getCodFiscale());
					userInfo.setIdIride(identita.toString());
					hreq.getSession().setAttribute(USERINFO_SESSIONATTR, userInfo);
				} catch (MalformedIdTokenException e) {
					log.error("[IrideIdAdapterFilter::doFilter] "+e.toString(),e);
				}
			}
		}
		
		fchn.doFilter(req, resp);
		
	}

	public void destroy() {
		// NOP
	}

	public void init(FilterConfig arg0) throws ServletException {
		// NOP
	}

	private String normalizeToken(String token){
		String tmp = null;
		
		if(token.indexOf("~") == -1){
			return token;
		}else{
			String[] tok = token.split("~");
			tmp = tok[6]+"/"+tok[4];
		}
				
		return tmp;
	}
}
«ENDFILE»
«ENDDEFINE»


«REM»
#################################################################
    constraints di sicurezza per Widget
#################################################################
«ENDREM»
«DEFINE getPageUIConstraintDef(GUIModel model) FOR ContentPanel»
	protected Map<String, UISecConstraint> getPageVisibilityUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "VISIB") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
	
	protected Map<String, UISecConstraint> getPageONOFFUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "ONOFF") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
«ENDDEFINE»


«DEFINE uiConstraint(GUIModel model, String behavior) FOR Widget-»
«IF securityConstraints.size>0-»
		// constraints per «this»
«FOREACH this.securityConstraints AS currConstraint-»
		UISecConstraint «name»_«securityConstraints.indexOf(currConstraint)»_ctr =
		«EXPAND uiConstraintNew(model) FOR currConstraint-» 
«ENDFOREACH-»
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
		«LET (behavior=="VISIB" ? securityConstraints.select(c|c.visible): securityConstraints.select(c|c.enabled)) AS selectedConstraints-»
			«FOREACH selectedConstraints AS currConstraint-»
			«name»_«securityConstraints.indexOf(currConstraint)»_ctr«IF securityConstraints.last()!=currConstraint»,«ENDIF»
			«ENDFOREACH-»
		«ENDLET-»
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ELSE»
		// constraint fittizio per «this»
		UISecConstraint «name»_default«behavior.toLowerCase().toFirstUpper()»_ctr =
		«EXPAND uiDummyConstraintNew(model, behavior) FOR this-»
		 
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
			«name»_default«behavior.toLowerCase().toFirstUpper()»_ctr
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ENDIF-»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR UISecurityConstraint»
 			null; /// ERRORE: constraint non gestito «this»
«ENDDEFINE»

«DEFINE uiDummyConstraintNew(GUIModel model, String pBehavior) FOR Widget»
«LET this AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET pBehavior!="VISIB" ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET pBehavior!="VISIB" ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new CustomUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»
 			){
 				@Override
					public boolean specificCheck(Map session, SecurityHelper sh) throws BEException{
						// dummy!!!
						return true;
					}
 			};
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR CustomSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new CustomUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»
 			){
 				@Override
					public boolean specificCheck(Map session, SecurityHelper sh) throws BEException{
						return getSpringSecurityHelper().customCheck«methodNameSuffix.toFirstUpper()»(session);
					}
 			};
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE uiConstraintNew(GUIModel model) FOR UCBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new UCBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.useCase.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR ActorBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new ActorBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.actor.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE securedWidgetCheck(GUIModel model) FOR ContentPanel»
// ridefinizione dei metodi di verifica visibilita'/validazione
// per supportare i security check

	public boolean isWidgetDisabled(String cpName, String widgShortName) {
		UISecConstraint ctr = allOnOffConstraints.get(widgShortName);
		if (ctr!=null){
			try{
				return !ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsActionClassName(this)»::isWidgetDisabled] errore durante verifica->disable");
				return true; // forzo la DISABILITAZIONE
			}
		}
		else
			return super.isWidgetDisabled(cpName, widgShortName);
	}
	
	public boolean isWidgetVisible(String cpName, String widgShortName) {
		UISecConstraint ctr = allVisibilityConstraints.get(widgShortName);
		if (ctr!=null){
			try{
				return ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsActionClassName(this)»::isWidgetVisible] errore durante verifica->hide");
				return false; // forzo l'invisibilita'
			}
		}
		else
			return super.isWidgetVisible(cpName, widgShortName);
	}

«ENDDEFINE»

«REM»
#################################################################
    constraints di sicurezza per Menu
#################################################################
«ENDREM»
«DEFINE getMenuUIConstraintDef(GUIModel model) FOR Menubar»
	protected Map<String, UISecConstraint> getMenuVisibilityUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«EXPAND uiConstraint(model, "VISIB") FOREACH topLevelMenu-» 
		return allConstraints;
	}
	
	protected Map<String, UISecConstraint> getMenuONOFFUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«EXPAND uiConstraint(model, "ONOFF") FOREACH topLevelMenu-» 
		return allConstraints;
	}
«ENDDEFINE»

«DEFINE uiConstraint(GUIModel model, String behavior) FOR Menu-»
«IF securityConstraints.size>0-»
		// constraints per «this»
«FOREACH this.securityConstraints AS currConstraint-»
		UISecConstraint «name»_«securityConstraints.indexOf(currConstraint)»_ctr =
		«EXPAND uiConstraintNew4Menu(model) FOR currConstraint-» 
«ENDFOREACH-»
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
		«LET (behavior=="VISIB" ? securityConstraints.select(c|c.visible): securityConstraints.select(c|c.enabled)) AS selectedConstraints-»
			«FOREACH selectedConstraints AS currConstraint-»
			«name»_«securityConstraints.indexOf(currConstraint)»_ctr«IF securityConstraints.last()!=currConstraint»,«ENDIF»
			«ENDFOREACH-»
		«ENDLET-»
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ENDIF-»
	«EXPAND uiConstraint(model, behavior) FOREACH this.submenu»
	«REM»MenuItem è DEPRECATO
	«EXPAND uiConstraint(model, behavior) FOREACH this.item»
	«ENDREM»
«ENDDEFINE»

«REM»MenuItem è DEPRECATO
«DEFINE uiConstraint(GUIModel model, String behavior) FOR MenuItem-»
«IF securityConstraints.size>0-»
		// constraints per «this»
«FOREACH this.securityConstraints AS currConstraint-»
		UISecConstraint «name»_«securityConstraints.indexOf(currConstraint)»_ctr =
		«EXPAND uiConstraintNew4Menu(model) FOR currConstraint-» 
«ENDFOREACH-»
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
		«LET (behavior=="VISIB" ? securityConstraints.select(c|c.visible): securityConstraints.select(c|c.enabled)) AS selectedConstraints-»
			«FOREACH selectedConstraints AS currConstraint-»
			«name»_«securityConstraints.indexOf(currConstraint)»_ctr«IF securityConstraints.last()!=currConstraint»,«ENDIF»
			«ENDFOREACH-»
		«ENDLET-»
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ENDIF-»
«ENDDEFINE»
«ENDREM»



«DEFINE uiConstraintNew4Menu(GUIModel model) FOR UISecurityConstraint»
 			null; /// ERRORE: constraint non gestito «this»
«ENDDEFINE»

«DEFINE uiConstraintNew4Menu(GUIModel model) FOR CustomSecurityConstraint»
«LET this.eContainer AS parent»
«LET parent.metaType==Menu ? ((Menu)parent).name :((MenuItem)parent).name AS itemName»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
 			new CustomUISecConstraint(
 				"_menu",
 				"«itemName»",
 				UISecConstraint.«behavior»,
 				true
 			){
 				@Override
					public boolean specificCheck(Map session, SecurityHelper sh) throws BEException{
						return getSpringSecurityHelper().customCheck«methodNameSuffix.toFirstUpper()»(session);
					}
 			};
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»


«DEFINE uiConstraintNew4Menu(GUIModel model) FOR UCBasedSecurityConstraint»
«LET this.eContainer AS parent»
«LET parent.metaType==Menu ? ((Menu)parent).name :((MenuItem)parent).name AS itemName»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
 			new UCBasedUISecConstraint(
 				"_menu",
 				"«itemName»",
 				UISecConstraint.«behavior»,
 				true,
 				"«this.useCase.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE uiConstraintNew4Menu(GUIModel model) FOR ActorBasedSecurityConstraint»
«LET this.eContainer AS parent»
«LET parent.metaType==Menu ? ((Menu)parent).name :((MenuItem)parent).name AS itemName»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
 			new ActorBasedUISecConstraint(
 				"_menu",
 				"«itemName»",
 				UISecConstraint.«behavior»,
 				true,
 				"«this.actor.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»


«REM»#######«ENDREM»


«DEFINE springSecurityHelperClasses FOR GUIModel-»
«FILE getSpringSecurityHelperJavaFile()»
package «getBaseJavaPackage()».business;

import java.util.*;
import java.io.*;
import it.csi.csi.porte.InfoPortaDelegata;
import it.csi.csi.porte.proxy.PDProxy;
import it.csi.csi.util.xml.PDConfigReader;
import it.csi.csi.wrapper.SystemException;
import it.csi.csi.wrapper.UnrecoverableException;
import it.csi.iride2.policy.entity.*;
import it.csi.iride2.policy.exceptions.*;
import it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService;
import «getDTOBaseJavaPackage()».*;
import org.apache.log4j.*;
import «getBaseJavaPackage()».util.*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperImports")»

«ENDPROTECT»

public class «getSpringSecurityHelperClassName()»{

    /**  */
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE + ".security");   

    //////////////////////////////////////////////////////////////////////////////
	/// Metodi di supporto alla sicurezza.
	//////////////////////////////////////////////////////////////////////////////
	«EXPAND springSecurityHelperMethods FOR this»
	
	//////////////////////////////////////////////////////////////////////////////
	/// Property aggiuntive del bean
	//////////////////////////////////////////////////////////////////////////////
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperProperties")»
	//// inserire qui le property che si vogliono iniettare in questo bean (es. dao, proxy di pd, ...) 
«ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»

«DEFINE springSecurityHelperMethods FOR GUIModel»
	«EXPAND irideHelperMethods FOR this»
	«EXPAND customConstraintsMethods FOR this»
«ENDDEFINE»

«DEFINE irideHelperMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza basata su IRIDE2
	///////////////////////////////////////////////////////////////////////////////
	
	public final static String IRIDE_PEP_RESOURCE = "/META-INF/iride2_pep_defPD_ejb.xml";
	
	it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService iride = null;
	
	protected PolicyEnforcerBaseService getIridePEP(){
		if (this.iride==null){
			InputStream is = getClass().getResourceAsStream(IRIDE_PEP_RESOURCE);
			if (is != null){
				try {
					InfoPortaDelegata info = PDConfigReader.read(is);
					this.iride = (PolicyEnforcerBaseService)PDProxy.newInstance(info);
					return this.iride;
				} 
				catch (Exception e) {
					log.error("[SecurityHelper::getIridePEP] errore nella parsificazione della configurazione di IRIDE2:"+e,e);
					throw new IllegalArgumentException("errore nella parsificazione della configurazione di IRIDE2");
				}
			}
			else 
				log.error("[SecurityHelper::getIridePEP] configurazione di IRIDE2 non trovata");
				throw new IllegalArgumentException("configurazione di IRIDE2 non trovata");
		} 
		else
			return this.iride;
	}
	
	public static final String IRIDE_ID_SESSIONATTR = "iride2_id";
	
	protected Identita getCurrentUser(Map session)
		throws BEException
	{
		Identita id = (Identita)session.get(IRIDE_ID_SESSIONATTR);
		if (id == null){
			log.error("[SecurityHelper::getCurrentUser] Errore nel reperimento del current user dalla sessione: attributo non trovato");
			throw new IllegalStateException("Errore nel reperimento del current user dalla sessione: attributo non trovato");
		}
		else{
			return id;
		}
	}
	
	public final static Application IRIDE2_APPLICATION = new Application("«this.securityModel.securityAppID»");;
	
	public boolean verifyCurrentUserForUC(Map session, String useCaseCode)
		throws BEException
	{
		Identita currentUser = getCurrentUser(session);
		UseCase uc = new UseCase();
		 
		uc.setAppId(IRIDE2_APPLICATION);
		uc.setId(useCaseCode);
		try {
			return getIridePEP().isPersonaAutorizzataInUseCase(getCurrentUser(session), uc);
		} catch (InternalException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] Errore interno in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore interno in verifyCurrentUserForUC:"+e, e);
		} catch (IdentitaNonAutenticaException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] identita' non autentica ["+currentUser+"],"+e);
			throw new BEException("verifyCurrentUserForUC: identita' non autentica ["+currentUser+"],"+e, e);
		} catch (NoSuchUseCaseException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] use case ["+uc+"] non valido"+e);
			throw new BEException("verifyCurrentUserForUC: use case ["+uc+"] non valido"+e, e);
		} catch (NoSuchApplicationException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] applicazione "+IRIDE2_APPLICATION+" non valida"+e);
			throw new BEException("verifyCurrentUserForUC: applicazione "+IRIDE2_APPLICATION+" non valida"+e, e);
		} catch (UnrecoverableException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] Errore non recuperabile in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore non recuperabile in verifyCurrentUserForUC:"+e, e);
		} catch (SystemException e) {
			log.error("[SecurityHelper::verifyCurrentUserForUC] Errore di sistema in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore di sistema in verifyCurrentUserForUC:"+e, e);
		}
		catch(Throwable e){
			log.error("[SecurityHelper::verifyCurrentUserForUC] Errore interno in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore interno in verifyCurrentUserForUC:"+e, e);
		}
	}
	
	public boolean verifyCurrentUserForActor(Map session, String actorCode)
		throws BEException
	{
		Identita currentUser = getCurrentUser(session);
		Actor act = new Actor();
		 
		act.setAppId(IRIDE2_APPLICATION);
		act.setId(actorCode);
		try {
			Actor [] actors = getIridePEP().findActorsForPersonaInApplication(currentUser, IRIDE2_APPLICATION);
			if (actors!=null){
				for (int i = 0; i < actors.length; i++) {
					Actor actor = actors[i];
					if (actor.equals(act))
						return true;
				}
				return false;
			}
			else
				return false;
		} catch (InternalException e) {
			log.error("[SecurityHelper::verifyCurentUserForActor] Errore interno in verifyCurrentUserForUC:"+e);
			throw new BEException("Errore interno in verifyCurrentUserForUC:"+e, e);
		} catch (IdentitaNonAutenticaException e) {
			log.error("[SecurityHelper::verifyCurentUserForActor] identita' non autentica ["+currentUser+"],"+e,e);
			throw new BEException("verifyCurrentUserForUC: identita' non autentica ["+currentUser+"],"+e, e);
		} catch (NoSuchApplicationException e) {
			log.error("[SecurityHelper::verifyCurentUserForActor] applicazione "+IRIDE2_APPLICATION+" non valida"+e,e);
			throw new BEException("verifyCurrentUserForUC: applicazione "+IRIDE2_APPLICATION+" non valida"+e, e);
		} catch (UnrecoverableException e) {
			log.error("[SecurityHelper::verifyCurentUserForActor] Errore non recuperabile in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore non recuperabile in verifyCurrentUserForUC:"+e, e);
		} catch (SystemException e) {
			log.error("[SecurityHelper::verifyCurentUserForActor] Errore di sistema in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore di sistema in verifyCurrentUserForUC:"+e, e);
		}
		catch(Throwable e){
			log.error("[SecurityHelper::verifyCurentUserForActor] Errore interno in verifyCurrentUserForUC:"+e,e);
			throw new BEException("Errore interno in verifyCurrentUserForUC:"+e, e);
		}
	}
«ENDDEFINE»

«DEFINE customConstraintsMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza custom
	///////////////////////////////////////////////////////////////////////////////
	
	«FOREACH (List[ContentPanel])getAllContentPanels(this) AS cp-»
		«LET (List[Widget])findAllWidgetsInContentPanel(cp) AS cpWidgets-»
			«LET cpWidgets.select(w|w.securityConstraints.select(c|c.metaType==CustomSecurityConstraint).size>0) AS allCustomConstrainedWidgets-»
			«FOREACH (List[CustomSecurityConstraint])(allCustomConstrainedWidgets.securityConstraints.select(c|c.metaType==CustomSecurityConstraint)) AS currCustomSC-»
	public boolean customCheck«currCustomSC.methodNameSuffix.toFirstUpper()» (Map session)
		throws BEException
	{
			«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("customCheck"+currCustomSC.methodNameSuffix)-»
		/// inserire qui il codice del controllo custom
		try{
			return true;
		}
		catch(Throwable ex){
			log.error("[SecurityHelper::customCheck«currCustomSC.methodNameSuffix.toFirstUpper()»] Errore durante l'esecuzione del metodo", ex);
			throw new BEException("Errore durante l'esecuzione del metodo customCheck«currCustomSC.methodNameSuffix.toFirstUpper()»", ex);
		}
			«ENDPROTECT»
	}
			«ENDFOREACH-»
			«ENDLET-»
		«ENDLET-»
		
	«ENDFOREACH-»
	«LET getAllCustomSecConstraints4Menus(this.structure.appWindow.appArea.menubar) AS customCtr4Menu-»
			«FOREACH customCtr4Menu AS currMenuCustomCtr-»
		
	public boolean customCheck«((CustomSecurityConstraint)currMenuCustomCtr).methodNameSuffix.toFirstUpper()» (Map session)
		throws BEException
	{
			«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("customCheck"+(((CustomSecurityConstraint)currMenuCustomCtr).methodNameSuffix))-»
		/// inserire qui il codice del controllo custom
		try{
			return true;
		}
		catch(Throwable ex){
			log.error("[SecurityHelper::customCheck«((CustomSecurityConstraint)currMenuCustomCtr).methodNameSuffix.toFirstUpper()»] Errore durante l'esecuzione del metodo", ex);
			throw new BEException("Errore durante l'esecuzione del metodo customCheck«((CustomSecurityConstraint)currMenuCustomCtr).methodNameSuffix.toFirstUpper()»", ex);
		}
			«ENDPROTECT»
	}		
			«ENDFOREACH-»
	«ENDLET»
«ENDDEFINE»


«DEFINE iride2PDFile FOR GUIModel»
«FILE getSpringIRIDE2PDConfig()»<porta-delegata name="PolicyEnforcerBase">
  <services>
    <service
      name="PolicyEnforcerBase"
      public-interface-class="it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService">
      <operations>
        <operation name="identificaUserPassword" type="synch-call">
          <param-list>
            <param name="username" type="java.lang.String" />
            <param name="password" type="java.lang.String" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="identificaUserPasswordPIN" type="synch-call">
          <param-list>
            <param name="username" type="java.lang.String" />
            <param name="password" type="java.lang.String" />
            <param name="pin" type="java.lang.String" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="identificaCertificato" type="synch-call">
          <param-list>
            <param name="certificato" type="byte[]" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Identita"/>
        </operation>
        <operation name="isPersonaAutorizzataInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="isPersonaInRuolo" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="ruolo" type="it.csi.iride2.iridefed.entity.Ruolo" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="getInfoPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="java.lang.String"/>
        </operation>
        <operation name="findRuoliForPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="it.csi.iride2.iridefed.entity.Ruolo[]"/>
        </operation>
        <operation name="findRuoliForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.iridefed.entity.Ruolo[]"/>
        </operation>
        <operation name="findUseCasesForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.UseCase[]"/>
        </operation>
        <operation name="findActorsForPersonaInApplication" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="app" type="it.csi.iride2.policy.entity.Application" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Actor[]"/>
        </operation>
        <operation name="isIdentitaAutentica" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
          </param-list>
          <ret-val type="boolean"/>
        </operation>
        <operation name="getInfoPersonaSchema" type="synch-call">
          <param-list>
            <param name="codRuolo" type="it.csi.iride2.iridefed.entity.Ruolo" />
          </param-list>
          <ret-val type="java.lang.String"/>
        </operation>
        <operation name="findActorsForPersonaInUseCase" type="synch-call">
          <param-list>
            <param name="persona" type="it.csi.iride2.policy.entity.Identita" />
            <param name="useCase" type="it.csi.iride2.policy.entity.UseCase" />
          </param-list>
          <ret-val type="it.csi.iride2.policy.entity.Actor[]"/>
        </operation>
      </operations>
    </service>
  </services>
  <config>
    <url-pa>multi://pc41012.csi.it</url-pa>
    <pluggable-pd-list chooser-class="it.csi.csi.porte.FixedDelegateChooser">
      <pluggable-pd
        name="policyEnf"
        class="it.csi.csi.porte.ejb.PortaDelegataEJB"
        url-pa="iride2/policy/PolicyEnforcementPoint_PA" >
        <properties>
          <property name="java.naming.provider.url" value="@IRIDE_PROVIDER_URL@" />
          <property name="java.naming.factory.initial" value="weblogic.jndi.WLInitialContextFactory" />
          <property name="csi.auth.jaas.client.class" value="it.csi.csi.porte.ejb.jaas.weblogic.WeblogicJAASNativeClient" />
          <property name="csi.auth.basic" value="" />
        </properties>
      </pluggable-pd>
    </pluggable-pd-list>
    <pre-function-handler-list>
    	<pluggable-fh
         name="CACHE PRE"
         class="«getIridePDCacheFQN()»" >
        <properties>
       </properties>
      </pluggable-fh>
    </pre-function-handler-list>
    <post-function-handler-list>
    	<pluggable-fh
         name="CACHE POST"
         class="«getIridePDCacheFQN()»" >
        <properties>
       </properties>
      </pluggable-fh>
    </post-function-handler-list>
    <queue-manager url="rmi://:2001/QMgrCli"/>
  </config>
</porta-delegata>
«ENDFILE»
«ENDDEFINE»