«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR AutenticationMethod»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR SSOBARTSSO»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR CustomAuthentication»
<!-- authentication method non supportato: «this.metaType» -->
«ENDDEFINE»

«DEFINE authenticationFilterDefAndMapping(GUIModel model) FOR OPAUTHSSO»
	<!-- ############################################################### 
         definizione filter per autentication con OPAUTH (oracle portal) 
         ###############################################################
    -->
	<filter>
		<filter-name>OP Filter</filter-name>
		<filter-class>it.csi.opauth.filter.OPFilter</filter-class>
		<init-param>
			<param-name>it.csi.opauth.filter.loginAccessUrl</param-name>
			<param-value>
				http://@OP_SERVER@/portal/pls/portal/csi_custom.ext_login
			</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.minAuthLevel</param-name>
			<param-value>«this.minAuthLevel»</param-value>
		</init-param>
		<init-param>
			<param-name>logger</param-name>
			<param-value>@APP_PREFIX@.OPclient</param-value>
		</init-param>
		<init-param>
			<param-name>it.csi.opauth.filter.serverName</param-name>
			<param-value>@DEFAULT_APP_SERVER@</param-value>
		</init-param>
	</filter>

    «EXPAND irideIdFilterDef(model) FOR this»
    
	<!-- ################################################################
	     il filter di autenticazione e' il primo ad essere innescato
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>OP Filter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
	«EXPAND irideIdFilterMap(model) FOR this»
«ENDDEFINE»

«DEFINE irideIdFilterDef(GUIModel model) FOR AutenticationMethod»
	<filter>
		<filter-name>IRIDE ID Adapter</filter-name>
		<filter-class>«getIrideIdAdapterFilterFQN(model)»</filter-class>
	</filter>
«ENDDEFINE»

«DEFINE irideIdFilterMap(GUIModel model) FOR AutenticationMethod»
	
	<!-- ################################################################
	     il filter di adattamento iride e' il successivo dopo 
	     l'autenticazione
	     ################################################################
	-->
	<filter-mapping>
		<filter-name>IRIDE ID Adapter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR OPAUTHSSO»
	<!-- replace variabili di environment per opauth -->
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@OP_SERVER@"  
		value="${opauth.server.url}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@APP_PREFIX@"  
		value="${componente}"/>
	<replace file="${build}/temp/conf/web/${webapp}/WEB-INF/web.xml" 
		token="@DEFAULT_APP_SERVER@"  
		value="${opauth.default.appserver}"/>	
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE envConfigForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»


«DEFINE templatePropsForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR OPAUTHSSO»
#-[configurazione opauth]--------------------------------------------------
opauth.server.url = spintest.csi.it:7778
opauth.default.appserver = localhost:8078
opauth.logout.url = http://spintest.csi.it:7778/portal/page/portal/sistemapiemonte/logout
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE templatePropsForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»


«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR AutenticationMethod»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR SSOBARTSSO»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR CustomAuthentication»
«ENDDEFINE»

«DEFINE ivyDependenciesForAuthentication(GUIModel model) FOR OPAUTHSSO»
	
	<!-- ############################################################## -->
    <!-- # OPAUTH                                                     # -->
    <!-- ############################################################## -->
	<dependency org="csipiemonte" name="opauth4j" rev="1.0.2" />
    <!-- <dependency org="csipiemonte" name="iride-simulation" rev="1.1.0" /> -->
    <!-- <dependency org="csipiemonte" name="simula" rev="1.1.0" /> -->    
    <!-- ############################################################## -->
    <!-- # IBM                                                        # -->
    <!-- ############################################################## -->
    <!--  -->
    <dependency org="ibm" name="xml" rev="1.0.0" />
    
«ENDDEFINE»


«DEFINE securityJavaFiles(boolean skip) FOR GUIModel»
«IF this.securityModel.autenticationMethod!=null»
«EXPAND IrideIdMaterializerFilter(this) FOR this.securityModel.autenticationMethod»
«EXPAND constraintJavaFiles FOR this»
«EXPAND springSecurityHelperClasses FOR this»
«ENDIF»
«ENDDEFINE»

«DEFINE constraintJavaFiles FOR GUIModel»
«FILE getSecurityJavaSrcDir(this,true)+"/UISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;

public interface UISecConstraint {

	public static final int ONOFF_CONSTRAINED_BEHAVIOR = 1;
	public static final int VISIB_CONSTRAINED_BEHAVIOR = 2;
	public boolean verifyConstraint(Map session, int checkedBehavior);
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/AbstractUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;

public abstract class AbstractUISecConstraint implements UISecConstraint{

protected int constrainedBehavior = UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR;
protected boolean defaultState;
protected String nomeContainer;
protected String nomeWidget;

public AbstractUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
	if (nomeContainer==null||nomeWidget==null)
		throw new IllegalArgumentException("Errore interno: nome container e nome widget obbligatori per constraint");
	if (constrainedBehavior!=UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR && 
		constrainedBehavior!=UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR)
		throw new IllegalArgumentException("Errore interno: comportamento oggetto di constraint non gestibile:"+constrainedBehavior);
	this.nomeContainer=nomeContainer;
	this.nomeWidget=nomeWidget;
	this.constrainedBehavior=constrainedBehavior;
	this.defaultState=defaultState;
}
	/**
	 * Combina adeguatamente:
	 * <ul>
	 * <li>l'esito della verifica specifica
	 * <li>lo stato di default (relativo al comportamento oggetto di constraint - visibilità o abilitazione)
	 * <li>lo stato corrente  (relativo al comportamento oggetto di constraint - visibilità o abilitazione)
	 * </ul>
	 * In sintesi il comportamento oggetto di constraint sarà così valutato:
	 * <ul>
	 * <li>se lo stato corrente non è specificato (il widget non è stato impostato esplicitamente
	 *     ad invisibile o disabilitato) viene utilizzato come stato corrente lo stato di default
	 * <li>se lo stato corrente combinato (corrente effettivo + default) è OFF (invisibile o disabilitato)
	 *     lo stato finale o OFF
	 * <li>se lo stato corrente combinato (corrente effettivo + default) è ON, viene eseguito
	 *     il check specifico (che dipende dat tipo di constraint) e lo stato finale è 
	 *     ON (visibile o abilitato) se il check specifico è verificato, OFF altrimenti.
	 * </ul>
	 * @param session mantiene lo stato corrente del widget
	 * @return
	 */
	protected boolean combineAll(Map session, int checkedBehavior) {
		if(checkedBehavior!=this.constrainedBehavior)
			return false; // se il comportamento osservato è un'altro passo oltre
		else{
			Boolean currentState = getCurrentState(session);
			if (currentState == null)
				currentState = new Boolean(defaultState);
			if (currentState.booleanValue() == false)
				return false;
			else
				return specificCheck(session);
		}
	}

	/**
	 * Cerca in sessione lo stato corrente.
	 * @return null se lo stato (per il comportamento in osservazione) non è impostato oppure
	 * il valore effettivo se questo è impostato.
	 */
	protected Boolean getCurrentState(Map session){
		String behaviorSuffix = "";
		switch (constrainedBehavior) {
		case UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_enabled";
			break;
		case UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR:
			behaviorSuffix = "_visible";
			break;
		default:
			break;
		} 
		Map cpData = (Map) session.get(nomeContainer);
		if (cpData != null) {
			Boolean behaviorFlag = (Boolean) cpData.get(nomeWidget
					+ behaviorSuffix);
			if (behaviorFlag != null) {
				return behaviorFlag.booleanValue();
			} else
				return null; // unspecified current state
		} else
			return null; // unspecified current state
	}
	
	public boolean verifyConstraint(Map session, int checkedBehavior) {
		
		return combineAll(session, checkedBehavior);
	}
	
	/**
	 * Questo metodo è ridefinito nelle varie tipologie di constraint e implementa
	 * i check specifici
	 * @param session
	 * @return
	 */
	protected abstract boolean specificCheck(Map session);
	
}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/CustomUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;

public class CustomUISecConstraint extends AbstractUISecConstraint {

	public CustomUISecConstraint(String nomeContainer, String nomeWidget, int constrainedBehavior, boolean defaultState) {
		super(nomeContainer,nomeWidget,constrainedBehavior,defaultState);
	}
	
	@Override
	protected boolean specificCheck(Map session) {
		// TODO Auto-generated method stub
		return true;
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ActorBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;
import java.util.Map;

public class ActorBasedUISecConstraint extends AbstractUISecConstraint {

	private String actorCode;
	
	public ActorBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String actorCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.actorCode=actorCode;
	}
	
	@Override
	protected boolean specificCheck(Map session) {
		// TODO Auto-generated method stub
		return true;
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/UCBasedUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;

public class UCBasedUISecConstraint extends AbstractUISecConstraint {

	private String useCaseCode;
	
	public UCBasedUISecConstraint(String nomeContainer, String nomeWidget,
			int constrainedBehavior, boolean defaultState, String useCaseCode) {
		super(nomeContainer, nomeWidget, constrainedBehavior, defaultState);
		this.useCaseCode=useCaseCode;
	}
	
	@Override
	protected boolean specificCheck(Map session) {
		// TODO Auto-generated method stub
		return true;
	}

}
«ENDFILE»

«FILE getSecurityJavaSrcDir(this,true)+"/ComplexUISecConstraint.java"»package «getSecurityJavaPackage(this)»;

import java.util.Map;

public class ComplexUISecConstraint implements UISecConstraint {

	protected UISecConstraint [] constraints = null;
	
	public ComplexUISecConstraint(UISecConstraint [] constraints) {
		this.constraints=constraints;
	}
	
	/**
	 * Verifica se almeno uno dei constraints è soddisfatto.
	 */
	public boolean verifyConstraint(Map session, int checkedBehavior) {
		if (constraints!=null && constraints.length>0){
			boolean verified = false;
			for (int i = 0; i < constraints.length || verified; i++) {
				UISecConstraint currCtr = constraints[i];
				verified |= currCtr.verifyConstraint(session, checkedBehavior);
			}
			return verified;
		}
		else
			return true;
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE IrideIdMaterializerFilter(GUIModel model) FOR AutenticationMethod»
«FILE getIrideIdAdapterFilterJavaFile(model, true)»package «getFiltersJavaPackage(model)»;

import it.csi.iride2.policy.entity.Identita;
import it.csi.iride2.policy.exceptions.MalformedIdTokenException;

import java.io.IOException;
import java.util.StringTokenizer;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

/**
 * Inserisce in sessione l'identità digitale relativa all'utente autenticato.
 * Funge da adapter tra il filter del metodo di autenticaizone previsto e la
 * logica applicativa.
 * @author CSIPiemonte
 *
 */
public class IrideIdAdapterFilter implements Filter{

	public static final String IRIDE_ID_SESSIONATTR = "iride2_id";
	
	public static final String AUTH_ID_MARKER = "it.csi.opauth.filter.identita";
	
	public void doFilter(ServletRequest req, ServletResponse resp,
			FilterChain fchn) throws IOException, ServletException {
		HttpServletRequest hreq = (HttpServletRequest)req;
		if (hreq.getSession().getAttribute(IRIDE_ID_SESSIONATTR)==null){
			String marker = (String)hreq.getSession().getAttribute(AUTH_ID_MARKER);
			if (marker!=null){
				try {
					Identita identita = new Identita(normalizeToken(marker));
					System.out.println("Inserito in sessione marcatore IRIDE:"+identita);
					hreq.getSession().setAttribute(IRIDE_ID_SESSIONATTR, identita);
				} catch (MalformedIdTokenException e) {
					// TODO mettere a posto messaggio
					e.printStackTrace();
				}
			}
		}
		
		fchn.doFilter(req, resp);
		
	}

	public void destroy() {
		// NOP
	}

	public void init(FilterConfig arg0) throws ServletException {
		// NOP
	}

	private String normalizeToken(String token){
		  String tmp = null;
		  
		  StringTokenizer tok = new StringTokenizer(token, "~");
		  
		  String codiceFiscale = tok.nextToken();
		  
		  while( tok.hasMoreTokens() ){
		   tmp = tok.nextToken();
		   if(tmp.startsWith(codiceFiscale)){
		    return tmp+"/";
		   }
		  }
		  
		  return tmp;
		 }
}
«ENDFILE»
«ENDDEFINE»

«DEFINE getPageUIConstraintDef(GUIModel model) FOR ContentPanel»
	protected Map<String, UISecConstraint> getPageVisibilityUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "VISIB") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
	
	protected Map<String, UISecConstraint> getPageONOFFUIConstraints(){
		Map<String, UISecConstraint> allConstraints = new HashMap<String, UISecConstraint>();
		«LET (List[Widget])(this.findAllWidgetsInContentPanel()) AS allWidgets-»
		«EXPAND uiConstraint(model, "ONOFF") FOREACH allWidgets-» 
		«ENDLET-»
		return allConstraints;
	}
«ENDDEFINE»


«DEFINE uiConstraint(GUIModel model, String behavior) FOR Widget-»
«IF securityConstraints.size>0-»
		// constraints per «this»
«FOREACH this.securityConstraints AS currConstraint-»
		UISecConstraint «name»_«securityConstraints.indexOf(currConstraint)»_ctr =
		«EXPAND uiConstraintNew(model) FOR currConstraint-» 
«ENDFOREACH-»
		UISecConstraint [] «name»_constraints = new UISecConstraint[]{
		«LET (behavior=="VISIB" ? securityConstraints.select(c|c.visible): securityConstraints.select(c|c.enabled)) AS selectedConstraints-»
			«FOREACH selectedConstraints AS currConstraint-»
			«name»_«securityConstraints.indexOf(currConstraint)»_ctr«IF securityConstraints.last()!=currConstraint»,«ENDIF»
			«ENDFOREACH-»
		«ENDLET-»
		};
		UISecConstraint «name»_ctr = new ComplexUISecConstraint(«name»_constraints);
		allConstraints.put("«name»", «name»_ctr);
«ENDIF-»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR UISecurityConstraint»
 			null; /// ERRORE: constraint non gestito «this»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR CustomSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new CustomUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»
 			){
 				@Override
					protected boolean specificCheck(Map session) {
						return getSpringSecurityHelper().customCheck«methodNameSuffix.toFirstUpper()»(session);
					}
 			};
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE uiConstraintNew(GUIModel model) FOR UCBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new UCBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.useCase.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»

«DEFINE uiConstraintNew(GUIModel model) FOR ActorBasedSecurityConstraint»
«LET this.eContainer AS parent»
«REM»«IF parent.metaType.(Widget)»«ENDREM»
«LET (Widget)parent AS parentWidget»
«LET this.enabled ? "ONOFF_CONSTRAINED_BEHAVIOR" : "VISIB_CONSTRAINED_BEHAVIOR" AS behavior»
«LET this.enabled ? (parentWidget.defaultEnabled) : (parentWidget.defaultVisible) AS defaultBehavior»
 			new ActorBasedUISecConstraint(
 				"«((ContentPanel)(findParentContentPanel(parentWidget))).name»",
 				"«parentWidget.name»",
 				UISecConstraint.«behavior»,
 				«defaultBehavior»,
 				"«this.actor.code»"
 			);
«ENDLET»
«ENDLET»
«ENDLET»
«REM»«ENDIF»«ENDREM»
«ENDLET»
«ENDDEFINE»


«DEFINE securedWidgetCheck(GUIModel modle) FOR ContentPanel»
// ridefinizione dei metodi di verifica visibilità/validazione
// per supportare i security check

	public boolean isWidgetDisabled(String cpName, String widgShortName) {
		UISecConstraint ctr = allOnOffConstraints.get(widgShortName);
		if (ctr!=null)
			return !ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR);
		else
			return super.isWidgetDisabled(cpName, widgShortName);
	}
	
	public boolean isWidgetVisible(String cpName, String widgShortName) {
		UISecConstraint ctr = allVisibilityConstraints.get(widgShortName);
		if (ctr!=null)
			return ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR);
		else
			return super.isWidgetVisible(cpName, widgShortName);
	}

«ENDDEFINE»



«DEFINE springSecurityHelperClasses FOR GUIModel-»
«FILE getSpringSecurityHelperJavaFile()»
package «getBaseJavaPackage()».business;

import java.util.*;
import it.csi.iride2.policy.entity.*;
import it.csi.iride2.policy.exceptions.*;
import «getDTOBaseJavaPackage()».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperImports")»

«ENDPROTECT»

public class «getSpringSecurityHelperClassName()»{

       

    //////////////////////////////////////////////////////////////////////////////
	/// Metodi di supporto alla sicurezza.
	//////////////////////////////////////////////////////////////////////////////
	«EXPAND springSecurityHelperMethods FOR this»
	
	//////////////////////////////////////////////////////////////////////////////
	/// Property aggiuntive del bean
	//////////////////////////////////////////////////////////////////////////////
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("SpringSecurityHelperProperties")»
	//// inserire qui le property che si vogliono iniettare in questo bean (es. dao, proxy di pd, ...) 
«ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»

«DEFINE springSecurityHelperMethods FOR GUIModel»
	«EXPAND irideHelperMethods FOR this»
	«EXPAND customConstraintsMethods FOR this»
«ENDDEFINE»

«DEFINE irideHelperMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza basata su IRIDE2
	///////////////////////////////////////////////////////////////////////////////
«ENDDEFINE»

«DEFINE customConstraintsMethods FOR GUIModel»
	///////////////////////////////////////////////////////////////////////////////
	//// Metodi per la sicurezza custom
	///////////////////////////////////////////////////////////////////////////////
	
	«FOREACH structure.appWindow.appArea.contentPanels AS cp-»
	«LET (List[Widget])findAllWidgetsInContentPanel(cp) AS cpWidgets-»
	«LET cpWidgets.select(w|w.securityConstraints.select(c|c.metaType==CustomSecurityConstraint).size>0) AS allCustomConstrainedWidgets-»
	«FOREACH (List[CustomSecurityConstraint])(allCustomConstrainedWidgets.securityConstraints.select(c|c.metaType==CustomSecurityConstraint)) AS currCustomSC-»
	public boolean customCheck«currCustomSC.methodNameSuffix.toFirstUpper()» (Map session){
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("customCheck"+currCustomSC.methodNameSuffix)-»
		/// inserire qui il codice del controllo custom
		return true;
		«ENDPROTECT»
	}
	«ENDFOREACH-»
	«ENDLET-»
	«ENDLET-»
	«ENDFOREACH-»
«ENDDEFINE»