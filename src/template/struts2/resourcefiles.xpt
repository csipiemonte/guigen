«IMPORT guigen»

«IMPORT template::struts2::remoteResources»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»
«EXTENSION org::openarchitectureware::util::stdlib::naming»

«DEFINE resourceFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND indexJspFile(skip_component_dir_creation) FOR this»
	«EXPAND jspFragmentsFile(skip_component_dir_creation) FOR this»
	«EXPAND jspErrorFiles(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera un file di index con la redirect alla welcome action.«ENDREM»
«DEFINE indexJspFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getIndexJspFile(this, skip_component_dir_creation)»<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Welcome</title>
		<meta http-equiv="refresh" content="0;url=HomePage.do"  />
	</head>
	<body>
	</body>
</html>
«ENDFILE»
«ENDDEFINE»


«REM»Espande i frammenti JSP comuni all'applicazione«ENDREM»
«DEFINE jspFragmentsFile(boolean skip_component_dir_creation) FOR GUIModel-»

	«REM»Genera la HEADER«ENDREM»
	«LET this.structure.appWindow.header AS header-»
		«IF header != null-»
			«EXPAND getHeaderMarkup(this, skip_component_dir_creation) FOR header-»
		«ENDIF-»
	«ENDLET-»

	«REM»Genera la MENU BAR«ENDREM»
	«LET this.structure.appWindow.appArea.menubar AS menubar-»
		«IF menubar != null-»
			«EXPAND getMenubarMarkup(this, skip_component_dir_creation) FOR menubar-»
		«ENDIF-»
	«ENDLET-»

	«REM»Genera la FOOTER«ENDREM»
	«LET this.structure.appWindow.footer AS footer-»
		«IF footer != null-»
			«EXPAND getFooterMarkup(this, skip_component_dir_creation) FOR footer-»
		«ENDIF-»
	«ENDLET-»

«ENDDEFINE»


«REM»Genera la componente di markup (HTML) della HEADER«ENDREM»
«DEFINE getHeaderMarkup(GUIModel model, boolean skip_component_dir_creation) FOR Header»
«FILE getJspFragmentsMarkupDir(model, skip_component_dir_creation) + "/header.jsp"»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://www.csi.it/taglibs/remincl-1.0" prefix="r"%>
«EXPAND remoteResources::getHeaderMarkup(model, skip_component_dir_creation) FOR this»
«ENDFILE»

«FILE getJspFragmentsMarkupDir(model, skip_component_dir_creation) + "/headerNoStruts.jsp"»<%@ taglib uri="http://www.csi.it/taglibs/remincl-1.0" prefix="r"%>
<%@ taglib uri="http://java.sun.com/jstl/fmt" prefix="fmt" %>

<fmt:setBundle basename="globalMessages" />

«EXPAND remoteResources::getHeaderMarkupNoStruts(model, skip_component_dir_creation) FOR this»
«ENDFILE»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) della MENUBAR«ENDREM»
«DEFINE getMenubarMarkup(GUIModel model, boolean skip_component_dir_creation) FOR Menubar»
«FILE getJspFragmentsMarkupDir(model, skip_component_dir_creation) + "/menu.jsp"»<%@ taglib prefix="s" uri="/struts-tags" %>
«EXPAND remoteResources::getMenubarMarkup(model, skip_component_dir_creation) FOR this»
«ENDFILE»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) della FOOTER«ENDREM»
«DEFINE getFooterMarkup(GUIModel model, boolean skip_component_dir_creation) FOR Footer»
«FILE getJspFragmentsMarkupDir(model, skip_component_dir_creation) + "/footer.jsp"»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://www.csi.it/taglibs/remincl-1.0" prefix="r"%>

«EXPAND remoteResources::getFooterMarkup(model, skip_component_dir_creation) FOR this»
«ENDFILE»
«ENDDEFINE»


«REM»Crea le pagine di errore dell'applicazione«ENDREM»
«DEFINE jspErrorFiles(boolean skip_component_dir_creation) FOR GUIModel-»
	«EXPAND getJspPageNotFoundErrorFile(skip_component_dir_creation) FOR this-»
	«EXPAND getJspApplicationErrorFile(skip_component_dir_creation) FOR this-»
	«EXPAND getJspFatalErrorFile(skip_component_dir_creation) FOR this-»
	«EXPAND getJspSessionExpiredFile(skip_component_dir_creation) FOR this-»
«ENDDEFINE»



«REM»Crea la pagina di errore 404 (Page Not Found) -> NO STRUTS«ENDREM»
«DEFINE getJspPageNotFoundErrorFile(boolean skip_component_dir_creation) FOR GUIModel-»
«FILE getJspErrorPagesDir(this, skip_component_dir_creation) + "/notFound.jsp"-»
«EXPAND remoteResources::getJspPageNotFoundErrorFile FOR this-»
«ENDFILE-»
«ENDDEFINE»


«REM»Crea la pagina di errore 500 (Internal Server Error) -> NO STRUTS«ENDREM»
«DEFINE getJspFatalErrorFile(boolean skip_component_dir_creation) FOR GUIModel-»
«FILE getJspErrorPagesDir(this, skip_component_dir_creation) + "/fatalError.jsp"-»
«EXPAND remoteResources::getJspFatalErrorFile FOR this-»
«ENDFILE-»
«ENDDEFINE»


«REM»Crea la pagina di errore per le ApplicationError (Runtime) [java.lang.RuntimeException]«ENDREM»
«DEFINE getJspApplicationErrorFile(boolean skip_component_dir_creation) FOR GUIModel-»
«FILE getJspErrorPagesDir(this, skip_component_dir_creation) + "/applicationError.jsp"-»
«EXPAND remoteResources::getJspApplicationErrorFile FOR this-»
«ENDFILE-»
«ENDDEFINE»


«REM»Crea la pagina di sessione scaduta«ENDREM»
«DEFINE getJspSessionExpiredFile(boolean skip_component_dir_creation) FOR GUIModel-»
«FILE getJspErrorPagesDir(this, true) + "/sessionExpired.jsp"-»
«EXPAND remoteResources::getJspPageSessionExpiredFile FOR this-»
«ENDFILE-»
«ENDDEFINE»



«REM»Mappa un ContentPanel con una Action Struts«ENDREM»
«DEFINE actionJspFile(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FILE getStrutsActionJspFile(this, model, skip_component_dir_creation)-»<%@taglib uri="/struts-tags" prefix="s" %>
<%@taglib uri="http://displaytag.sf.net" prefix="display" %>
<%@taglib uri="/customtag" prefix="customtag" %>
«IF hasTable(this) -»
<%@ taglib uri="http://java.sun.com/jstl/fmt" prefix="fmt" %>

<fmt:setBundle basename="«getStrutsActionPath(this, model)»" />
«ENDIF-»

«REM»Genera la HEADER«ENDREM»
«EXPAND setupHeader(model, skip_component_dir_creation) FOR this-»

«REM»Genera il corpo della Pagina«ENDREM»
«EXPAND setupContentPanel(model, skip_component_dir_creation) FOR this-»

«REM»Genera la FOOTER«ENDREM»
«EXPAND setupFooter(model, skip_component_dir_creation) FOR this-»
«ENDFILE-»
«EXPAND createUserDefinedWidgetJspFiles(model, skip_component_dir_creation) FOR this-»
«EXPAND createDialogPanelJspFiles(model, skip_component_dir_creation) FOR this-»
«ENDDEFINE»


«REM»Inserisce, se necessario, la direttiva include per la header«ENDREM»
«DEFINE setupHeader(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel-»
«IF model.structure.appWindow.header != null-»
<s:include value="fragments/header.jsp" ></s:include>
«ENDIF-»
«ENDDEFINE»


«REM»Inserisce, se necessario, la direttiva include per il footer«ENDREM»
«DEFINE setupFooter(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel-»
	«IF model.structure.appWindow.footer != null-»
	<s:include value="fragments/footer.jsp" ></s:include>
	«ENDIF-»
«ENDDEFINE»


«REM»Genera il file JSP di uno UserDefinedWidget.«ENDREM»
«DEFINE createUserDefinedWidgetJspFiles(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
	«LET this.findAllWidgetsInContentPanel().select(w|w. metaType == UserDefinedWidget) AS widgetsList-»
	«FOREACH widgetsList AS currWidg-»
		«EXPAND createUserDefinedWidgetJspFile(model, skip_component_dir_creation, this) FOR (UserDefinedWidget)currWidg-»
	«ENDFOREACH-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE createUserDefinedWidgetJspFile(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp) FOR UserDefinedWidget»
«FILE getJspUserDefinedWidgetMarkupDir(model, skip_component_dir_creation)+"/"+cp.name+"_"+this.name+".jsp" »<%@taglib uri="/struts-tags" prefix="s" %>

<%-- Parametro per la gestione della abilitazione/disabilitazione del widget --%>
<s:set name="«cp.name»_«this.name»_enabled_local" value="isWidgetDisabled('«cp.name»','«this.name»')" />

«PROTECT CSTART '<!--' CEND '-->' ID getRegionUID(cp.name+"_"+this.name)»
<!-- Inserire qui il codice del widget -->
«ENDPROTECT»

«ENDFILE-»
«ENDDEFINE»


«REM»Genera i files JSP per i DialoPanels.«ENDREM»
«DEFINE createDialogPanelJspFiles(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FOREACH this.dialogs AS currentDialog»
	«EXPAND setupDialogPanel(model, skip_component_dir_creation, this) FOR currentDialog»
«ENDFOREACH»
«ENDDEFINE»



«REM»
==========================================================================================================================
Gestione dei pannelli
==========================================================================================================================
«ENDREM»

«REM»Genera il setup del Content Panel«ENDREM»
«DEFINE setupContentPanel(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
<s:form id="«this.name»" name="«this.name»" action="«getStrutsActionConfigName(this)»" method="post">
	«LET this.panels AS currP-»
		«EXPAND setupFirstLevelPanel(model, skip_component_dir_creation, this) FOR currP»
	«ENDLET-»
</s:form>
«ENDDEFINE»


«REM»Genera il setup del pannello di primo livello (unico)«ENDREM»
«DEFINE setupFirstLevelPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp) FOR Panel»
<!-- Creazione del pannello di primo livello «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND remoteResources::setupFirstLevelFormPanel(model, skip_component_dir_creation, cp) FOR (FormPanel)this»
«ELSE-»
	«ERROR "Il pannello di tipo " + this.metaType + " non è ammesso al primo livello - " + loc()»
«ENDIF-»
«ENDDEFINE»


«REM»Crea un sottopannello«ENDREM»
«DEFINE createAndAddSubpanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR Panel»
<!-- Creazione del sottopannello «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (FormPanel)this-»
«ELSEIF this.metaType == MenuPanel-»
	«EXPAND setupMenuPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MenuPanel)this-»
«ELSEIF this.metaType == CommandPanel-»
	«EXPAND setupCommandPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (CommandPanel)this-»
«ELSEIF this.metaType == MultiPanel-»
	«EXPAND setupMultiPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MultiPanel)this-»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (TabSetPanel)this-»
«ELSEIF this.metaType == WizardPanel-»
	«EXPAND setupWizardPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (WizardPanel)this-»
«ELSEIF this.metaType == StdMessagePanel-»
	«EXPAND setupStdMessagePanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (StdMessagePanel)this-»
«ELSEIF this.metaType == UserInfoPanel-»
	«EXPAND setupUserInfoPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (UserInfoPanel)this-»
«ELSEIF this.metaType == UserDefinedPanel-»
	«EXPAND setupUserDefinedPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (UserDefinedPanel)this-»
«ELSE-»
	«ERROR "ERRORE tipo di pannello " + this.metaType + " non gestito! " + loc()»
«ENDIF-»
«ENDDEFINE»


«REM»
************** Form Panel e tipi derivati (CommandPanel, MenuPanel) **************
«ENDREM»

«REM»Genera un form panel«ENDREM»
«DEFINE setupFormPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR FormPanel»
	«IF expandLayout-»
		«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«ENDIF-»

	«REM»Espande i widget del FormPanel corrente«ENDREM»
	«EXPAND createWidgets(model, cp) FOR this»

	«REM»Espande i sottopannelli del FormPanel corrente«ENDREM»
	«FOREACH this.subpanels.select(p | p.metaType != DialogPanel) AS currSubform-»
		«EXPAND createAndAddSubpanel(model, skip_component_dir_creation, cp, true, quadrante) FOR currSubform»
	«ENDFOREACH-»

	«IF expandLayout-»
		«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
	«ENDIF-»
«ENDDEFINE»

«REM»Genera un CommandPanel«ENDREM»
«DEFINE setupCommandPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR CommandPanel»
	«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«EXPAND createWidgets(model, cp) FOR this-»
	«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
«ENDDEFINE»

«REM»Genera un MenuPanel«ENDREM»
«DEFINE setupMenuPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR MenuPanel»
	«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«EXPAND createWidgets(model, cp) FOR this-»
	«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
«ENDDEFINE»


«REM»
************** Multi Panel e tipi derivati (TabsetPanel, WizardPanel) **************
«ENDREM»

«REM»Genera un MultiPanel«ENDREM»
«DEFINE setupMultiPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR MultiPanel»
	«REM»Crea le direttive di include per i files dei sottopannelli e crea i files dei sottopannelli«ENDREM»
	«FOREACH this.panels AS currSubPan ITERATOR i -»
		«EXPAND createAndAddMultiPanelSubpanel(model, skip_component_dir_creation, cp, this, expandLayout, quadrante) FOR currSubPan-»
		«EXPAND createMultiPanelSubpanelIncludeDirective(model, cp, this, i.firstIteration) FOR currSubPan-»
	«ENDFOREACH-»
«ENDDEFINE»

«REM»Genera un TabsetPanel«ENDREM»
«DEFINE setupTabSetPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR TabSetPanel»
	«REM»Definizione del pannello«ENDREM»
	«EXPAND remoteResources::setupTabSetPanel(model) FOR this-»

	«REM»Crea le direttive di include per i files dei tabs e crea i files dei tabs«ENDREM»
	«FOREACH this.panels AS currTab ITERATOR i -»
		«EXPAND createAndAddMultiPanelSubpanel(model, skip_component_dir_creation, cp, this, expandLayout, quadrante) FOR currTab-»
		«EXPAND createMultiPanelSubpanelIncludeDirective(model, cp, this, i.firstIteration) FOR currTab-»
	«ENDFOREACH-»
«ENDDEFINE»

«REM»Genera un WizardPanel«ENDREM»
«DEFINE setupWizardPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR WizardPanel»
	«REM»Definizione del pannello«ENDREM»
	«EXPAND remoteResources::setupWizardPanel(model) FOR this-»
	
	«REM»Crea le direttive di include per i files dei tabs e crea i files dei tabs«ENDREM»
	«FOREACH this.panels AS currStep ITERATOR i -»
		«EXPAND createAndAddMultiPanelSubpanel(model, skip_component_dir_creation, cp, this, expandLayout, quadrante) FOR currStep-»
		«EXPAND createMultiPanelSubpanelIncludeDirective(model, cp, this, i.firstIteration) FOR currStep-»
	«ENDFOREACH-»	
«ENDDEFINE»



«REM»Crea i sottopannelli di un MultiPanel (e dei sottotipi: TabsetPanel)«ENDREM»
«DEFINE createAndAddMultiPanelSubpanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, MultiPanel multiPanel, boolean expandLayout, UDLRCSpecConstants quadrante) FOR Panel»
«FILE getJspMultiPanelFullName(model, skip_component_dir_creation, multiPanel, this)»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://displaytag.sf.net" prefix="display" %>
<%@taglib uri="/customtag" prefix="customtag" %>
«IF hasTable(this) -»
<%@ taglib uri="http://java.sun.com/jstl/fmt" prefix="fmt" %>

<fmt:setBundle basename="«getStrutsActionPath(findParentContentPanel(this), model)»" />
«ENDIF-»

<!-- Creazione del multi panel «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (FormPanel)this-»
«ELSEIF this.metaType == MenuPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MenuPanel)this-»
«ELSEIF this.metaType == CommandPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (CommandPanel)this-»
«ELSEIF this.metaType == MultiPanel-»
	«EXPAND setupMultiPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MultiPanel)this-»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (TabSetPanel)this-»
«ELSEIF this.metaType == WizardPanel-»
	«EXPAND setupWizardPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (WizardPanel)this-»
«ELSE-»
	«ERROR "ERRORE. MultiPanel: tipo di sottopannello " + this + " non gestito"»
«ENDIF-»
«ENDFILE»
«ENDDEFINE»


«REM»la direttiva di include per ogni file che rappresenta un sottopannello di un MultiPanel 
(o di un sottotipo: TabsetPanel)«ENDREM»
«DEFINE createMultiPanelSubpanelIncludeDirective(GUIModel model, ContentPanel cp, MultiPanel multiPanel, boolean isFirst) FOR Panel»
<s:if test="#session.«multiPanel.name»_selectedMultiPanel == '«multiPanel.name+"_"+this.name»'«IF isFirst» || #session.«multiPanel.name»_selectedMultiPanel == null«ENDIF»">
	<s:include value="«getMultiPanelJspInclude(multiPanel, this)»" ></s:include>
</s:if>
«ENDDEFINE»


«REM»
************** StdMessagePanel (Pannello per errori) **************
«ENDREM»

«DEFINE setupStdMessagePanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR StdMessagePanel»
	«EXPAND remoteResources::setupStdMessagePanel(model, cp) FOR this-»
«ENDDEFINE»


«REM»
************** UserInfoPanel (pannello con le informazioni sull'utente loggato) **************
«ENDREM»

«DEFINE setupUserInfoPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR UserInfoPanel»
	«EXPAND remoteResources::setupUserInfoPanel(model, cp) FOR this-»
«ENDDEFINE»


«REM»
************** UserDefinedPanel (Pannello definito dall'utente) **************
«ENDREM»

«DEFINE setupUserDefinedPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR UserDefinedPanel»
	«EXPAND userDefinedPanelInclude(model, cp) FOR this»
	«EXPAND userDefinedPanelFile(model, skip_component_dir_creation, cp) FOR this»
«ENDDEFINE»

«DEFINE userDefinedPanelInclude(GUIModel model, ContentPanel cp) FOR UserDefinedPanel»
<s:include value="«getJspUserDefinedPanelConfig()+"/"+cp.name+"_"+this.name+".jsp"»"></s:include>
«ENDDEFINE»

«DEFINE userDefinedPanelFile(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp) FOR UserDefinedPanel»
«FILE getJspUserDefinedPanelMarkupDir(model, skip_component_dir_creation)+"/"+cp.name+"_"+this.name+".jsp"»<%@ taglib uri="/struts-tags" prefix="s" %>
«PROTECT CSTART '<!--' CEND '-->' ID getRegionUID(cp.name+"_"+this.name)»
<!-- Inserire il codice del pannello -->
«ENDPROTECT»
«ENDFILE»
«ENDDEFINE»


«REM»
************** Dialog Panel **************
Il DialogPanel sarà un pannello figlio di ContentPanel, posizionabile solo al primo livello.
Può contenere solo BoxPanel (nuovo pannello da creare) e CommandPanel
Il BoxPanel è un nuovo tipo di pannello (da creare), che può essere di tipo:
  * INFO    (box con bordo verde)  -> messaggi generici
  * WARNING (box con bordo nero)   -> messaggi di warning
  * ERROR   (box con bordo rosso)  -> messaggi di errore
Ogni BoxPanel può contenere uno o più PlainText che possono avere o staticText o un databinding con un testo dinamico 
(ad esempio messaggio proveniente dalla business logic).
I CommandPanel saranno gestiti come gli altri CommandPanel (pulsanti con eventi).
DialogPanel e BoxPanel ammettono solo VerticalFlowLayout.
Il DialogPanel è implementato come un file sepèarato che però afferisce alla stessa Action del ContentPanel che lo contiene, 
in modo che condividano le stesse proprietà (importante per la business logic)
«ENDREM»
«DEFINE setupDialogPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp) FOR DialogPanel-»
«FILE getJspDialogPanelFullName(model, skip_component_dir_creation, this)-»<%@ taglib uri="/struts-tags" prefix="s" %>
«EXPAND remoteResources::dialogPanelControlHeader(model) FOR this-»

«FOREACH this.msgBoxes AS currentMsgBox-»
	«EXPAND setupMsgBoxPanel(model, cp) FOR currentMsgBox-»
«ENDFOREACH-»

«EXPAND setupCommandPanel(model, skip_component_dir_creation, cp, true, null) FOR this.commands-»

«EXPAND remoteResources::dialogPanelControlFooter(model) FOR this-»
«ENDFILE-»
«ENDDEFINE»


«REM»
************** MsgBoxPanel **************
«ENDREM»
«DEFINE setupMsgBoxPanel(GUIModel model, ContentPanel cp) FOR MsgBoxPanel»
«EXPAND remoteResources::msgBoxPanelControlHeader(model) FOR this-»
«EXPAND createWidgets(model, cp) FOR this»
«EXPAND remoteResources::msgBoxPanelControlFooter(model) FOR this-»
«ENDDEFINE»


«REM»
==========================================================================================================================
Gestione dei Widget
==========================================================================================================================
«ENDREM»

«REM»TODO: nel caso di GridLayout bisogna reimpostare la lista dei widget secondo l'ordine corretto«ENDREM»
«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR FormPanel»
«FOREACH (List[Widget])getWidgetsByOrder(this) AS currWidg ITERATOR wi-»
	«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR currWidg»
«ENDFOREACH-»
«ENDDEFINE»

«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR CommandPanel»
	«FOREACH this.widgets AS currWidg ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (Widget)currWidg»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR MenuPanel»
	«FOREACH this.widgets AS currWidg ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (Widget)currWidg»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR MsgBoxPanel»
	«FOREACH this.textMessages AS currTxt ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (PlainText)currTxt»
	«ENDFOREACH»
«ENDDEFINE»


«REM»Genera la componente COMPLETA di markup (HTML) di un widget generico (HEADER, WIDGET, FOOTER, CLOSE)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel cp, FormPanel fp, Boolean isFirst, Boolean isLast) FOR Widget»
<s:if test="isWidgetVisible('«cp.name»','«this.name»')" >
«EXPAND remoteResources::widgetControlHeader(model, fp, isFirst, isLast) FOR this-»
«EXPAND createWidgetMarkup(model, cp) FOR this-»
«EXPAND remoteResources::widgetControlFooter(model, fp, isFirst, isLast) FOR this-»
</s:if>
«EXPAND remoteResources::widgetClose(model, fp, isFirst, isLast) FOR this-»
«ENDDEFINE»


«REM»Genera la componente COMPLETA di markup (HTML) di un widget di tipo PlainText (HEADER, WIDGET, FOOTER, CLOSE)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel cp, FormPanel fp, Boolean isFirst, Boolean isLast) FOR PlainText»
<s:if test="isWidgetVisible('«cp.name»','«this.name»')" >
«EXPAND remoteResources::widgetControlHeader(model, fp, isFirst, isLast) FOR this-»
«EXPAND createWidgetMarkup(model, cp) FOR this-»
«EXPAND remoteResources::widgetControlFooter(model, fp, isFirst, isLast) FOR this-»
</s:if>
«EXPAND remoteResources::widgetClose(model, fp, isFirst, isLast) FOR this-»
«ENDDEFINE»


«REM»Genera la componente COMPLETA di markup (HTML) di un widget di tipo PlainText (HEADER, WIDGET, FOOTER, CLOSE)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel cp, MsgBoxPanel mbp, Boolean isFirst, Boolean isLast) FOR PlainText»
<s:if test="isWidgetVisible('«cp.name»','«this.name»')" >
«EXPAND remoteResources::widgetControlHeader(model, mbp, isFirst, isLast) FOR this-»
«EXPAND createWidgetMarkup(model, cp) FOR this-»
«EXPAND remoteResources::widgetControlFooter(model, mbp, isFirst, isLast) FOR this-»
</s:if>
«ENDDEFINE»


«REM»Genera la componente COMPLETA di markup (HTML) di un widget di tipo Button [Button, ConfirmButton, ResetButton] (HEADER, WIDGET, FOOTER, CLOSE)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel cp, CommandPanel cmdp, Boolean isFirst, Boolean isLast) FOR Button»
<s:if test="isWidgetVisible('«cp.name»','«this.name»')" >
«EXPAND remoteResources::widgetControlHeader(model, cmdp, isFirst, isLast) FOR this-»
«EXPAND createWidgetMarkup(model, cp) FOR this-»
«EXPAND remoteResources::widgetControlFooter(model, cmdp, isFirst, isLast) FOR this-»
</s:if>
«EXPAND remoteResources::widgetClose(model, cmdp, isFirst, isLast) FOR this-»
«ENDDEFINE»



«REM»Genera la componente di markup (HTML) di un widget generico (non dovrebbe mai essere chiamato, se succede da un errore)«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Widget»
«ERROR "Widget " + this + " non gestito"»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un PlainText.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR PlainText»
<!-- [GUIGEN] Crea il widget «this» -->
«IF this.databinding!=null-»
<s:property value="«getOGNLForWidgetValue(this)»" />
«ELSE-»
«IF !isNullOrEmpty(this.staticText)»<s:text name="«cp.name».«this.name».statictext.label" />«ENDIF»
«ENDIF-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TextField.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TextField»
<!-- [GUIGEN] Crea il widget «this» -->
<s:textfield name="«getOGNLForWidgetValue(this)»" id="«getWidgetName(this)»"
	disabled="isWidgetDisabled('«cp.name»','«this.name»')"
	«getTextFieldStyleByLayout(model, this)»
/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TextField.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR HiddenValue»
<!-- [GUIGEN] Crea il widget «this» -->
<s:hidden name="«getOGNLForWidgetValue(this)»" id="«getWidgetName(this)»" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una TextArea.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TextArea»
<!-- [GUIGEN] Crea il widget «this» -->
<s:textarea name="«getOGNLForWidgetValue(this)»" id="«getWidgetName(this)»"
	disabled="isWidgetDisabled('«cp.name»','«this.name»')"
	«IF this.rows != null»rows="«this.rows»"«ENDIF»
	«IF this.columns != null»cols="«this.columns»"«ENDIF»
	></s:textarea>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) dei radio button.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR RadioButtons»
<!-- [GUIGEN] Crea il widget «this» -->
«FOREACH this.radio AS currRadio»
«EXPAND createWidgetMarkup(model, cp, this) FOR currRadio»
«ENDFOREACH»
«REM»«getRadioButtonsValueChangedHandlerNoScript(this, model)»STDMDD-163: Radio button: implementazione evento di click«ENDREM»
«ENDDEFINE»

«REM»Genera la componente di markup (HTML) di un singolo radio button.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp, RadioButtons parent) FOR RadioButton»
<s:radio id="«getWidgetName(this)»" name="«getOGNLForWidgetValue(parent)»"
	list="#{«getFixedRadioButtonList(this)»}"
	disabled="isWidgetDisabled('«cp.name»','«parent.name»')"
	«getRadioPortalStyle(model)»
	«REM»«getRadioButtonsValueChangedHandlerJS(parent)»STDMDD-163: Radio button: implementazione evento di click«ENDREM»
	/> <s:text name="«cp.name».«parent.name».«this.name».label" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una CheckBox.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR CheckBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:checkbox name="«getOGNLForWidgetValue(this)»" id="«getWidgetName(this)»"
	disabled="isWidgetDisabled('«cp.name»','«this.name»')"
	«getCheckboxPortalStyle(model)»
	/>
<s:hidden name="__checkbox_«getWidgetName(this)»" id="__checkbox_«getWidgetName(this)»" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una ComboBox.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ComboBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:select name="«getOGNLForWidgetValue(this)»" id="«getWidgetName(this)»"
          headerKey="" headerValue=""
          list="«getOGNLForWidgetMultiValue(this)»"
          disabled="isWidgetDisabled('«cp.name»','«this.name»')"
          «IF (databinding!=null && databinding.appData.type.metaType==TypedArray) ||
          	  (databinding==null && dataType.metaType==TypedArray)-»
          multiple="true"
          «ENDIF-»
          «IF this.keySelector!=null && this.keySelector.length>0»listKey="«keySelector»"«ENDIF»
          «IF this.valueSelector!=null && this.valueSelector.length>0»listValue="«valueSelector»"«ENDIF»
          «getComboBoxValueChangedHandlerJS(this)»
          />
«getComboBoxValueChangedHandlerNoScript(this, model)»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante (Button): al momento è renderizzata come un submit.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Button»
<!-- [GUIGEN] Crea il widget «this» -->
<s:submit name="«getWidgetName(this)»" id="«getWidgetName(this)»" method="«getClickHandlerMethodName(this)»" 
	key="«findParentContentPanel(this).name».«this.name».label" «getButtonStyleByLayout(model, this)» 
	disabled="isWidgetDisabled('«cp.name»','«this.name»')" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di submit del form.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ConfirmButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:submit name="«getWidgetName(this)»" id="«getWidgetName(this)»" method="«getClickHandlerMethodName(this)»"
	key="«findParentContentPanel(this).name».«this.name».label" «getButtonStyleByLayout(model, this)» 
	disabled="isWidgetDisabled('«cp.name»','«this.name»')" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di reset del form.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ResetButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:reset name="«getWidgetName(this)»" id="«getWidgetName(this)»" key="«findParentContentPanel(this).name».«this.name».label" 
	«getButtonStyleByLayout(model, this)» disabled="isWidgetDisabled('«cp.name»','«this.name»')" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una immagine. TODO: implementare«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Image»
<!-- [GUIGEN] Crea il widget «this» -->
<img src="«this.image»" alt="«this.label»"/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una tabella. Implementato tramite DisplayTag«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Table»
<!-- [GUIGEN] Crea il widget «this» -->
«LET this.enableExport ? "true" : "false" AS exportEnabled»
<s:set name="«cp.name»_«this.name»_clearStatus" value="isTableClearStatus('«cp.name»_«this.name»')" />
<display:table name="«getOGNLForWidgetMultiValue(this)»"
               excludedParams="*"
               form="«cp.name»"
               export="«enableExport»"
               id="«getWidgetName(this)»"
               pagesize="«this.pageSize»"
               requestURI="«getStrutsActionConfigName(cp)».do"
               keepStatus="true"
               clearStatus="${«cp.name»_«this.name»_clearStatus}"
               uid="row_«this.name»"
               «IF customDecorator-»
               decorator="«getTableDecoratorFQN(model,this)»"
               «ENDIF-»
               «getTablePortalStyle(model)» >
	«IF this.databinding != null -»
		<display:column headerClass="nosort">
		«IF this.databinding.appData.type.metaType == SimpleType -»
			<s:radio list="%{#attr.row_«this.name».«columnModel.valueSelector»}" name="«getOGNLForWidgetValue(this)»" «getCheckboxPortalStyle(model)» />
		«ELSEIF this.databinding.appData.type.metaType == TypedArray -»
			<s:checkboxlist list="%{#attr.row_«this.name».«columnModel.valueSelector»}" name="«getOGNLForWidgetValue(this)»" «getRadioPortalStyle(model)» />
		«ENDIF-»
		</display:column>
	«ENDIF-»
	«LET this.columnModel AS tabColMod-»
	«FOREACH tabColMod.columns AS currCol-»
		«IF currCol.editable-»
		<display:column titleKey="«cp.name».«this.name».«currCol.selector».label" sortable="«currCol.sortable»" headerClass="«currCol.sortable ? "sortable" : "nosort"»" «getColumnComparator(model, currCol, this)»>
			<s:textfield name="%{'«getOGNLForWidgetMultiValue(this)»[' + (#attr.row_«this.name»_rowNum - 1) + '].«currCol.selector»'}" cssClass="minim"/>
		</display:column>
		«ELSE-»
		<display:column property="«currCol.selector»" titleKey="«cp.name».«this.name».«currCol.selector».label" «getColumnAction(currCol, this, cp)»
			sortable="«currCol.sortable»" headerClass="«currCol.sortable ? "sortable" : "nosort"»"
			«getColumnFormatter(currCol, this)» «getColumnComparator(model, currCol, this)» «getColumnStyle(currCol, this, model)» />
		«ENDIF-»
	«ENDFOREACH-»
	«ENDLET-»
</display:table>
«ENDLET»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un MenuView (segnaposto per il menu).«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR MenuView»
«IF model.structure.appWindow.appArea.menubar != null-»
	<s:include value="fragments/menu.jsp"></s:include>
«ENDIF-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TreeView.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TreeView»
«REM»TODO: verificare se questo id va bene«ENDREM»
<div id="menuTree">
	<customtag:tree
		name="«getOGNLForWidgetMultiValue(this)»"
		cssUlClass="tree" 
        cssRootClass="treeRoot" cssFolderOpenClass="treeFolderOpen" 
        cssFolderClosedClass="treeFolderClosed" cssDotClass="treeDot" 
		linkOnTree="true" id="«name»"
		«IF this.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size==1-»
		requestURI="«getStrutsActionConfigName(cp)»!«getHandlerMethodName(this,this.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).first())».do" showChildNumber="false">
		«ELSE-»
		requestURI="«getStrutsActionConfigName(cp)».do" showChildNumber="false">
		«ENDIF-»
	</customtag:tree>
</div>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un Calendar.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Calendar»
«ERROR "Il Widget Calendar non è ancora gestito"»
«ENDDEFINE»


«REM»
Genera la componente di markup (HTML) di uno UserDefinedWidget.
La componente UserDefinedWidget consiste in una jsp separata dove lo sviluppatore scrive, in regione protetta,
il codice necessario, e nella direttiva include inserita laddove il widget deve essere posizionato.
NOTA: lo sviluppatore è responsabile del codice che inserisca all'interno di tale widget.
«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR UserDefinedWidget»
<s:include value="«getJspUserDefinedWidgetConfig()+"/"+cp.name+"_"+this.name+".jsp"»"></s:include>
«ENDDEFINE»
