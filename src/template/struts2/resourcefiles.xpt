«IMPORT guigen»

«IMPORT template::struts2::remoteResources»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE resourceFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND indexJspFile(skip_component_dir_creation) FOR this»
	«EXPAND jspFragmentsFile(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera un file di index con la redirect alla welcome action.«ENDREM»
«DEFINE indexJspFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getIndexJspFile(this, skip_component_dir_creation)»<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Welcome</title>
		<meta http-equiv="refresh" content="0;url=HomePage.do"  />
	</head>
	<body>
	</body>
</html>
«ENDFILE»
«ENDDEFINE»


«REM»Espande i frammenti JSP comuni all'applicazione«ENDREM»
«DEFINE jspFragmentsFile(boolean skip_component_dir_creation) FOR GUIModel»

		«REM»Genera la HEADER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.header AS header»
			«IF header != null»
				«EXPAND template::struts2::remoteResources::getHeaderMarkup(this, skip_component_dir_creation) FOR header»
			«ENDIF»
		«ENDLET»

		«REM»Genera la MENU BAR (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.appArea.menubar AS menubar»
			«IF menubar != null»
				«EXPAND template::struts2::remoteResources::getMenubarMarkup(this, skip_component_dir_creation) FOR menubar»
			«ENDIF»		
		«ENDLET»

		«REM»Genera la FOOTER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.footer AS footer»
			«IF footer != null»
				«EXPAND template::struts2::remoteResources::getFooterMarkup(this, skip_component_dir_creation) FOR footer»
			«ENDIF»
		«ENDLET»

«ENDDEFINE»


«REM»Mappa un ContentPanel con una Action Struts«ENDREM»
«DEFINE actionJspFile(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FILE getStrutsActionJspFile(this, model, skip_component_dir_creation)»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://displaytag.sf.net" prefix="display" %>

		«REM»Genera la HEADER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET model.structure.appWindow.header AS header-»
		«IF header != null-»
		<s:include value="fragments/header.jsp" ></s:include>
		«ENDIF-»
		«ENDLET-»
		

		«REM»Genera il corpo della Pagina«ENDREM»
		«EXPAND setupContentPanel(model, skip_component_dir_creation) FOR this-»


		«REM»Genera la FOOTER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET model.structure.appWindow.footer AS footer-»
		«IF footer != null-»
		<s:include value="fragments/footer.jsp" ></s:include>
		«ENDIF-»
		«ENDLET-»

«ENDFILE»
«ENDDEFINE»


«REM»
==========================================================================================================================
Gestione dei pannelli
==========================================================================================================================
«ENDREM»

«REM»Genera il setup del «ENDREM»
«DEFINE setupContentPanel(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
<s:form action="«getStrutsActionConfigName(this)»" method="post">
	«LET this.panels AS currP-»
		«EXPAND setupFirstLevelPanel(model, skip_component_dir_creation, this) FOR currP»
	«ENDLET-»
</s:form>
«ENDDEFINE»


«REM»Genera il setup del pannello di primo livello (unico)«ENDREM»
«DEFINE setupFirstLevelPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel panel) FOR Panel»
<!-- Creazione del pannello «this» -->
«EXPAND firstLevelPanelPreLayout FOR this»

«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, panel) FOR (FormPanel)this»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model, skip_component_dir_creation, panel) FOR (TabSetPanel)this»
«ELSEIF this.metaType == DialogPanel-»
	«REM»TODO: IMPLEMENTARE«ENDREM»
«ENDIF-»

«EXPAND firstLevelPanelPostLayout FOR this»

«ENDDEFINE»


«REM»comment«ENDREM»
«DEFINE setupFormPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel panel) FOR FormPanel»

	«REM»Espande i widget del FormPanel corrente«ENDREM»
	«FOREACH this.widgets AS currWidg-»
		«EXPAND createAndAddWidgetMarkup(model, panel) FOR currWidg»
	«ENDFOREACH-»
	
	«REM»Espande i sottopannelli del FormPanel corrente«ENDREM»
	«FOREACH this.subpanels.select(p | p.metaType != DialogPanel) AS currSubform-»
		«EXPAND createAndAddSubpanel(model, skip_component_dir_creation, panel) FOR currSubform»
	«ENDFOREACH-»
	
«ENDDEFINE»


«REM»
Genera un tabset panel
TODO: 
1. stili: ci sono stili diversi da gestire sulla base della posizione del pannello e della sua attivazione o meno
     - tab3 (tab normale), tabAttivo3 (nel caso il tab sia attivo)
     - tabUltimo3 (ultimo tab del pannello), tabAttivoUltimo3 (nel caso l'ultimo tab sia attivo)
2. come si implementano i singoli tab del tabbed panel?
     - pagine jsp separate incluse a runtime?
     - layer (<div>)?
   Ricordarsi che il tipo di implementazione incide anche sul passaggio dei dati al submit del form.
3. Come si implementa l'azione di cambio tab? 
     Nel caso di pagine separate deve essere prevista nella Action (file Java) un nuovo tipo di azione (command) 
     da inserire automaticamente nel caso il ContentPanel contenga uno o più TabbedPanel che preveda il settaggio 
     del tab selezionato come attivo e il ricaricamento della pagina (jump action su se stessa) 
     in modo da visualizzare il tab selezionato. 
     Nel caso di implementazione a layer, lazione è da realizzare via Javascript. 
     Ricordarsi che a seconda dell'implementazione scelta per i tab, 
     può essere necessario una memorizzazione dei dati delle form.
4. Come si riconosce il tab attivo? 
     Come per il menu attivo, si potrebbe ipotizzare di salvare da qualche parte il tab attivo 
     per poi utilizzare dinamicamente a runtime l'informazione sulla JSP via OGNL. 
     Bisogna determinare lo scope di questa informazione (session, Action, page,...).
5. I tabbed panels possono essere annidati: un sottopannello di un tab può essere a sua volta un tabbed panel, 
     quindi l'informazione DEI tab attivi va strutturata opportunamente in maniera da evitare 
     dannose sovrapposizioni di nomi (i nomi dei componenti sono univoci a livello di ContentPanel?).
«ENDREM»
«DEFINE setupTabSetPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel panel) FOR TabSetPanel»
	«REM»TAPPO PER PROVARE SENZA LOGICA JAVA DI APPOGGIO -> SOSTITUIRE CON LOGICA VERA«ENDREM»
	<s:set name="«this.name»_selectedTab" value="%{'«this.name+"_"+this.tabs.first().name»'}" />
	«REM»TAPPO PER PROVARE SENZA LOGICA JAVA DI APPOGGIO -> SOSTITUIRE CON LOGICA VERA«ENDREM»
	
	«REM»Definizione del pannello«ENDREM»
	«EXPAND template::struts2::remoteResources::setupTabSetPanelByPortal(model) FOR this»

	«REM»Crea le direttive di include per i files dei tabs e crea i files dei tabs
	TODO: determinare meccanismo di inclusione del tab selezionato (deafult: primo tab)«ENDREM»
	«FOREACH this.tabs AS currTab -»
		«EXPAND createAndAddTab(model, skip_component_dir_creation, panel, this) FOR currTab-»
		«EXPAND createTabIncludeDirective(model, panel, this) FOR currTab»
	«ENDFOREACH-»
	
«ENDDEFINE»


«REM»Crea un sottopannello«ENDREM»
«DEFINE createAndAddSubpanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel panel) FOR Panel»
<!-- Creazione del sottopannello «this» -->
«EXPAND subPanelPreLayout FOR this-»

«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, panel) FOR (FormPanel)this»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model,skip_component_dir_creation, panel) FOR (TabSetPanel)this»
«ELSE-»
	<!-- ERRORE tipo di pannello «this» non gestito!!!! -->
«ENDIF-»

«EXPAND subPanelPostLayout FOR this-»

«ENDDEFINE»


«REM»Crea i files per ogni singolo tab«ENDREM»
«DEFINE createAndAddTab(GUIModel model, boolean skip_component_dir_creation, ContentPanel panel, TabSetPanel tabPanel) FOR Panel»
«FILE getJspTabsMarkupDir(model, skip_component_dir_creation)+"/"+tabPanel.name+"_"+this.name+".jsp"»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://displaytag.sf.net" prefix="display" %>

<!-- Creazione del tab «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, panel) FOR (FormPanel)this»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model, skip_component_dir_creation, panel) FOR (TabSetPanel)this»
«ELSE-»
	<!-- ERRORE tipo di tab «this» non gestito!!!! -->
«ENDIF-»
«ENDFILE»
«ENDDEFINE»


«REM»la direttiva di include per ogni file che rappresenta un Tab«ENDREM»
«DEFINE createTabIncludeDirective(GUIModel model, ContentPanel panel, TabSetPanel tabPanel) FOR Panel»
<s:if test="%{#«tabPanel.name»_selectedTab == '«tabPanel.name+"_"+this.name»'}">
	<s:include value="«getJspTabsConfig()+"/"+tabPanel.name+"_"+this.name+".jsp"»" ></s:include>
</s:if>
«ENDDEFINE»





«REM»
==========================================================================================================================
Gestione dei Widget
==========================================================================================================================
«ENDREM»

«REM»Genera la componente di markup (HTML) di un widget generico (non dovrebbe mai essere chiamato)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR Widget»
<!-- [GUIGEN] widget non gestito: «this» -->
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TextField.«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR TextField»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:textfield name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
		«IF this.fieldLength != null»size="«this.fieldLength»"«ENDIF» 
		disabled="#session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled"
	/>
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una TextArea.«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR TextArea»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:textarea name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
		disabled="#session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled"
		«IF this.rows != null»rows="«this.rows»"«ENDIF»
		«IF this.columns != null»cols="«this.columns»"«ENDIF»
		></s:textarea>
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) dei radio button. TODO: implementare«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR RadioButtons»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:radio id="widg_«this.name»" name="«getOGNLForWidgetValue(this)»" label="«this.label»"
		list="#{«getFixedRadioButtonList(this)»}" 
		disabled="#session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled" 
		/>
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una CheckBox.«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR CheckBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:checkbox name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
		disabled="#session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled" 
		/>
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una ComboBox.«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR ComboBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:select name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
	          headerKey="00" headerValue="-- Selezionare un valore --"
	          list="«getOGNLForWidgetMultiValue(this)»"
	          disabled="session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled"
	          «IF this.keySelector!=null && this.keySelector.length>0»listKey="«keySelector»"«ENDIF»
	          «IF this.valueSelector!=null && this.valueSelector.length>0»listValue="«valueSelector»"«ENDIF»
	          />
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante (Button).«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR Button»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:submit name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" disabled="session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled" />
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di submit del form.«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR ConfirmButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:submit name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" disabled="session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled"/>
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di reset del form. 
NOTA: implementato per il momento SOLO in HTML«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR ResetButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
	<s:reset name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" disabled="session.«panel.name».«this.name»_enabled!=null && !#session.«panel.name».«this.name»_enabled" />
</s:if>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una immagine. TODO: implementare«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR Image»
<!-- [GUIGEN] Crea il widget «this» -->
<img src="«this.image»" alt="«this.label»"/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una tabella. Implementato tramite DisplayTag«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel panel) FOR Table»
<!-- [GUIGEN] Crea il widget «this» -->

«REM»tag implementation: KEEP«ENDREM»
<s:if test="#session.«panel.name»==null || #session.«panel.name».«this.name»_visible==null || #session.«panel.name».«this.name»_visible" >
<display:table name="«getOGNLForWidgetMultiValue(this)»" 
               export="true" 
               defaultsort="1" 
               defaultorder="descending" 
               id="rowR" 
               pagesize="«this.pageSize»" 
               requestURI="«getStrutsActionConfigName(panel)».do" 
               keepStatus="true"
               clearStatus="false"
               «getTablePortalStyle(model)» >
	«LET this.columnModel AS tabColMod-»
		«FOREACH tabColMod.columns AS currCol-»
		<display:column property="«currCol.selector»" title="«currCol.label»" sortable="«currCol.sortable»" headerClass="sortable" />
		«ENDFOREACH-»
	«ENDLET-»
</display:table>
</s:if>
«ENDDEFINE»


«REM»
==========================================================================================================================
Gestione dei LAYOUT
==========================================================================================================================
«ENDREM»

«REM»comment«ENDREM»
«DEFINE firstLevelPanelPreLayout FOR Panel»
«IF this.layout.metaType == VerticalFlowPanelLayout-»
	<h3>«this.label.toUpperCase()»</h3>
	<!--<table>-->
«ELSE-»
	<fieldset>
		<legend>«this.label.toUpperCase()»</legend>
«ENDIF-»
«ENDDEFINE»


«REM»comment«ENDREM»
«DEFINE firstLevelPanelPostLayout FOR Panel»
«IF this.layout.metaType == VerticalFlowPanelLayout-»
	<!--</table>-->
«ELSE-»
	</fieldset>
«ENDIF-»
«ENDDEFINE»


«REM»comment«ENDREM»
«DEFINE subPanelPreLayout FOR Panel»
«IF this.layout.metaType == VerticalFlowPanelLayout-»
	«IF this.label != null -»
	<h4>«this.label.toUpperCase()»</h4>
	«ENDIF-»
	
	<table>
«ELSE-»
	<fieldset>
		<legend>«this.label.toUpperCase()»</legend>
«ENDIF-»
«ENDDEFINE»


«REM»comment«ENDREM»
«DEFINE subPanelPostLayout FOR Panel»
«IF this.layout.metaType == VerticalFlowPanelLayout-»
	</table>
«ELSE-»
	</fieldset>
«ENDIF-»
«ENDDEFINE»








