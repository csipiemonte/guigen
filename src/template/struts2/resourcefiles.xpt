«IMPORT guigen»

«IMPORT template::struts2::remoteResources»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE resourceFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND indexJspFile(skip_component_dir_creation) FOR this»
	«EXPAND jspFragmentsFile(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera un file di index con la redirect alla welcome action.«ENDREM»
«DEFINE indexJspFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getIndexJspFile(this, skip_component_dir_creation)»<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Welcome</title>
		<meta http-equiv="refresh" content="0;url=HomePage.do"  />
	</head>
	<body>
	</body>
</html>
«ENDFILE»
«ENDDEFINE»


«REM»Espande i frammenti JSP comuni all'applicazione«ENDREM»
«DEFINE jspFragmentsFile(boolean skip_component_dir_creation) FOR GUIModel»

		«REM»Genera la HEADER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.header AS header-»
			«IF header != null-»
				«EXPAND template::struts2::remoteResources::getHeaderMarkup(this, skip_component_dir_creation) FOR header-»
			«ENDIF-»
		«ENDLET-»

		«REM»Genera la MENU BAR (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.appArea.menubar AS menubar-»
			«IF menubar != null-»
				«EXPAND template::struts2::remoteResources::getMenubarMarkup(this, skip_component_dir_creation) FOR menubar-»
			«ENDIF-»
		«ENDLET-»

		«REM»Genera la FOOTER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«LET this.structure.appWindow.footer AS footer-»
			«IF footer != null-»
				«EXPAND template::struts2::remoteResources::getFooterMarkup(this, skip_component_dir_creation) FOR footer-»
			«ENDIF-»
		«ENDLET-»

«ENDDEFINE»


«REM»Mappa un ContentPanel con una Action Struts«ENDREM»
«DEFINE actionJspFile(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FILE getStrutsActionJspFile(this, model, skip_component_dir_creation)-»<%@taglib uri="/struts-tags" prefix="s" %>
<%@taglib uri="http://displaytag.sf.net" prefix="display" %>
<%@taglib uri="/customtag" prefix="customtag" %>

		«REM»Genera la HEADER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«EXPAND setupHeader(model, skip_component_dir_creation) FOR this-»

		«REM»Genera il corpo della Pagina«ENDREM»
		«EXPAND setupContentPanel(model, skip_component_dir_creation) FOR this-»

		«REM»Genera la FOOTER (NOTA: è una possibile implementazione, migliorabile)«ENDREM»
		«EXPAND setupFooter(model, skip_component_dir_creation) FOR this-»
«ENDFILE-»
«ENDDEFINE»


«REM»Inserisce, se necessario, la direttiva include per la header«ENDREM»
«DEFINE setupHeader(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel-»
	«IF model.structure.appWindow.header != null-»
	<s:include value="fragments/header.jsp" ></s:include>
	«ENDIF-»
«ENDDEFINE»


«REM»Inserisce, se necessario, la direttiva include per il footer«ENDREM»
«DEFINE setupFooter(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel-»
	«IF model.structure.appWindow.footer != null-»
	<s:include value="fragments/footer.jsp" ></s:include>
	«ENDIF-»
«ENDDEFINE»



«REM»
==========================================================================================================================
Gestione dei pannelli
==========================================================================================================================
«ENDREM»

«REM»Genera il setup del Content Panel«ENDREM»
«DEFINE setupContentPanel(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
<s:form action="«getStrutsActionConfigName(this)»" method="post" theme="simple">
	«LET this.panels AS currP-»
		«EXPAND setupFirstLevelPanel(model, skip_component_dir_creation, this) FOR currP»
	«ENDLET-»
</s:form>
«ENDDEFINE»


«REM»Genera il setup del pannello di primo livello (unico)«ENDREM»
«DEFINE setupFirstLevelPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp) FOR Panel»
<!-- Creazione del pannello di primo livello «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND remoteResources::setupFirstLevelFormPanel(model, skip_component_dir_creation, cp) FOR (FormPanel)this»
«ELSEIF this.metaType == TabSetPanel-»
	«REM»Al momento facciamo l'assunzione che al primo livello posso mettere solo Form Panels.«ENDREM»
«ELSEIF this.metaType == DialogPanel-»
	«REM»TODO: IMPLEMENTARE«ENDREM»
«ENDIF-»
«ENDDEFINE»


«REM»Crea un sottopannello«ENDREM»
«DEFINE createAndAddSubpanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR Panel»
<!-- Creazione del sottopannello «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (FormPanel)this-»
«ELSEIF this.metaType == MenuPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MenuPanel)this-»
«ELSEIF this.metaType == CommandPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (CommandPanel)this-»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model,skip_component_dir_creation, cp, expandLayout, quadrante) FOR (TabSetPanel)this-»
«ELSE-»
	<!-- ERRORE tipo di pannello «this» non gestito!!!! -->
«ENDIF-»
«ENDDEFINE»


«REM»
************** Form Panel **************
«ENDREM»

«REM»comment«ENDREM»
«DEFINE setupFormPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR FormPanel»
	«IF expandLayout-»
		«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«ENDIF-»

	«REM»Espande i widget del FormPanel corrente«ENDREM»
	«EXPAND createWidgets(model, cp) FOR this»

	«REM»Espande i sottopannelli del FormPanel corrente«ENDREM»
	«FOREACH this.subpanels.select(p | p.metaType != DialogPanel) AS currSubform-»
		«EXPAND createAndAddSubpanel(model, skip_component_dir_creation, cp, true, quadrante) FOR currSubform»
	«ENDFOREACH-»

	«IF expandLayout-»
		«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
	«ENDIF-»

«ENDDEFINE»

«REM»«ENDREM»
«DEFINE setupFormPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR CommandPanel»
	«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«EXPAND createWidgets(model, cp) FOR this»
	«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
«ENDDEFINE»

«REM»«ENDREM»
«DEFINE setupFormPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR MenuPanel»
	«EXPAND remoteResources::subPanelControlHeader(model, quadrante) FOR this-»
	«EXPAND createWidgets(model, cp) FOR this»
	«EXPAND remoteResources::subPanelControlFooter(model, quadrante) FOR this-»
«ENDDEFINE»


«REM»
************** Tabset Panel **************
«ENDREM»

«REM»
Genera un tabset panel
TODO:
1. stili: ci sono stili diversi da gestire sulla base della posizione del pannello e della sua attivazione o meno
     - tab3 (tab normale), tabAttivo3 (nel caso il tab sia attivo)
     - tabUltimo3 (ultimo tab del pannello), tabAttivoUltimo3 (nel caso l'ultimo tab sia attivo)
2. come si implementano i singoli tab del tabbed panel?
     - pagine jsp separate incluse a runtime?
     - layer (<div>)?
   Ricordarsi che il tipo di implementazione incide anche sul passaggio dei dati al submit del form.
3. Come si implementa l'azione di cambio tab?
     Nel caso di pagine separate deve essere prevista nella Action (file Java) un nuovo tipo di azione (command)
     da inserire automaticamente nel caso il ContentPanel contenga uno o più TabbedPanel che preveda il settaggio
     del tab selezionato come attivo e il ricaricamento della pagina (jump action su se stessa)
     in modo da visualizzare il tab selezionato.
     Nel caso di implementazione a layer, lazione è da realizzare via Javascript.
     Ricordarsi che a seconda dell'implementazione scelta per i tab,
     può essere necessario una memorizzazione dei dati delle form.
4. Come si riconosce il tab attivo?
     Come per il menu attivo, si potrebbe ipotizzare di salvare da qualche parte il tab attivo
     per poi utilizzare dinamicamente a runtime l'informazione sulla JSP via OGNL.
     Bisogna determinare lo scope di questa informazione (session, Action, page,...).
5. I tabbed panels possono essere annidati: un sottopannello di un tab può essere a sua volta un tabbed panel,
     quindi l'informazione DEI tab attivi va strutturata opportunamente in maniera da evitare
     dannose sovrapposizioni di nomi (i nomi dei componenti sono univoci a livello di ContentPanel?).
«ENDREM»
«DEFINE setupTabSetPanel(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, boolean expandLayout, UDLRCSpecConstants quadrante) FOR TabSetPanel»
	«REM»TAPPO PER PROVARE SENZA LOGICA JAVA DI APPOGGIO -> SOSTITUIRE CON LOGICA VERA«ENDREM»
	<s:set name="«this.name»_selectedTab" value="%{'«this.name+"_"+this.tabs.first().name»'}" />
	«REM»TAPPO PER PROVARE SENZA LOGICA JAVA DI APPOGGIO -> SOSTITUIRE CON LOGICA VERA«ENDREM»

	«REM»Definizione del pannello«ENDREM»
	«EXPAND remoteResources::setupTabSetPanelByPortal(model) FOR this-»

	«REM»Crea le direttive di include per i files dei tabs e crea i files dei tabs
	TODO: determinare meccanismo di inclusione del tab selezionato (deafult: primo tab)«ENDREM»
	«FOREACH this.tabs AS currTab -»
		«EXPAND createAndAddTab(model, skip_component_dir_creation, cp, this, expandLayout, quadrante) FOR currTab-»
		«EXPAND createTabIncludeDirective(model, cp, this) FOR currTab-»
	«ENDFOREACH-»

«ENDDEFINE»


«REM»Crea i files per ogni singolo tab«ENDREM»
«DEFINE createAndAddTab(GUIModel model, boolean skip_component_dir_creation, ContentPanel cp, TabSetPanel tabPanel, boolean expandLayout, UDLRCSpecConstants quadrante) FOR Panel»
«FILE getJspTabsMarkupDir(model, skip_component_dir_creation)+"/"+tabPanel.name+"_"+this.name+".jsp"»<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib uri="http://displaytag.sf.net" prefix="display" %>
<!-- Creazione del tab «this» -->
«IF this.metaType == FormPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (FormPanel)this-»
«ELSEIF this.metaType == MenuPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (MenuPanel)this-»
«ELSEIF this.metaType == CommandPanel-»
	«EXPAND setupFormPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (CommandPanel)this-»
«ELSEIF this.metaType == TabSetPanel-»
	«EXPAND setupTabSetPanel(model, skip_component_dir_creation, cp, expandLayout, quadrante) FOR (TabSetPanel)this-»
«ELSE-»
	<!-- ERRORE tipo di tab «this» non gestito!!!! -->
«ENDIF-»
«ENDFILE»
«ENDDEFINE»


«REM»la direttiva di include per ogni file che rappresenta un Tab«ENDREM»
«DEFINE createTabIncludeDirective(GUIModel model, ContentPanel cp, TabSetPanel tabPanel) FOR Panel»
<s:if test="%{#«tabPanel.name»_selectedTab == '«tabPanel.name+"_"+this.name»'}">
	<s:include value="«getJspTabsConfig()+"/"+tabPanel.name+"_"+this.name+".jsp"»" ></s:include>
</s:if>
«ENDDEFINE»


«REM»
************** Dialog Panel **************
«ENDREM»





«REM»
==========================================================================================================================
Gestione dei Widget
==========================================================================================================================
«ENDREM»

«REM»TODO: nel caso di GridLayout bisogna reimpostare la lista dei widget secondo l'ordine corretto«ENDREM»
«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR FormPanel»
«LET getWidgetsByOrder(this) AS widgetsList»
	«FOREACH widgetsList AS currWidg ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (Widget)currWidg»
	«ENDFOREACH-»
«ENDLET»
«ENDDEFINE»

«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR CommandPanel»
	«FOREACH this.widgets AS currWidg ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (Widget)currWidg»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE createWidgets(GUIModel model, ContentPanel cp) FOR MenuPanel»
	«FOREACH this.widgets AS currWidg ITERATOR wi-»
		«EXPAND createAndAddWidgetMarkup(model, cp, this, wi.firstIteration, wi.lastIteration) FOR (Widget)currWidg»
	«ENDFOREACH-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) che va di un widget generico (non dovrebbe mai essere chiamato)«ENDREM»
«DEFINE createAndAddWidgetMarkup(GUIModel model, ContentPanel cp, FormPanel fp, Boolean isFirst, Boolean isLast) FOR Widget»
<s:if test="#session.«cp.name»==null || #session.«cp.name».«this.name»_visible==null || #session.«cp.name».«this.name»_visible" >
«EXPAND remoteResources::widgetControlHeader(model, fp, isFirst, isLast) FOR this-»
«EXPAND createWidgetMarkup(model, cp) FOR this»
«EXPAND remoteResources::widgetControlFooter(model, fp, isFirst, isLast) FOR this-»
</s:if>
«EXPAND remoteResources::widgetClose(model, fp, isFirst, isLast) FOR this-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un widget generico (non dovrebbe mai essere chiamato)«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Widget»
<!-- [GUIGEN] widget non gestito: «this» -->
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un PlainText.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR PlainText»
<!-- [GUIGEN] Crea il widget «this» -->
«IF this.databinding!=null-»
<s:property value="«getOGNLForWidgetValue(this)»" />
«ELSE-»
<s:text name="widg_«this.name»">«staticText»</s:text>
«ENDIF-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TextField.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TextField»
<!-- [GUIGEN] Crea il widget «this» -->
<s:textfield name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»"
	«IF this.fieldLength != null»size="«this.fieldLength»"«ENDIF»
	disabled="#session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"
/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una TextArea.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TextArea»
<!-- [GUIGEN] Crea il widget «this» -->
<s:textarea name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
	disabled="#session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"
	«IF this.rows != null»rows="«this.rows»"«ENDIF»
	«IF this.columns != null»cols="«this.columns»"«ENDIF»
	></s:textarea>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) dei radio button. TODO: implementare«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR RadioButtons»
<!-- [GUIGEN] Crea il widget «this» -->
<s:radio id="widg_«this.name»" name="«getOGNLForWidgetValue(this)»" label="«this.label»"
	list="#{«getFixedRadioButtonList(this)»}"
	disabled="#session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"
	/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una CheckBox.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR CheckBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:checkbox name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
	disabled="#session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"
	/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una ComboBox.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ComboBox»
<!-- [GUIGEN] Crea il widget «this» -->
<s:select name="«getOGNLForWidgetValue(this)»" id="widg_«this.name»" label="«this.label»"
          headerKey="00" headerValue="-- Selezionare un valore --"
          list="«getOGNLForWidgetMultiValue(this)»"
          disabled="session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"
          «IF this.keySelector!=null && this.keySelector.length>0»listKey="«keySelector»"«ENDIF»
          «IF this.valueSelector!=null && this.valueSelector.length>0»listValue="«valueSelector»"«ENDIF»
          />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante (Button): al momento è renderizzata come un submit.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Button»
<!-- [GUIGEN] Crea il widget «this» -->
<s:submit name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" method="«getClickHandlerMethodName(this)»" 
	«getButtonStyleByLayout(model, this)» disabled="session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di submit del form.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ConfirmButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:submit name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" method="«getClickHandlerMethodName(this)»"
	«getButtonStyleByLayout(model, this)» disabled="session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled"/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un pulsante di reset del form.
«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR ResetButton»
<!-- [GUIGEN] Crea il widget «this» -->
<s:reset name="widg_«this.name»" id="widg_«this.name»" value="«this.label»" «getButtonStyleByLayout(model, this)»
	disabled="session.«cp.name».«this.name»_enabled!=null && !#session.«cp.name».«this.name»_enabled" />
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una immagine. TODO: implementare«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Image»
<!-- [GUIGEN] Crea il widget «this» -->
<img src="«this.image»" alt="«this.label»"/>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di una tabella. Implementato tramite DisplayTag«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Table»
<!-- [GUIGEN] Crea il widget «this» -->
<display:table name="«getOGNLForWidgetMultiValue(this)»"
               export="true"
               defaultsort="1"
               defaultorder="descending"
               id="rowR"
               pagesize="«this.pageSize»"
               requestURI="«getStrutsActionConfigName(cp)».do"
               keepStatus="true"
               clearStatus="false"
               «getTablePortalStyle(model)» >
	«LET this.columnModel AS tabColMod-»
		«FOREACH tabColMod.columns AS currCol-»
		<display:column property="«currCol.selector»" title="«currCol.label»" sortable="«currCol.sortable»" headerClass="sortable" />
		«ENDFOREACH-»
	«ENDLET-»
</display:table>
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un MenuView (segnaposto per il menu).«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR MenuView»
«IF model.structure.appWindow.appArea.menubar != null-»
	<s:include value="fragments/menu.jsp"></s:include>
«ENDIF-»
«ENDDEFINE»


«REM»Genera la componente di markup (HTML) di un TreeView.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR TreeView»
			<div id="«name»">
				<customtag:tree
					name="«getOGNLForWidgetMultiValue(this)»" folder="images" imgOpen="minus.gif"
					imgClosed="plus.gif" imgDot="dot.gif" linkOnTree="true"
					«IF this.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size==1-»
					requestURI="«getStrutsActionConfigName(cp)»!«getHandlerMethodName(this,this.eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).first())».do" showChildNumber="false">
					«ELSE-»
					requestURI="«getStrutsActionConfigName(cp)».do" showChildNumber="false">
					«ENDIF-»
				</customtag:tree>
			</div>
«ENDDEFINE»

«REM»Genera la componente di markup (HTML) di un Calendar.«ENDREM»
«DEFINE createWidgetMarkup(GUIModel model, ContentPanel cp) FOR Calendar»

«ENDDEFINE»
