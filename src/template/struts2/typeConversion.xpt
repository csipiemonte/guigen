«IMPORT guigen»

«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»


«REM»
==========================================================================================================================
STRUTS2 CUSTOM TYPE CONVERTER PROPERTY FILE
===========================================================================================================================
«ENDREM»

«REM»Genera il file di property«ENDREM»
«DEFINE conversionPropertyFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsTypeConvertersPropertiesFile(this, skip_component_dir_creation)»#######################################################################
# SAF2 global conversion goes here
#######################################################################

int=«getTypeConverterJavaPackage(this)».CsiNumericConverter
long=«getTypeConverterJavaPackage(this)».CsiNumericConverter
float=«getTypeConverterJavaPackage(this)».CsiNumericConverter
double=«getTypeConverterJavaPackage(this)».CsiNumericConverter

java.lang.Integer=«getTypeConverterJavaPackage(this)».CsiNumericConverter
java.lang.Long=«getTypeConverterJavaPackage(this)».CsiNumericConverter
java.lang.Float=«getTypeConverterJavaPackage(this)».CsiNumericConverter
java.lang.Double=«getTypeConverterJavaPackage(this)».CsiNumericConverter
«ENDFILE»
«ENDDEFINE»



«REM»
==========================================================================================================================
STRUTS2 CUSTOM TYPE CONVERTER CLASSES
===========================================================================================================================
«ENDREM»

«REM»Genera le classi dei convertitori«ENDREM»
«DEFINE conversionClassesFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND numericConverterClassFile(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera la classe per il convertitore numerico«ENDREM»
«DEFINE numericConverterClassFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getTypeConverterJavaSrcDir(this, skip_component_dir_creation) + "/CsiNumericConverter.java"»package «getTypeConverterJavaPackage(this)»;

import java.text.NumberFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.util.Locale;
import java.util.Map;

import org.apache.struts2.util.StrutsTypeConverter;

import com.opensymphony.xwork2.util.TypeConversionException;


/**
 * Custom Type Converter per i tipi numerici.
 * 
 * @author [GUIGEN]
 */
public class CsiNumericConverter extends StrutsTypeConverter {

	/**
	 * 
	 * @param  context
	 * @param  values
	 * @param  toClass
	 * @return
	 * @see org.apache.struts2.util.StrutsTypeConverter#convertFromString(java.util.Map, java.lang.String[], java.lang.Class)
	 */
	@Override
	public Object convertFromString(Map context, String[] values, Class toClass) {
		if ( values != null && values.length > 0 && values[0] != null && values[0].trim().length() > 0 ) {
			String  s = values[0].trim();
			NumberFormat df = NumberFormat.getNumberInstance(Locale.ITALY);

			if (toClass == Float.TYPE || toClass == Float.class || toClass == Double.TYPE || toClass == Double.class) {
				df.setMinimumFractionDigits(2);
				df.setMaximumFractionDigits(2);
			}

			try {
				ParsePosition parsePosition = new ParsePosition(0);
				Number n = df.parse(s, parsePosition );
				if ( parsePosition.getIndex() != s.length() ) {
					throw new ParseException("impossibile convertire l'intera stringa", parsePosition.getIndex()); 
				}
			
				// df.parse restituisce il tipo massimo quindi
				//  [1] double, Double; float, Float  => Double se specifico i decimali
				//  [2] double, Double; float, Float  => Long se non specifico i decimali
				//  [3] int, Integer; long, Long      => Long
				// bisogna in qualche modo fare un "downcast" in base a toClass

				// Se il tipo target e' un decimale occorre gestire il caso [2]
				if (toClass == Float.TYPE || toClass == Float.class || toClass == Double.TYPE || toClass == Double.class) {
					if (n instanceof Long){
						n= new Double(n.doubleValue());
					}
				}
				if (toClass == Integer.TYPE || toClass == Integer.class) {
					return ((Long) n).intValue();
				} else if (toClass == Float.TYPE || toClass == Float.class) {
					return ((Double) n).floatValue();
				}
				return n;
			} catch (ParseException e) {
				throw new TypeConversionException(e);
			}

		}
		return null;
	}

	/**
	 * 
	 * @param
	 * @param
	 * @return
	 * @see org.apache.struts2.util.StrutsTypeConverter#convertToString(java.util.Map, java.lang.Object)
	 */
	@Override
	public String convertToString(Map context, Object o) {
		NumberFormat df = NumberFormat.getNumberInstance(Locale.ITALY);
		
		if ( o instanceof Integer || o instanceof Long ) {
			return df.format(o);
		} 
		else if ( o instanceof Float || o instanceof Double ) {
			df.setMinimumFractionDigits(2);
			df.setMaximumFractionDigits(2);
			return df.format(o);
		}
		
		return o.toString();
	}

}
«ENDFILE»
«ENDDEFINE»



«REM»
==========================================================================================================================
DISPLAYTAG CUSTOM DECORATORS CLASSES
===========================================================================================================================
«ENDREM»

«REM»Genera le classi dei decoratori«ENDREM»
«DEFINE decoratorsClassesFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND customColumnDecoratorClassFile(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera la classe per il decoratore numerico della displaytag«ENDREM»
«DEFINE customColumnDecoratorClassFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getColumnDecoratorJavaSrcDir(this, skip_component_dir_creation) + "/CsiCustomColumnDecorator.java"»package «getColumnDecoratorJavaPackage(this)»;

import java.text.NumberFormat;
import java.util.Locale;

import org.displaytag.decorator.ColumnDecorator;
import org.displaytag.exception.DecoratorException;


/**
 * Custom Column Decorator per DisplayTag: formatta i numeri.
 * 
 * @author [GUIGEN]
 */
public class CsiCustomColumnDecorator implements ColumnDecorator {

	/**
	 *
	 * @param columnValue
	 * @return
	 * @see org.displaytag.decorator.ColumnDecorator#decorate(java.lang.Object)
	 */
	public String decorate(Object columnValue) throws DecoratorException {
		if ( columnValue != null ) {
			if ( columnValue.getClass()  == Integer.class || columnValue.getClass() == Long.class ) {
				// tipo numerico intero
				return doFormatFromIntegerToString(columnValue);
			} 
			else if ( columnValue.getClass()  == Float.class || columnValue.getClass() == Double.class ) {
				// tipo intero decimale
				return doFormatFromDecimalToString(columnValue);
			}
			// TODO: implementare la logica di decorazione per altri tipi (se necessario)
			
			// per tutti gli altri tipi ritorno la stringa
			return columnValue.toString();
		}	
		return null;
	}

	
	/**
	 * 
	 * @param columnValue
	 * @return
	 */
	private String doFormatFromIntegerToString(Object columnValue) {
		NumberFormat df = NumberFormat.getNumberInstance(Locale.ITALY);
		return df.format(columnValue);
	}
	
	/**
	 * 
	 * @param columnValue
	 * @return
	 */
	private String doFormatFromDecimalToString(Object columnValue) {
		NumberFormat df = NumberFormat.getNumberInstance(Locale.ITALY);
		df.setMinimumFractionDigits(2);
		df.setMaximumFractionDigits(2);
		return df.format(columnValue);
	}	

}
«ENDFILE»
«ENDDEFINE»



«REM»
==========================================================================================================================
DISPLAYTAG CUSTOM COMPARATORS CLASSES
===========================================================================================================================
«ENDREM»

«REM»Genera le classi dei comparatori«ENDREM»
«DEFINE comparatorsClassesFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND dateComparatorClassFile(skip_component_dir_creation) FOR this»
	«EXPAND dateTimeComparatorClassFile(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»Genera la classe per il comparatore di tipi Date«ENDREM»
«DEFINE dateComparatorClassFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getComparatorJavaSrcDir(this, skip_component_dir_creation) + "/CsiDateComparator.java"»package «getComparatorJavaPackage(this)»;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;


/**
 * Comparatore custom per tipi Date (da usare con la DisplayTag)
 *
 * @author [GUIGEN]
 */
public class CsiDateComparator implements Comparator<String>, java.io.Serializable {

	/** Costante per il formato DATE */
	private static final String DATE_FORMAT = "dd/MM/yyyy";


	/*
	 * (non-Javadoc)
	 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
	 */
	public int compare(String o1, String o2) {
		SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);

		try {
			Date d1 = sdf.parse(o1);
			Date d2 = sdf.parse(o2);
			return d1.compareTo(d2);
		} catch (ParseException e) {
			return -1;
		}
	}

}
«ENDFILE»
«ENDDEFINE»


«REM»Genera la classe per il comparatore di tipi Date«ENDREM»
«DEFINE dateTimeComparatorClassFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getComparatorJavaSrcDir(this, skip_component_dir_creation) + "/CsiDateTimeComparator.java"»package «getComparatorJavaPackage(this)»;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;


/**
 * Comparatore custom per tipi DateTime  (da usare con la DisplayTag)
 *
 * @author [GUIGEN]
 */
public class CsiDateTimeComparator implements Comparator<String>, java.io.Serializable {

	/** Costante per il formato DATE */
	private static final String DATE_FORMAT = "dd/MM/yyyy";

	/** Costante per il formato HOUR SHORT */
	private static final String HOUR_SHORT_FORMAT = "hh:mm";

	/** Costante per il formato HOUR EXTENDED */
	private static final String HOUR_EXTENDED_FORMAT = "hh:mm:ss";

	/** Costante per il formato DATETIME SHORT */
	private static final String DATETIME_SHORT_FORMAT = DATE_FORMAT + "-" + HOUR_SHORT_FORMAT;

	/** Costante per il formato DATETIME EXTENDED */
	private static final String DATETIME_EXTENDED_FORMAT = DATE_FORMAT + "-" + HOUR_EXTENDED_FORMAT;


	/*
	 * (non-Javadoc)
	 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
	 */
	public int compare(String o1, String o2) {
		SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);

		try {
			// estrapolo la data dalle stringhe
			String sd1 = o1.substring(0, o1.indexOf("-"));
			String sd2 = o2.substring(0, o2.indexOf("-"));

			// converto le stringhe della date in oggetti di tipo Date
			Date d1 = sdf.parse(sd1);
			Date d2 = sdf.parse(sd2);

			// confronto gli oggetti Date
			if ( d1.compareTo(d2) != 0 ) {
				// le due date sono differenti, ne ritorno il confronto
				return d1.compareTo(d2);
			} else {
				// le due date sono uguali, confronto la parte delle ore
				String sm1 = o1.substring(o1.indexOf("-")+1);
				String sm2 = o2.substring(o2.indexOf("-")+1);
				return sm1.compareTo(sm2);
			}
		} catch (ParseException e) {
			return -1;
		}
	}

}
«ENDFILE»
«ENDDEFINE»
