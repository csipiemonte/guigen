«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE actionImplClasses FOR GUIModel»
«FILE getPresentationJavaSrcDir(true)+"/ICommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Interfaccia comune di tutte le azioni di presentation
 * @author CSI Piemonte
 *
 */
public interface ICommand {
	/**
	 * Esegue l'azione corrispondente
	 * @return il codice del RESULT struts conseguente all'azioen (se l'azione comporta)
	 * una decisione sul result, null altrimenti
	 */
	public String doCommand(BaseAction strutsAction);
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpCommand.java"»
package «getPresentationJavaPackage()»;

/// JUMP_ACTION
public class JumpCommand implements ICommand {
	String name;
	String _currentPageName = null;
	boolean _pushCurrent;
	public JumpCommand(String panelName, String currentPageName,
			boolean pushCurrent) {
		name = panelName;
		_pushCurrent = pushCurrent;
		_currentPageName = currentPageName;
	}
	public String doCommand(BaseAction strutsAction) {
		if (_pushCurrent) {
			//TODO capire se e come impleemntare lo stack delle action
			//_pageStack.add(_currentPageName);
		}
		return "GO_TO_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/OnOffCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class OnOffCommand implements ICommand {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public OnOffCommand(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doCommand(BaseAction strutsAction) {
		System.out.println("on-off action!");
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);		
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				System.out.println("on-off action on " + _targets[i]);
				
				cpWidgetsStatus.put(_targets[i]+"_enabled", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/VisibilityCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class VisibilityCommand implements ICommand {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public VisibilityCommand(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doCommand(BaseAction strutsAction) {
		System.out.println("visibility action!");
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);			
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				System.out.println("visibility action on " + _targets[i]);
				
				cpWidgetsStatus.put(_targets[i]+"_visible", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecCommand.java"»
package «getPresentationJavaPackage()»;

import «getDTOBaseJavaPackage()».*;

////ExecCommand
public abstract class ExecCommand implements ICommand {
	String _esiti[] = null;
	//JFrame _frame = null;
	ICommand _azioni[] = null;
	java.util.Hashtable _resultAzioni = new java.util.Hashtable();

	public ExecCommand(String esiti[], ICommand[] azioni) {
		_esiti = esiti;
		//_frame = frame;
		_azioni = azioni;
		if (_esiti != null) {
			for (int i = 0; i < _esiti.length; i++)
				_resultAzioni.put(_esiti[i], _azioni[i]);
		}
	}

	/**
	 * Esecuzione della logica di business.
	 */
	public String doCommand(BaseAction strutsAction){
		// action --> model
		Object theModel = strutsAction.toModel();
		// esecuzione azione
		ExecResults execResults = doLogic(theModel); 
		String result = execResults.getResultCode();
		Object outModel = execResults.getModel();
		// model --> action
		strutsAction.fromModel(outModel);
		// impostazione degli appData
		storeAppData(execResults, strutsAction);
		// determinazione esito e azione corrispondente
		ICommand resultAction = null;
		for (int i = 0; i<_esiti.length; i++){
			if (_esiti[i].equals(result))
				resultAction = _azioni[i];
		}
		// esecuzione azione conseguente all'esito
		if(resultAction!=null){
			return resultAction.doCommand(strutsAction);
		}
		else
			throw new IllegalStateException("Il result code "+result+" non è tra quelli previsti ("+_esiti+")");
	}
	
	/**
	 * Deve essere implamentata nella sottoclasse in modo da impostare in sessioen o action i valori
	 * degli app data previsti dalla exec action
	 */
	public abstract void storeAppData(ExecResults res, BaseAction strutsAction);
	
	
	// deve essere sovrascritto per eseguire la logica e deve restituire il result_code
	// corretto
	public abstract ExecResults doLogic(Object theModel);
}
«ENDFILE»

«FILE getDTOBaseSrcDir(this)+"/ExecResults.java"»
package «getDTOBaseJavaPackage()»;

import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
 
public class ExecResults {
	private String _resultCode;
	
	private Object _model;
	
	public void setModel(Object model){
		_model=model;
	}
	
	public Object getModel(){
		return _model;
	}
	
	
	public void setResultCode(String code){
		_resultCode = code; 
	}
	
	public String getResultCode(){
		return _resultCode;
	}
	
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/SequenceCommand.java"»
package «getPresentationJavaPackage()»;

/// SEQUENCE_ACTION
public class SequenceCommand implements ICommand {
	ICommand[] _actions;
	public SequenceCommand(ICommand[] actions) {
		_actions = actions;
	}
	
	/**
	 * La sequence action esegue in sequenza tutte le azioni atomiche
	 * incluse come step, mantenendo il più recente risultato non nullo restituito
	 * dagli step (per determinare al termine quale debba essere la pagina successiva
	 */
	public String doCommand(BaseAction strutsAction) {
		String result=null;
		if (_actions != null) {
			for (int i = 0; i < _actions.length; i++) {
				ICommand currAct = _actions[i];
				// TODO standardizzare log
				System.out
						.println("sequenza, azione #" + i + ":" + currAct);
				String currResult = currAct.doCommand(strutsAction);
				if (currResult!=null)
					result=currResult;
			}
			System.out.println("Il risultato finale della sequence è "+result);
		}
		return result;
	}
};
«ENDFILE»
«ENDDEFINE»


«REM»richiamata dal template di definizione della classe Action per un dato 
     content panel
«ENDREM»
«DEFINE actionStructureInit(GUIModel model) FOR ContentPanel»
    /**
     * inizializza la struttura dei command da eseguire per ciascun event handler 
     * di ciascun widget
     */
	public ICommand initCommand(String sourceWidget, String eventType) {
		HashMap<String, HashMap<String, ICommand>> cmdsByWidget = new HashMap<String, HashMap<String, ICommand>>();
		
		«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		// contiene i comandi del widget «((Widget)currEventSource).name» per ogni Ev.H.
		HashMap<String, ICommand> cmds4«((Widget)currEventSource).name»ByEvh = 
		  new HashMap<String, ICommand>();
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«REM»TODO prendere non solo il primo !!!«ENDREM»
		«FOREACH evhs AS currEvh»
		cmds4«((Widget)currEventSource).name»ByEvh.put("«currEvh.eventType.toString()»",initCommand«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»());
		«ENDFOREACH»
		«ENDLET»
		cmdsByWidget.put("«((Widget)currEventSource).name»",cmds4«((Widget)currEventSource).name»ByEvh);	
		«ENDFOREACH»
		return cmdsByWidget.get(sourceWidget).get(eventType);
		«ELSE»
		return new ICommand(){
			public String doCommand(BaseAction strutsAction){return null;}
		};
		«ENDIF»
		«ENDLET»
	}
	
	«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«FOREACH evhs AS currEvh»
		public ICommand initCommand«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»(){
		«EXPAND addActionsCode("actions_"+currEvh.eventType.toString().toLowerCase()+"_"+((Widget)currEvh.eContainer).name, model) FOR currEvh»
		/// TODO la riga successiv aè un pezza...
		ICommand action = act_actions_«currEvh.eventType.toString().toLowerCase()»_«((Widget)currEvh.eContainer).name»_1; 
		return action;
		}
		«ENDFOREACH»
		«ENDLET»	
		«ENDFOREACH»
		«ENDIF»
	«ENDLET»
	
«ENDDEFINE»


«DEFINE actionStructureInit1(GUIModel model) FOR Command»
    /**
     * inizializza la struttura dei command da eseguire per ciascun event handler 
     * di ciascun widget
     */
	public ICommand initCommand() {
		«EXPAND addActionCode("onInit",1, model) FOR this»
		ICommand action = act_onInit_1; 
		return action;
	}
	

	
«ENDDEFINE»

«DEFINE actionStructureInit(GUIModel model) FOR Menubar»
    /**
     * inizializza la struttura dei command da eseguire per ciascun event handler 
     * di ciascun widget
     */
	public ICommand initCommand(String sourceWidget, String eventType) {
		HashMap<String, HashMap<String, ICommand>> cmdsByWidget = new HashMap<String, HashMap<String, ICommand>>();
		
		«LET getAllEventSourceMenuItems() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		// contiene i comandi del menuItem «((MenuItem)currEventSource).name» per ogni Ev.H.
		HashMap<String, ICommand> cmds4«((MenuItem)currEventSource).name»ByEvh = 
		  new HashMap<String, ICommand>();
		«LET ((MenuItem)currEventSource).eventHandler AS evhs»
		«REM»TODO prendere non solo il primo !!!«ENDREM»
		«LET evhs AS currEvh»
		cmds4«((MenuItem)currEventSource).name»ByEvh.put("«currEvh.eventType.toString()»",initCommand«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»());
		«ENDLET»
		«ENDLET»
		cmdsByWidget.put("«((MenuItem)currEventSource).name»",cmds4«((MenuItem)currEventSource).name»ByEvh);	
		«ENDFOREACH»
		return cmdsByWidget.get(sourceWidget).get(eventType);
		«ELSE»
		return new ICommand(){
			public String doCommand(BaseAction strutsAction){return null;}
		};
		«ENDIF»
		«ENDLET»
	}
	
	«LET getAllEventSourceMenuItems() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		«LET ((MenuItem)currEventSource).eventHandler AS evhs»
		«LET evhs AS currEvh»
		public ICommand initCommand«((MenuItem)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»(){
		«EXPAND addActionsCode("actions_"+currEvh.eventType.toString().toLowerCase()+"_"+((MenuItem)currEvh.eContainer).name, model) FOR currEvh»
		/// TODO la riga successiv aè un pezza...
		ICommand action = act_actions_«currEvh.eventType.toString().toLowerCase()»_«((MenuItem)currEvh.eContainer).name»_1; 
		return action;
		}
		«ENDLET»
		«ENDLET»	
		«ENDFOREACH»
		«ENDIF»
	«ENDLET»
	
«ENDDEFINE»


«DEFINE addActionsCode(String actionsVarName, GUIModel model) FOR EventHandler»
    «LET this.command AS currAction»
    «LET 1 AS actionNumber»
    	«EXPAND addActionCode(actionsVarName,actionNumber, model) FOR currAction»
    «ENDLET»
    «ENDLET»
    
	ICommand [] «actionsVarName» = new ICommand[]{
	«LET this.command AS currAct»
		«LET 1 AS actionNumber»
		act_«actionsVarName»_«actionNumber»
		«ENDLET»
	«ENDLET»
	};
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR Command»
// azione non supportata «this»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR JumpCommand»
	/// Jump Command begin
	JumpCommand act_«actionsVarName»_«actionNumber» = new JumpCommand("«this.jumpTo.name»", «IF this.pushCurrentPage»"«findParentContentPanel(this).name»",true«ELSE»null,false«ENDIF»);
	/// Jump Command end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR ShowDialogCommand»
	// ShowDialog Command begin
	ShowDialogCommand act_«actionsVarName»_«actionNumber» = new ShowDialogCommand("«this.dialog.name»");
	// ShowDialog Command end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR JumpBackCommand»
	//JumpBack Command begin
	JumpBackCommand act_«actionsVarName»_«actionNumber» = new JumpBackCommand();
	// JumpBack Command end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR SequenceCommand»
	// SequenceCommand begin
    «FOREACH commands AS currAct»
    «EXPAND addActionCode(actionsVarName+"step",commands.indexOf(currAct), model) FOR currAct»
    «ENDFOREACH»
    
    ICommand [] act_«actionsVarName»_«actionNumber»_steps = new ICommand[]{
    «FOREACH commands AS currAct»
    act_«actionsVarName+"step_"+commands.indexOf(currAct)»«IF currAct!=commands.last()»,«ENDIF»
    «ENDFOREACH»
    };
	SequenceCommand act_«actionsVarName»_«actionNumber» = new SequenceCommand(act_«actionsVarName»_«actionNumber»_steps);
	// SequenceCommand end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR ONOFFCommand»
	«LET findParentContentPanel().name AS containerName»
	// ONOFF Command begin
    //prepara i nomi dei componenti target da abilitare/disabilitare
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
    
	OnOffCommand act_«actionsVarName»_«actionNumber» = new OnOffCommand("«containerName»", act_«actionsVarName»_«actionNumber»_targets,«this.enable»);
	//ONOFF Command end
	«ENDLET»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR VisibilityCommand»
	«LET findParentContentPanel().name AS containerName»
	// VisibilityCommand begin
	//prepara i nomi dei componenti target da mostrare/nascondere
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
	VisibilityCommand act_«actionsVarName»_«actionNumber» = new VisibilityCommand("«containerName»", act_«actionsVarName»_«actionNumber»_targets,«this.show»);
	// Visibility Command end
	«ENDLET»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber, GUIModel model) FOR ExecCommand»
	// ExecCommand begin
    String [] resultNames=new String []{
      «FOREACH this.results AS currRes»
      "«currRes.resultCode»"«IF currRes!=results.last()»,«ENDIF»
      «ENDFOREACH»
    };
    
    ICommand [] actionsForResults = new ICommand[«this.results.size»];
    «FOREACH results AS currRes»
    «EXPAND addActionCode(actionsVarName+"_resAction",results.indexOf(currRes),model) FOR currRes.command»
    actionsForResults[«results.indexOf(currRes)»] = «"act_"+actionsVarName+"_resAction_"+results.indexOf(currRes)»;
    «ENDFOREACH»
    
    
	ExecCommand act_«actionsVarName»_«actionNumber» = new ExecCommand(resultNames, actionsForResults){
		public ExecResults doLogic(Object theModel){
		
			«LET findParentContentPanel(this) AS parentCP»
			«IF parentCP != null»
			return getSpringBackEnd().«this.methodName»((«getModelDTOFQN(parentCP,false, false, model)»)theModel);
			«ELSEIF isInMenuBranch(this)»
			return getSpringBackEnd().«this.methodName»((«getModelDTOFQN(null, true, false, model)»)theModel);
			«ELSE»
			return getSpringBackEnd().«this.methodName»((«getModelDTOFQN(null, false, true, model)»)theModel);
			«ENDIF»
			«ENDLET»
		
		}
		
		public void storeAppData(ExecResults res, BaseAction strutsAction){
			// cast della action al tipo specifico per poter utilizzare direttamente
			// le property
			«LET findParentContentPanel(this) AS parentCP»
			«IF parentCP != null»
			«getStrutsActionClassName(findParentContentPanel(this))» specificAction = 
			  («getStrutsActionClassName(findParentContentPanel(this))») strutsAction;
			«ELSEIF this.eContainer.metaType == ApplicationArea»
			«getStrutsHomeClassName(model)» specificAction = 
			  («getStrutsHomeClassName(model)») strutsAction;
			«ELSE»
			«getStrutsMenuClassName(model)» specificAction = 
			  («getStrutsMenuClassName(model)») strutsAction;
			«ENDIF»
			«ENDLET»
			
			  
		«FOREACH this.postExecData AS currAppData»
			// store del dato «currAppData.name»
			//«toJavaType(currAppData.type,model)» _«getAppDataPropertyName(currAppData)» = 
			//	(«toJavaType(currAppData.type,model)»)res.get«getAppDataPropertyName(currAppData).toFirstUpper()»();
			// il dato «currAppData.name» è salvato in un attributo della action corrente
			//specificAction.set«getAppDataPropertyName(currAppData).toFirstUpper()»(_«getAppDataPropertyName(currAppData)»);
			«IF currAppData.lifetimeExtent==DataLifetimeType::USER_SESSION»
			// il dato «currAppData.name» è salvato in sessione
			strutsAction.getSession().put("«getAppDataKey(currAppData)»",specificAction.get«getAppDataPropertyName(currAppData).toFirstUpper()»());
			«ENDIF»
		«ENDFOREACH»
		}
		
		«REM»
		public ExecResults «this.methodName»(BaseAction strutsAction){
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("act_"+actionsVarName+"_"+actionNumber+"code")»
			// inserire qui la logica applicativa da eseguire
			
			ExecResults results = new ExecResults();
			// impostazione del result code
			results.setResultCode("«this.results.first().resultCode»");
			// impostazione degli app data risultanti
			«FOREACH this.postExecData AS currAppData»
			//// impostazione dell'application Data «currAppData.name» (scope: «currAppData.lifetimeExtent.toString()»)
			results.setAppData("«getAppDataKey(currAppData)»", null);
			«ENDFOREACH»
			return results;
		«ENDPROTECT»
		}
		«ENDREM»
	};
	// Exec Action end
«ENDDEFINE»

«REM»property sempre presenti:
- idNodo per gestire eventuali click su un treeView
«ENDREM»
«DEFINE commonProperties FOR ContentPanel»
	/////////////////////////////////////////
	/// property comuni a tutte le action
	/////////////////////////////////////////
	
	// nodo selezionato in un eventuale tree
	private String _idNodo = "";
	
	public void setIdNodo(String val){
		_idNodo = val;
	}
	
	public String getIdNodo(){
		return _idNodo;
	}
	
«ENDDEFINE»

«REM»
	inserisce tutte le proeprty associate ai vari DataWidget contenuti nel content panel
	a tutti i livelli
«ENDREM»
«DEFINE widgetsProperties(GUIModel model) FOR ContentPanel»
«LET findAllWidgetsInContentPanel(this) AS allW»
«LET (List[Widget])allW AS allWidgets»
«LET allWidgets.typeSelect(DataWidget).select(w|w.databinding==null) AS allDataWidgets»
	«EXPAND widgetProperty(model) FOREACH allDataWidgets»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE widgetProperty (GUIModel model) FOR DataWidget»
	// tipo di data widget non gestito: «this»
«ENDDEFINE»

«DEFINE widgetProperty (GUIModel model) FOR TextField»
	// TextField «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty(GUIModel model) FOR TextArea»
	// TextArea «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty(GUIModel model) FOR Table»
	// Table «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty(GUIModel model) FOR RadioButtons»
	// RadioButtons «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty(GUIModel model) FOR CheckBox»
	// CheckBox «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty(GUIModel model) FOR ComboBox»
	// ComboBox «name»
	«EXPAND property("widg_"+name, model) FOR this.dataType»
«ENDDEFINE»

«DEFINE property(String name, GUIModel model) FOR Type»
	private «toJavaType(this, model)» _«name»;
	
	public void set«name.toFirstUpper()»(«toJavaType(this, model)» value){
		_«name» = value;
	}
	
	public «toJavaType(this, model)» get«name.toFirstUpper()»(){
		return _«name»;
	}
«ENDDEFINE»

«DEFINE storedAppDataProperties(GUIModel model) FOR ContentPanel»
«LET findAllActionScopedAppDataInContentPanel(this) AS allAD»
«LET (List[ApplicationData])allAD AS allAppData»
	«EXPAND appDataProperty(model) FOREACH allAppData»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«REM»serve per la on-init action: non usare altrove«ENDREM»
«DEFINE storedAppDataProperties(GUIModel model) FOR Command»
«LET findAllActionScopedAppData(this) AS allAD»
«LET (List[ApplicationData])allAD AS allAppData»
	«EXPAND appDataProperty(model) FOREACH allAppData»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE storedAppDataProperties(GUIModel model) FOR Menubar»
«LET findAllActionScopedAppDataInMenubar(this) AS allAD»
«LET (List[ApplicationData])allAD AS allAppData»
	«EXPAND appDataProperty(model) FOREACH allAppData»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE springBEProperties FOR GUIModel»
	private «getSpringBEFQN()» _backEnd = null;
	
	public void setSpringBackEnd(«getSpringBEFQN()» be){
		_backEnd = be;
	}
	
	public «getSpringBEFQN()» getSpringBackEnd(){
		return _backEnd;
	}
«ENDDEFINE»

«DEFINE appDataProperty(GUIModel model) FOR ApplicationData»
«IF this.lifetimeExtent==DataLifetimeType::USER_ACTION-»
«EXPAND appDataPropertyActionScoped(model) FOR this-»
«ELSE-»
«EXPAND appDataPropertySessionScoped(model) FOR this-»
«ENDIF-»
«ENDDEFINE»

«DEFINE appDataPropertyActionScoped(GUIModel model) FOR ApplicationData»
	private «toJavaType(this.type, model)» _«getAppDataPropertyName(this)» = «defaultInitVal(this.type,model)»;
	
	public void set«getAppDataPropertyName(this).toFirstUpper()»(«toJavaType(this.type, model)» value){
		_«getAppDataPropertyName(this)» = value;
	}
	
	public «toJavaType(this.type, model)» get«getAppDataPropertyName(this).toFirstUpper()»(){
		return _«getAppDataPropertyName(this)»;
	}
«ENDDEFINE»

«DEFINE appDataPropertySessionScoped(GUIModel model) FOR ApplicationData»
	
	public void set«getAppDataPropertyName(this).toFirstUpper()»(«toJavaType(this.type, model)» value){
		getSession().put("«getAppDataKey(this)»", value);
	}
	
	public «toJavaType(this.type, model)» get«getAppDataPropertyName(this).toFirstUpper()»(){
		return («toJavaType(this.type, model)»)(getSession().get("«getAppDataKey(this)»"));
	}
«ENDDEFINE»