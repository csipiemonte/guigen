«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE actionImplClasses FOR GUIModel»
«FILE getPresentationJavaSrcDir(true)+"/IAction.java"»
package «getPresentationJavaPackage()»;

/**
 * Interfaccia comune di tutte le azioni di presentation
 * @author CSI Piemonte
 *
 */
public interface IAction {
	/**
	 * Esegue l'azione corrispondente
	 * @return il codice del RESULT struts conseguente all'azioen (se l'azione comporta)
	 * una decisione sul result, null altrimenti
	 */
	public String doAction(BaseAction strutsAction);
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpAction.java"»
package «getPresentationJavaPackage()»;

/// JUMP_ACTION
public class JumpAction implements IAction {
	String name;
	String _currentPageName = null;
	boolean _pushCurrent;
	public JumpAction(String panelName, String currentPageName,
			boolean pushCurrent) {
		name = panelName;
		_pushCurrent = pushCurrent;
		_currentPageName = currentPageName;
	}
	public String doAction(BaseAction strutsAction) {
		if (_pushCurrent) {
			//TODO capire se e come impleemntare lo stack delle action
			//_pageStack.add(_currentPageName);
		}
		return "GO_TO_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/OnOffAction.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class OnOffAction implements IAction {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public OnOffAction(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doAction(BaseAction strutsAction) {
		System.out.println("on-off action!");
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);		
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				System.out.println("on-off action on " + _targets[i]);
				
				cpWidgetsStatus.put(_targets[i]+"_enabled", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/VisibilityAction.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class VisibilityAction implements IAction {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public VisibilityAction(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doAction(BaseAction strutsAction) {
		System.out.println("visibility action!");
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);			
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				System.out.println("visibility action on " + _targets[i]);
				
				cpWidgetsStatus.put(_targets[i]+"_visible", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecAction.java"»
package «getPresentationJavaPackage()»;

////ExecAction
public abstract class ExecAction implements IAction {
	String _esiti[] = null;
	//JFrame _frame = null;
	IAction _azioni[] = null;
	java.util.Hashtable _resultAzioni = new java.util.Hashtable();

	//public ExecAction(JFrame frame, String esiti[], IAction[] azioni) {
	public ExecAction(String esiti[], IAction[] azioni) {
		_esiti = esiti;
		//_frame = frame;
		_azioni = azioni;
		if (_esiti != null) {
			for (int i = 0; i < _esiti.length; i++)
				_resultAzioni.put(_esiti[i], _azioni[i]);
		}
	}

	public String doAction(BaseAction strutsAction){
		// esecuzione azione
		ExecResults execResults = doLogic(strutsAction); 
		String result = execResults.getResultCode();
		// impostazione degli appData
		storeAppData(execResults, strutsAction);
		// determinazione esito e azione corrispondente
		IAction resultAction = null;
		for (int i = 0; i<_esiti.length; i++){
			if (_esiti[i].equals(result))
				resultAction = _azioni[i];
		}
		// esecuzione azione conseguente all'esito
		if(resultAction!=null){
			return resultAction.doAction(strutsAction);
		}
		else
			throw new IllegalStateException("Il result code "+result+" non è tra quelli previsti ("+_esiti+")");
	}
	
	/**
	 * Deve essere implamentata nella sottoclasse in modo da impostare in sessioen o action i valori
	 * degli app data previsti dalla exec action
	 */
	public abstract void storeAppData(ExecResults res, BaseAction strutsAction);
	
	
	// deve essere sovrascritto per eseguire la logica e deve restituire il result_code
	// corretto
	public abstract ExecResults doLogic(BaseAction strutsAction);
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecResults.java"»
package «getPresentationJavaPackage()»;

import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
 
public class ExecResults {
	private String _resultCode;
	private Map _appData = new HashMap();
	
	public void setResultCode(String code){
		_resultCode = code; 
	}
	
	public String getResultCode(){
		return _resultCode;
	}
	
	public void setAppData(String name, Object data){
		_appData.put(name, data);
	}
	
	public Object getAppData(String name){
		return _appData.get(name);
	}
	
	public Iterator<String> getAppDataNames(){
		return (Iterator<String>) _appData.keySet().iterator();
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/SequenceAction.java"»
package «getPresentationJavaPackage()»;

/// SEQUENCE_ACTION
public class SequenceAction implements IAction {
	IAction[] _actions;
	public SequenceAction(IAction[] actions) {
		_actions = actions;
	}
	
	/**
	 * La sequence action esegue in sequenza tutte le azioni atomiche
	 * incluse come step, mantenendo il più recente risultato non nullo restituito
	 * dagli step (per determinare al termine quale debba essere la pagina successiva
	 */
	public String doAction(BaseAction strutsAction) {
		String result=null;
		if (_actions != null) {
			for (int i = 0; i < _actions.length; i++) {
				IAction currAct = _actions[i];
				// TODO standardizzare log
				System.out
						.println("sequenza, azione #" + i + ":" + currAct);
				String currResult = currAct.doAction(strutsAction);
				if (currResult!=null)
					result=currResult;
			}
			System.out.println("Il risultato finale della sequence è "+result);
		}
		return result;
	}
};
«ENDFILE»
«ENDDEFINE»


«REM»richiamata dal template di definizione della classe Action per un dato 
     content panel
«ENDREM»
«DEFINE actionStructureInit FOR ContentPanel»
    /**
     * inizializza la struttura dei command da eseguire per ciascun event handler 
     * di ciascun widget
     */
	public IAction initAction(String sourceWidget, String eventType) {
		HashMap<String, HashMap<String, IAction>> cmdsByWidget = new HashMap<String, HashMap<String, IAction>>();
		
		«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		// contiene i comandi del widget «((Widget)currEventSource).name» per ogni Ev.H.
		HashMap<String, IAction> cmds4«((Widget)currEventSource).name»ByEvh = 
		  new HashMap<String, IAction>();
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«REM»TODO prendere non solo il primo !!!«ENDREM»
		«FOREACH evhs AS currEvh»
		cmds4«((Widget)currEventSource).name»ByEvh.put("«currEvh.eventType.toString()»",initAction«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»());
		«ENDFOREACH»
		«ENDLET»
		cmdsByWidget.put("«((Widget)currEventSource).name»",cmds4«((Widget)currEventSource).name»ByEvh);	
		«ENDFOREACH»
		return cmdsByWidget.get(sourceWidget).get(eventType);
		«ELSE»
		return new IAction(){
			public String doAction(BaseAction strutsAction){return null;}
		};
		«ENDIF»
		«ENDLET»
	}
	
	«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«FOREACH evhs AS currEvh»
		public IAction initAction«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»(){
		«EXPAND addActionsCode("actions_"+currEvh.eventType.toString().toLowerCase()+"_"+((Widget)currEvh.eContainer).name) FOR currEvh»
		/// TODO la riga successiv aè un pezza...
		IAction action = act_actions_«currEvh.eventType.toString().toLowerCase()»_«((Widget)currEvh.eContainer).name»_1; 
		return action;
		}
		«ENDFOREACH»
		«ENDLET»	
		«ENDFOREACH»
		«ENDIF»
	«ENDLET»
	
«ENDDEFINE»



«DEFINE addActionsCode(String actionsVarName) FOR EventHandler»
    «LET this.action AS currAction»
    «LET 1 AS actionNumber»
    	«EXPAND addActionCode(actionsVarName,actionNumber) FOR currAction»
    «ENDLET»
    «ENDLET»
    
	IAction [] «actionsVarName» = new IAction[]{
	«LET this.action AS currAct»
		«LET 1 AS actionNumber»
		act_«actionsVarName»_«actionNumber»
		«ENDLET»
	«ENDLET»
	};
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR Action»
// azione non supportata «this»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR JumpAction»
	/// Jump Action begin
	JumpAction act_«actionsVarName»_«actionNumber» = new JumpAction("«this.jumpTo.name»", «IF this.pushCurrentPage»"«findParentContentPanel(this).name»",true«ELSE»null,false«ENDIF»);
	/// Jump Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ShowDialogAction»
	// ShowDialog Action begin
	ShowDialogAction act_«actionsVarName»_«actionNumber» = new ShowDialogAction("«this.dialog.name»");
	// ShowDialog Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR JumpBackAction»
	//JumpBack Action begin
	JumpBackAction act_«actionsVarName»_«actionNumber» = new JumpBackAction();
	// JumpBack Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR SequenceAction»
	// SequenceAction begin
    «FOREACH actions AS currAct»
    «EXPAND addActionCode(actionsVarName+"step",actions.indexOf(currAct)) FOR currAct»
    «ENDFOREACH»
    
    IAction [] act_«actionsVarName»_«actionNumber»_steps = new IAction[]{
    «FOREACH actions AS currAct»
    act_«actionsVarName+"step_"+actions.indexOf(currAct)»«IF currAct!=actions.last()»,«ENDIF»
    «ENDFOREACH»
    };
	SequenceAction act_«actionsVarName»_«actionNumber» = new SequenceAction(act_«actionsVarName»_«actionNumber»_steps);
	// SequenceAction end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ONOFFAction»
	«LET findParentContentPanel().name AS containerName»
	// ONOFF Action begin
    //prepara i nomi dei componenti target da abilitare/disabilitare
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
    
	OnOffAction act_«actionsVarName»_«actionNumber» = new OnOffAction("«containerName»", act_«actionsVarName»_«actionNumber»_targets,«this.enable»);
	//ONOFF Action end
	«ENDLET»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR VisibilityAction»
	«LET findParentContentPanel().name AS containerName»
	// VisibilityAction begin
	//prepara i nomi dei componenti target da mostrare/nascondere
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
	VisibilityAction act_«actionsVarName»_«actionNumber» = new VisibilityAction("«containerName»", act_«actionsVarName»_«actionNumber»_targets,«this.show»);
	// Visibility Action end
	«ENDLET»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ExecAction»
	// ExecAction begin
    String [] resultNames=new String []{
      «FOREACH this.results AS currRes»
      "«currRes.resultCode»"«IF currRes!=results.last()»,«ENDIF»
      «ENDFOREACH»
    };
    
    IAction [] actionsForResults = new IAction[«this.results.size»];
    «FOREACH results AS currRes»
    «EXPAND addActionCode(actionsVarName+"_resAction",results.indexOf(currRes)) FOR currRes.action»
    actionsForResults[«results.indexOf(currRes)»] = «"act_"+actionsVarName+"_resAction_"+results.indexOf(currRes)»;
    «ENDFOREACH»
    
    
	ExecAction act_«actionsVarName»_«actionNumber» = new ExecAction(resultNames, actionsForResults){
		public ExecResults doLogic(BaseAction strutsAction){
		
			return «this.methodName»(strutsAction);
		
		}
		
		public void storeAppData(ExecResults res, BaseAction strutsAction){
			// cast della action al tipo specifico per poter utilizzare direttamente
			// le property
			«getStrutsActionClassName(findParentContentPanel(this))» specificAction = 
			  («getStrutsActionClassName(findParentContentPanel(this))») strutsAction;
			  
		«FOREACH this.postExecData AS currAppData»
			// store del dato «currAppData.name»
			Object _«getAppDataPropertyName(currAppData)» = res.getAppData("«getAppDataPropertyName(currAppData)»");
			«IF currAppData.lifetimeExtent==DataLifetimeType::USER_ACTION»
			// il dato «currAppData.name» è salvato in un attributo della action corrente
			specificAction.set«getAppDataPropertyName(currAppData).toFirstUpper()»(_«getAppDataPropertyName(currAppData)»);
			«ELSEIF currAppData.lifetimeExtent==DataLifetimeType::USER_SESSION»
			// il dato «currAppData.name» è salvato in sessione
			strutsAction.getSession().put("«getAppDataKey(currAppData)»",_«getAppDataPropertyName(currAppData)»);
			«ENDIF»
		«ENDFOREACH»
		}
		public ExecResults «this.methodName»(BaseAction strutsAction){
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("act_"+actionsVarName+"_"+actionNumber+"code")»
			// inserire qui la logica applicativa da eseguire
			
			ExecResults results = new ExecResults();
			// impostazione del result code
			results.setResultCode("«this.results.first().resultCode»");
			// impostazione degli app data risultanti
			«FOREACH this.postExecData AS currAppData»
			//// impostazione dell'application Data «currAppData.name» (scope: «currAppData.lifetimeExtent.toString()»)
			results.setAppData("«currAppData.name»", null);
			«ENDFOREACH»
			return results;
		«ENDPROTECT»
		}
	};
	// Exec Action end
«ENDDEFINE»

«REM»aggiunge la definizione delle property corrispondenti ai button di un pannello,
     necessarie per capire quale sia la fonte dell'evento di tipo clicked
«ENDREM»
«DEFINE buttonFlagsInAction FOR ContentPanel»
	«LET getAllEventSourceWidgets() AS allEventSources»
	«LET allEventSources.select(w|((Widget)w).eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size>0) AS allClickSources»
	«FOREACH allClickSources AS currClickSource»
	private boolean _widg_«((Widget)currClickSource).name»;
	
	public void setWidg_«((Widget)currClickSource).name»(boolean value){
		_widg_«((Widget)currClickSource).name» = true;
		System.out.println("_widg_«((Widget)currClickSource).name»->"+value);
		System.out.println("forzo a true...");
	}
	«ENDFOREACH»
	«ENDLET»
	«ENDLET»
«ENDDEFINE»

«REM»
	inserisce tutte le proeprty associate ai vari DataWidget contenuti nel content panel
	a tutti i livelli
«ENDREM»
«DEFINE widgetsProperties FOR ContentPanel»
«LET findAllWidgetsInContentPanel(this) AS allW»
«LET (List[Widget])allW AS allWidgets»
«LET allWidgets.typeSelect(DataWidget) AS allDataWidgets»
	«EXPAND widgetProperty FOREACH allDataWidgets»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE widgetProperty FOR DataWidget»
	// tipo di data widget non gestito: «this»
«ENDDEFINE»

«DEFINE widgetProperty FOR TextField»
	// TextField «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR TextArea»
	// TextArea «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR Table»
	// Table «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR RadioButtons»
	// RadioButtons «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR CheckBox»
	// CheckBox «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR ComboBox»
	// ComboBox «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE property(String name, String modifier) FOR WidgetDataType»
	private «mapWidgetDataType2JavaType(this, modifier)» _«name»;
	
	public void set«name.toFirstUpper()»(«mapWidgetDataType2JavaType(this, modifier)» value){
		_«name» = value;
	}
	
	public «mapWidgetDataType2JavaType(this, modifier)» get«name.toFirstUpper()»(){
		return _«name»;
	}
«ENDDEFINE»

«DEFINE storedAppDataProperties FOR ContentPanel»
«LET findAllActionScopedAppDataInContentPanel(this) AS allAD»
«LET (List[ApplicationData])allAD AS allAppData»
	«EXPAND appDataProperty FOREACH allAppData»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE appDataProperty FOR ApplicationData»
	private Object _«getAppDataPropertyName(this)»;
	
	public void set«getAppDataPropertyName(this).toFirstUpper()»(Object value){
		_«getAppDataPropertyName(this)» = value;
	}
	
	public Object get«getAppDataPropertyName(this).toFirstUpper()»(){
		return _«getAppDataPropertyName(this)»;
	}
«ENDDEFINE»

