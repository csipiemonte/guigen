«IMPORT guigen»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE actionImplClasses FOR GUIModel»
«FILE getPresentationJavaSrcDir(true)+"/IAction.java"»
package it.csi.piol.piolfe.presentation.piolfe.action;

/**
 * Interfaccia comune di tutte le azioni di presentation
 * @author CSI Piemonte
 *
 */
public interface IAction {
	/**
	 * Esegue l'azione corrispondente
	 * @return il codice del RESULT struts conseguente all'azioen (se l'azione comporta)
	 * una decisione sul result, null altrimenti
	 */
	public String doAction(Object strutsAction);
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpAction.java"»
package it.csi.piol.piolfe.presentation.piolfe.action;

/// JUMP_ACTION
public class JumpAction implements IAction {
	String name;
	String _currentPageName = null;
	boolean _pushCurrent;
	public JumpAction(String panelName, String currentPageName,
			boolean pushCurrent) {
		name = panelName;
		_pushCurrent = pushCurrent;
		_currentPageName = currentPageName;
	}
	public String doAction(Object strutsAction) {
		if (_pushCurrent) {
			//TODO capire se e come impleemntare lo stack delle action
			//_pageStack.add(_currentPageName);
		}
		return "GO_TO_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecAction.java"»
package it.csi.piol.piolfe.presentation.piolfe.action;

////ExecAction
public abstract class ExecAction implements IAction {
	String _esiti[] = null;
	//JFrame _frame = null;
	IAction _azioni[] = null;
	java.util.Hashtable _resultAzioni = new java.util.Hashtable();

	//public ExecAction(JFrame frame, String esiti[], IAction[] azioni) {
	public ExecAction(String esiti[], IAction[] azioni) {
		_esiti = esiti;
		//_frame = frame;
		_azioni = azioni;
		if (_esiti != null) {
			for (int i = 0; i < _esiti.length; i++)
				_resultAzioni.put(_esiti[i], _azioni[i]);
		}
	}

	public String doAction(Object strutsAction){
		// esecuzione azione
		String result = doLogic(strutsAction);
		// determinazione esito e azione corrispondente
		IAction resultAction = null;
		for (int i = 0; i<_esiti.length; i++){
			if (_esiti[i].equals(result))
				resultAction = _azioni[i];
		}
		// esecuzione azione conseguente all'esito
		if(resultAction!=null){
			return resultAction.doAction(strutsAction);
		}
		else
			throw new IllegalStateException("Il result code "+result+" non è tra quelli previsti ("+_esiti+")");
	}
	
	// deve essere sovrascritto per eseguire la logica e deve restituire il result_code
	// corretto
	public abstract String doLogic(Object strutsAction);
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/SequenceAction.java"»
package it.csi.piol.piolfe.presentation.piolfe.action;

/// SEQUENCE_ACTION
public class SequenceAction implements IAction {
	IAction[] _actions;
	public SequenceAction(IAction[] actions) {
		_actions = actions;
	}
	
	/**
	 * La sequence action esegue in sequenza tutte le azioni atomiche
	 * incluse come step, mantenendo il più recente risultato non nullo restituito
	 * dagli step (per determinare al termine quale debba essere la pagina successiva
	 */
	public String doAction(Object strutsAction) {
		String result=null;
		if (_actions != null) {
			for (int i = 0; i < _actions.length; i++) {
				IAction currAct = _actions[i];
				// TODO standardizzare log
				System.out
						.println("sequenza, azione #" + i + ":" + currAct);
				String currResult = currAct.doAction(strutsAction);
				if (currResult!=null)
					result=currResult;
			}
			System.out.println("Il risultato finale della sequence è "+result);
		}
		return result;
	}
};
«ENDFILE»
«ENDDEFINE»


«REM»richiamata dal template di definizione della classe Action per un dato 
     content panel
«ENDREM»
«DEFINE actionStructureInit FOR ContentPanel»
    /**
     * inizializza la struttura dei command da eseguire per ciascun event handler 
     * di ciascun widget
     */
	public IAction initAction(String sourceWidget, String eventType) {
		HashMap<String, HashMap<String, IAction>> cmdsByWidget = new HashMap<String, HashMap<String, IAction>>();
		
		«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		// contiene i comandi del widget «((Widget)currEventSource).name» per ogni Ev.H.
		HashMap<String, IAction> cmds4«((Widget)currEventSource).name»ByEvh = 
		  new HashMap<String, IAction>();
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«REM»TODO prendere non solo il primo !!!«ENDREM»
		«FOREACH evhs AS currEvh»
		cmds4«((Widget)currEventSource).name»ByEvh.put("«currEvh.eventType.toString()»",initAction«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»());
		«ENDFOREACH»
		«ENDLET»
		cmdsByWidget.put("«((Widget)currEventSource).name»",cmds4«((Widget)currEventSource).name»ByEvh);	
		«ENDFOREACH»
		return cmdsByWidget.get(sourceWidget).get(eventType);
		«ELSE»
		return new IAction(){
			public String doAction(Object strutsAction){return null;}
		};
		«ENDIF»
		«ENDLET»
	}
	
	«LET getAllEventSourceWidgets() AS eventSources»
		«IF eventSources.size>0»
		«FOREACH eventSources AS currEventSource»
		«LET ((Widget)currEventSource).eventHandlers AS evhs»
		«FOREACH evhs AS currEvh»
		public IAction initAction«((Widget)currEventSource).name.toFirstUpper()»_«currEvh.eventType.toString().toFirstUpper()»(){
		«EXPAND addActionsCode("actions_"+currEvh.eventType.toString().toLowerCase()+"_"+((Widget)currEvh.eContainer).name) FOR currEvh»
		/// TODO la riga successiv aè un pezza...
		IAction action = act_actions_«currEvh.eventType.toString().toLowerCase()»_«((Widget)currEvh.eContainer).name»_1; 
		return action;
		}
		«ENDFOREACH»
		«ENDLET»	
		«ENDFOREACH»
		«ENDIF»
	«ENDLET»
	
«ENDDEFINE»



«DEFINE addActionsCode(String actionsVarName) FOR EventHandler»
    «LET this.action AS currAction»
    «LET 1 AS actionNumber»
    	«EXPAND addActionCode(actionsVarName,actionNumber) FOR currAction»
    «ENDLET»
    «ENDLET»
    
	IAction [] «actionsVarName» = new IAction[]{
	«LET this.action AS currAct»
		«LET 1 AS actionNumber»
		act_«actionsVarName»_«actionNumber»
		«ENDLET»
	«ENDLET»
	};
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR Action»
// azione non supportata «this»
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR JumpAction»
	/// Jump Action begin
	JumpAction act_«actionsVarName»_«actionNumber» = new JumpAction("«this.jumpTo.name»", «IF this.pushCurrentPage»"«findParentContentPanel(this).name»",true«ELSE»null,false«ENDIF»);
	/// Jump Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ShowDialogAction»
	// ShowDialog Action begin
	ShowDialogAction act_«actionsVarName»_«actionNumber» = new ShowDialogAction("«this.dialog.name»");
	// ShowDialog Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR JumpBackAction»
	//JumpBack Action begin
	JumpBackAction act_«actionsVarName»_«actionNumber» = new JumpBackAction();
	// JumpBack Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR SequenceAction»
	// SequenceAction begin
    «FOREACH actions AS currAct»
    «EXPAND addActionCode(actionsVarName+"step",actions.indexOf(currAct)) FOR currAct»
    «ENDFOREACH»
    
    IAction [] act_«actionsVarName»_«actionNumber»_steps = new IAction[]{
    «FOREACH actions AS currAct»
    act_«actionsVarName+"step_"+actions.indexOf(currAct)»«IF currAct!=actions.last()»,«ENDIF»
    «ENDFOREACH»
    };
	SequenceAction act_«actionsVarName»_«actionNumber» = new SequenceAction(act_«actionsVarName»_«actionNumber»_steps);
	// SequenceAction end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ONOFFAction»
	// ONOFF Action begin
    //prepara i nomi dei componenti target da abilitare/disabilitare
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
    
	OnOffAction act_«actionsVarName»_«actionNumber» = new OnOffAction(act_«actionsVarName»_«actionNumber»_targets,«this.enable»);
	//ONOFF Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR VisibilityAction»
	// VisibilityAction begin
	//prepara i nomi dei componenti target da mostrare/nascondere
    String[] act_«actionsVarName»_«actionNumber»_targets = new String[]{
    «FOREACH this.targetWidgets AS currWidg»
    "«currWidg.name»"«IF currWidg!=targetWidgets.last()»,«ENDIF»
    «ENDFOREACH»
    };
	VisibilityAction act_«actionsVarName»_«actionNumber» = new VisibilityAction(act_«actionsVarName»_«actionNumber»_targets,«this.show»);
	// Visibility Action end
«ENDDEFINE»

«DEFINE addActionCode(String actionsVarName, int actionNumber) FOR ExecAction»
	// ExecAction begin
    String [] resultNames=new String []{
      «FOREACH this.results AS currRes»
      "«currRes.resultCode»"«IF currRes!=results.last()»,«ENDIF»
      «ENDFOREACH»
    };
    
    IAction [] actionsForResults = new IAction[«this.results.size»];
    «FOREACH results AS currRes»
    «EXPAND addActionCode(actionsVarName+"_resAction",results.indexOf(currRes)) FOR currRes.action»
    actionsForResults[«results.indexOf(currRes)»] = «"act_"+actionsVarName+"_resAction_"+results.indexOf(currRes)»;
    «ENDFOREACH»
    
    
	ExecAction act_«actionsVarName»_«actionNumber» = new ExecAction(resultNames, actionsForResults){
		public String doLogic(Object strutsAction){
		«REM»«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("act_"+actionsVarName+"_"+actionNumber+"code")»«ENDREM»
			// inserire qui la logica applicativa da eseguire
			return "«this.results.first().resultCode»";
		«REM»«ENDPROTECT»«ENDREM»
		}
	};
	// Exec Action end
«ENDDEFINE»

«REM»aggiunge la definizione delle property corrispondenti ai button di un pannello,
     necessarie per capire quale sia la fonte dell'evento di tipo clicked
«ENDREM»
«DEFINE buttonFlagsInAction FOR ContentPanel»
	«LET getAllEventSourceWidgets() AS allEventSources»
	«LET allEventSources.select(w|((Widget)w).eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size>0) AS allClickSources»
	«FOREACH allClickSources AS currClickSource»
	private boolean _widg_«((Widget)currClickSource).name»;
	
	public void setWidg_«((Widget)currClickSource).name»(boolean value){
		_widg_«((Widget)currClickSource).name» = true;
		System.out.println("_widg_«((Widget)currClickSource).name»->"+value);
		System.out.println("forzo a true...");
	}
	«ENDFOREACH»
	«ENDLET»
	«ENDLET»
«ENDDEFINE»

«REM»
	inserisce tutte le proeprty associate ai vari DataWidget contenuti nel content panel
	a tutti i livelli
«ENDREM»
«DEFINE widgetsProperties FOR ContentPanel»
«LET findAllWidgetsInContentPanel(this) AS allW»
«LET (List[Widget])allW AS allWidgets»
«LET allWidgets.typeSelect(DataWidget) AS allDataWidgets»
	«EXPAND widgetProperty FOREACH allDataWidgets»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE widgetProperty FOR DataWidget»
	// tipo di data widget non gestito: «this»
«ENDDEFINE»

«DEFINE widgetProperty FOR TextField»
	// TextField «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR TextArea»
	// TextArea «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR Table»
	// Table «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR RadioButtons»
	// RadioButtons «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR CheckBox»
	// CheckBox «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE widgetProperty FOR ComboBox»
	// ComboBox «name»
	«EXPAND property("widg_"+name, this.dataTypeModifier) FOR this.dataType»
«ENDDEFINE»

«DEFINE property(String name, String modifier) FOR WidgetDataType»
	private «mapWidgetDataType2JavaType(this, modifier)» _«name»;
	
	public void set«name.toFirstUpper()»(«mapWidgetDataType2JavaType(this, modifier)» value){
		_«name» = value;
	}
	
	public «mapWidgetDataType2JavaType(this, modifier)» get«name.toFirstUpper()»(){
		return _«name»;
	}
«ENDDEFINE»