«IMPORT guigen»
«IMPORT ecore»
«EXTENSION template::GenericExtensions »
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE actionImplClasses FOR GUIModel»
«FILE getPresentationJavaSrcDir(true)+"/ICommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Interfaccia comune di tutte le azioni di presentation
 *
 * @author CSI Piemonte
 */
public interface ICommand extends java.io.Serializable {
	/**
	 * Esegue l'azione corrispondente
	 * @return il codice del RESULT struts conseguente all'azione (se l'azione comporta)
	 * una decisione sul result, null altrimenti
	 */
	public String doCommand(BaseAction strutsAction) throws Exception;
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/NOPCommand.java"»
package «getPresentationJavaPackage()»;

/// NO OPERATION
public class NOPCommand implements ICommand {
	
	public NOPCommand() {
		
	}
	public String doCommand(BaseAction strutsAction) throws Exception{
		return null;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpCommand.java"»
package «getPresentationJavaPackage()»;

/// JUMP_ACTION
public class JumpCommand implements ICommand {
	String name;
	String _currentPageName = null;
	boolean _pushCurrent;
	public JumpCommand(String panelName, String currentPageName,
			boolean pushCurrent) {
		name = panelName;
		_pushCurrent = pushCurrent;
		_currentPageName = currentPageName;
	}
	public String doCommand(BaseAction strutsAction) throws Exception{
		if (_pushCurrent) {
			//TODO capire se e come impleemntare lo stack delle action
			//_pageStack.add(_currentPageName);
		}
		// clear page scoped appdata
		strutsAction.clearPageScopedAppData();
		return "GO_TO_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/RefreshViewCommand.java"»
package «getPresentationJavaPackage()»;

/// REFRESHVIEW_ACTION
public class RefreshViewCommand implements ICommand {
	String _currentPanelName = null;
	String [] _targetPanels=null;
	String [] _targetWidgets=null;
	
	public RefreshViewCommand(String currentPanelName, String [] targetPanelNames,
			String  [] targetWidgetNames) {
		_currentPanelName = currentPanelName;
		_targetPanels = targetPanelNames;
		_targetWidgets = targetWidgetNames;
	}
	
	
	public String doCommand(BaseAction strutsAction) throws Exception {
		return null;
	}
};
«ENDFILE»


«FILE getPresentationJavaSrcDir(true)+"/JumpExtCommand.java"»
package «getPresentationJavaPackage()»;

/// JUMP_ACTION
public class JumpExtCommand implements ICommand {
	String locationCode;
	public JumpExtCommand(String locationCode) {
		this.locationCode = locationCode;
	}
	public String doCommand(BaseAction strutsAction) throws Exception{
		// clear page scoped appdata
		strutsAction.clearPageScopedAppData();
		return "GO_TO_"+locationCode;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ActivateMultiPanelItemCommand.java"»
package «getPresentationJavaPackage()»;

/// ActivateMultiPanelItemCommand
public class ActivateMultiPanelItemCommand implements ICommand {
	String contentPanelName;
	String containerName; 
	String itemName;
	
	/**
	 * @param contentPanelName il nome del content panel
	 * @param containerName il nome del multi-panel contenitore
	 * @param itemName il nome dell'item da attivare (se null => non mostrare
	 *  nessun pannello
	 */
	public ActivateMultiPanelItemCommand(String contentPanelName, String containerName, String itemName) {
		this.contentPanelName = contentPanelName;
		this.containerName = containerName;
		this.itemName = itemName;
	}
	public String doCommand(BaseAction strutsAction) throws Exception{
		if (itemName!=null){
			strutsAction.getSession().put(
				contentPanelName+"_"+containerName+"_selectedMultiPanel", 
				contentPanelName+"_"+containerName+"_"+itemName);
		}
		else{
			strutsAction.getSession().remove(contentPanelName+"_"+containerName+"_selectedMultiPanel");
		}
		return null;
	}
};
«ENDFILE»


«FILE getPresentationJavaSrcDir(true)+"/ScreenStateCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class ScreenStateCommand implements ICommand {
	String _containerName = null;
	String _stateName = null;
	String[] _widgetsOn = null;
	String[] _widgetsOff = null;
	String[] _widgetsShown = null;
	String[] _widgetsHidden = null;

	public ScreenStateCommand(
			String containerName,
			String stateName, 
			String widgetsOn[],
			String widgetsOff[],
			String widgetsShown[],
			String widgetsHidden[]
			) {
		_containerName = containerName;
		_stateName = stateName;
		_widgetsOn = widgetsOn;
		_widgetsOff = widgetsOff;
		_widgetsShown = widgetsShown;
		_widgetsHidden = widgetsHidden;
	}

	public String doCommand(BaseAction strutsAction) throws Exception {
		OnOffCommand turnOn = new OnOffCommand(_containerName, _widgetsOn, true);
		OnOffCommand turnOff = new OnOffCommand(_containerName, _widgetsOff, false);
		VisibilityCommand show = new VisibilityCommand(_containerName, _widgetsShown, true);
		VisibilityCommand hide = new VisibilityCommand(_containerName, _widgetsHidden, false);
		turnOn.doCommand(strutsAction);
		turnOff.doCommand(strutsAction);
		show.doCommand(strutsAction);
		hide.doCommand(strutsAction);
		if (_stateName != null){
			strutsAction.getSession().put(_containerName+"_currentState",_stateName);
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/OnOffCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class OnOffCommand implements ICommand {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public OnOffCommand(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doCommand(BaseAction strutsAction) throws Exception{
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);		
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				cpWidgetsStatus.put(_targets[i]+"_enabled", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/VisibilityCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class VisibilityCommand implements ICommand {
	String _containerName = null;
	String[] _targets = null;
	boolean _show = true;

	public VisibilityCommand(String containerName, String targets[], boolean show) {
		_containerName = containerName;
		_targets = targets;
		_show = show;
	}

	public String doCommand(BaseAction strutsAction) throws Exception{
		if (_targets != null) {
			Map<String, Boolean> cpWidgetsStatus = 
				(Map<String, Boolean>) strutsAction.session.get(_containerName);			
			if(cpWidgetsStatus == null){
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(_containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < _targets.length; i++) {
				cpWidgetsStatus.put(_targets[i]+"_visible", new Boolean(_show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.*;
import com.opensymphony.xwork2.ActionSupport;
import «getDTOBaseJavaPackage()».*;

////ExecCommand
public abstract class ExecCommand implements ICommand {
	String _esiti[] = null;
	ICommand _azioni[] = null;
	java.util.Hashtable _resultAzioni = new java.util.Hashtable();

	public ExecCommand(String esiti[], ICommand[] azioni) {
		_esiti = esiti;
		_azioni = azioni;
		if (_esiti != null) {
			for (int i = 0; i < _esiti.length; i++)
				_resultAzioni.put(_esiti[i], _azioni[i]);
		}
	}

	/**
	 * Esecuzione della logica di business.
	 */
	public String doCommand(BaseAction strutsAction) throws Exception{
		// action --> model
		Object theModel = strutsAction.toModel();
		// esecuzione azione
		ExecResults execResults = doLogic(theModel); 
		String result = execResults.getResultCode();
		Object outModel = execResults.getModel();
		// model --> action
		strutsAction.fromModel(outModel);
		// impostazione degli appData
		storeAppData(execResults, strutsAction);
		// impostazione degli eventuali messaggi
		updateMessages(
			execResults.getFldErrors(), 
			execResults.getGlobalErrors(), 
			execResults.getGlobalMessages(), 
			strutsAction);
		// determinazione esito e azione corrispondente
		ICommand resultAction = null;
		for (int i = 0; i<_esiti.length; i++){
			if (_esiti[i].equals(result))
				resultAction = _azioni[i];
		}
		// esecuzione azione conseguente all'esito
		if(resultAction!=null){
			return resultAction.doCommand(strutsAction);
		}
		else
			throw new IllegalStateException("Il result code "+result+" non e' tra quelli previsti ("+_esiti+")");
	}
	
	/**
	 * inserisce negli appositi campi della action struts2 gli errori/messaggi provenienti dalla
	 * business logic.
	 */
	public void updateMessages(Map<String,String> fieldErrors, Collection<String> globalErrors, Collection<String> globalMessages, ActionSupport action){
		if (fieldErrors!=null){
			Iterator<String> fieldKey_it = fieldErrors.keySet().iterator();
			while(fieldKey_it.hasNext()){
				String currKey = fieldKey_it.next();
				action.addFieldError(currKey, fieldErrors.get(currKey));
			}
		}
		if (globalErrors!=null){
			Iterator<String> it = globalErrors.iterator();
			while(it.hasNext()){
				action.addActionError(it.next());
			}
		}
		if (globalMessages!=null){
			Iterator<String> it = globalMessages.iterator();
			while(it.hasNext()){
				action.addActionMessage(it.next());
			}
		}
	}
	
	/**
	 * Deve essere implamentata nella sottoclasse in modo da impostare in sessione o action i valori
	 * degli app data previsti dalla exec action
	 */
	public abstract void storeAppData(ExecResults res, BaseAction strutsAction);
	
	
	// deve essere sovrascritto per eseguire la logica e deve restituire il result_code
	// corretto
	public abstract ExecResults doLogic(Object theModel) throws Exception;
}
«ENDFILE»

«FILE getDTOBaseSrcDir(this)+"/ExecResults.java"»
package «getDTOBaseJavaPackage()»;

import java.util.*;
 
public class ExecResults {
	private String _resultCode;
	private Map<String, String> fldErrors = new HashMap<String, String>();
	private Collection<String> globalErrors=new ArrayList<String>();
	private Collection<String> globalMessages=new ArrayList<String>();
	private Object _model;
	
	public void setModel(Object model){
		_model=model;
	}
	
	public Object getModel(){
		return _model;
	}
	
	
	public void setResultCode(String code){
		_resultCode = code; 
	}
	
	public String getResultCode(){
		return _resultCode;
	}
	
	public Map<String, String> getFldErrors() {
		return fldErrors;
	}

	public void setFldErrors(Map<String, String> fldErrors) {
		this.fldErrors = fldErrors;
	}

	public Collection<String> getGlobalErrors() {
		return globalErrors;
	}

	public void setGlobalErrors(Collection<String> globalErrors) {
		this.globalErrors = globalErrors;
	}

	public Collection<String> getGlobalMessages() {
		return globalMessages;
	}

	public void setGlobalMessages(Collection<String> globalMessages) {
		this.globalMessages = globalMessages;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/SequenceCommand.java"»
package «getPresentationJavaPackage()»;

/// SEQUENCE_ACTION
public class SequenceCommand implements ICommand {
	ICommand[] _actions;
	public SequenceCommand(ICommand[] actions) {
		_actions = actions;
	}
	
	/**
	 * La sequence action esegue in sequenza tutte le azioni atomiche
	 * incluse come step, mantenendo il pi&ugrave; recente risultato non nullo restituito
	 * dagli step (per determinare al termine quale debba essere la pagina successiva
	 */
	public String doCommand(BaseAction strutsAction) throws Exception{
		String result=null;
		if (_actions != null) {
			for (int i = 0; i < _actions.length; i++) {
				ICommand currAct = _actions[i];
				String currResult = currAct.doCommand(strutsAction);
				if (currResult!=null)
					result=currResult;
			}
		}
		return result;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ShowDialogCommand.java"»
package «getPresentationJavaPackage()»;

/// SHOW_DIALOG_ACTION
public class ShowDialogCommand implements ICommand {
	String name;
	public ShowDialogCommand(String panelName) {
		name = panelName;
	}
	public String doCommand(BaseAction strutsAction) throws Exception {
		return "SHOW_"+name;
	}
};
«ENDFILE»

«ENDDEFINE»
