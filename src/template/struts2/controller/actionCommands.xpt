«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT guigen»
«IMPORT ecore»
«EXTENSION template::GenericExtensions »
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE actionImplClasses FOR GUIModel»
«FILE getPresentationJavaSrcDir(true)+"/ICommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Interfaccia comune di tutte le azioni di presentation
 *
 */
public interface ICommand extends java.io.Serializable {
	/**
	 * Esegue l'azione corrispondente
	 * @return il codice del RESULT struts conseguente all'azione (se l'azione comporta)
	 * una decisione sul result, null altrimenti
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException;
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/CommandExecutionException.java"»
package «getPresentationJavaPackage()»;

/**
 * Eccezione rilanciat ain caso di errori durante l'esecuzione della
 * catena di comandi.
 *
 */
public class CommandExecutionException extends Exception{
	public CommandExecutionException(String msg, Throwable nested){
		super(msg, nested);
	}
	
	public CommandExecutionException(String msg){
		super(msg);
	}
};
«ENDFILE»


«FILE getPresentationJavaSrcDir(true)+"/NOPCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione di NOPCommand. 
 * Questo comando ha effetto nullo nella catena.
 */
public class NOPCommand implements ICommand {
	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	public NOPCommand() {
		
	}
	
	/**
	 * @return null. In questo modo il NOPCommand ha effetto nullo sull'esecuzione 
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		return null;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando JumpCommand
 */
public class JumpCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;

	/**
	 * nome del ContentPanel target del salto
	 */
	String name;
	
	/**
	 * nome del contnetPanel di partenza (serve in caso di pushCurrentPage)
	 */
	String currentPageName = null;
	
	/**
	 * se impostato a true, verra' inserita la pagina (content panel) corrente nello 
	 * stack
	 */
	boolean pushCurrent;
	
	/**
	 * @param panelName il nome del contentPanel a cui saltare
	 * @param currentPageName il nome del contentPanel di partenza (serve in 
	 * caso di pushCurrentPage
	 * @param pushCurrentPage se impostato a true viene inserito il nome del contentPanel
     * corrente nello stack
	 */
	public JumpCommand(String panelName, String currentPageName,
			boolean pushCurrent) {
		name = panelName;
		this.pushCurrent = pushCurrent;
		this.currentPageName = currentPageName;
	}
	
	/**
	 * Esecuzione del salto. L'esecuzione del jump command si concretizza con la restituzione
	 * al workflow di struts del result corrispondente alla action associata al
	 * ContentPanel target. 
	 * Nel caso sia specificato pushCurrentPage=true, verra' inserito nello stack delle pagine
	 * il nome del contentPanel di partenza, contenuto in currentPageName.
	 * Inoltre viene eseguita la pulizia degli application data di scope SAME_PAGE.
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
	//se prevista modalità PUSH_PAGE_CURRENT --> inserisci in queque currentPage 
		if (this.pushCurrent && (null!=this.currentPageName && !"".equalsIgnoreCase(this.currentPageName))) {
			if (strutsAction.getAppDataNavigationQueue() == null)
				strutsAction.setAppDataNavigationQueue(new java.util.LinkedList());
			strutsAction.getAppDataNavigationQueue().add(this.currentPageName);
		} else {
			if (strutsAction.getAppDataNavigationQueue() != null)
				strutsAction.getAppDataNavigationQueue().clear();
		}
		// clear page scoped appdata
		strutsAction.clearPageScopedAppData(name);
		return "GO_TO_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/JumpBackCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando JumpBackCommand
 */
public class JumpBackCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	private java.util.LinkedList<java.lang.String> navigationQueue;
	private String currentCPName;

	/**
	 * @param currentCPName il nome del ContentPanel di partenza
	 * @param navigationQueue la coda (stack) di navigazione, necessaria per capire a
	 * che contentPanel tornare
	 */
	public JumpBackCommand(String currentCPName,
			java.util.LinkedList<java.lang.String> navigationQueue) {
		this.currentCPName = currentCPName;
		this.navigationQueue = navigationQueue;

	}
	
	/**
	 * Esecuzione del comando JumpBackCommand. L'esecuzione di questo comando consiste nella restituzione
	 * al workflow di struts del result GO_TO_BackPage, che tutte le action asosciate ai ContnetPanel
	 * possiedono, e che a runtime ridirige il flusso al content panel sul top dello stack.
	 * Il result GO_TO_BackPage prende le info circa namespace e action a cui saltare dalle property
	 * backNamespace e backActionName contenute nella action. questo comando pertanto, oltre a restituire
	 * il result GO_TO_BackPage, imposta anche tale coppia di proprieta'.
	 * Nel caso in cui lo stack sia vuoto il comando resittuisce il result BACK_TO_HOME che fa ritornare il
	 * flusso di esecuzione alla home page applicativa.
	 */
	public String doCommand(BaseAction strutsAction)
			throws CommandExecutionException {
		// clear page scoped appdata
		strutsAction.clearPageScopedAppData(currentCPName);

			if (navigationQueue != null && !navigationQueue.isEmpty()) {
			String backPage = navigationQueue.getLast();
			if (null != backPage && !"".equalsIgnoreCase(backPage)) {
				String[] splitArray = backPage.split("/");
				strutsAction.setBackActionName(splitArray[3]);
				strutsAction.setBackNamespace("/" + splitArray[1] + "/"
						+ splitArray[2]);
				navigationQueue.removeLast();
				return "GO_TO_BackPage";
			}
		}
		return "BACK_TO_HOME";

	}

};
«ENDFILE»



«FILE getPresentationJavaSrcDir(true)+"/RefreshViewCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando RefreshViewCommand.
 */
public class RefreshViewCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String currentPanelName = null;
	String [] targetPanels=null;
	String [] targetWidgets=null;
	
	/**
	 * @param currentPanelName il nome del ContentPanel su cui deve essere effettuato il refresh
	 * @param targetPanelNames l'elenco dei nomi dei pannelli da rinfrescare
	 * @param targetWidgetNames l'elenco dei nomi dei widget da rinfrescare
	 */
	public RefreshViewCommand(String currentPanelName, String [] targetPanelNames,
			String  [] targetWidgetNames) {
		this.currentPanelName = currentPanelName;
		this.targetPanels = targetPanelNames;
		this.targetWidgets = targetWidgetNames;
	}
	
	
	/**
	 * Nell'implementazione struts l'esecuzione di questo comando e' completamente a carico dello 
	 * strato javascript.
	 * Pertanto l'unico effetto di questo comando e' quello di comandare al workflow di struts la
	 * restituizione della pagina completa. La parte client ritagliera' le parti a seconda di 
	 * quali pannelli target sono stati modellati. 
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		return null;
	}
};
«ENDFILE»


«FILE getPresentationJavaSrcDir(true)+"/JumpExtCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando JumpExtCommnad.
 */
public class JumpExtCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;

	String locationCode;
	String staticUrl;
	String runtimeUrlProviderAppaData;
	boolean binaryStream;
	
	/**
	 * @param locationCode codice univoco identificativo della location a cui saltare.
	 * e' referenziato nel result di struts
	 * @param staticUrl se il comandoprevede il salto ad un url fisso, questo e' contenuto
	 * in tale parametro
	 * @param runtimeUrlProviderAppData nome dell'ApplicationData che contiene il valore dell'url a cui
	 * saltare (in caso di url dinamicamente determinato)
	 * @param binaryStream se impostato a true indica che l'url a cui si comanda il salto produrra'
	 * uno stream binario. Alcune cartuccie potrebbero sfruttare questa informazione per ottimizzare
	 * il comportamento.
	 */
	public JumpExtCommand(String locationCode, String staticUrl, String runtimeUrlProviderAppaData, boolean binaryStream) {
		this.locationCode = locationCode;
		this.staticUrl = staticUrl;
		this.runtimeUrlProviderAppaData = runtimeUrlProviderAppaData;
		this.binaryStream = binaryStream;
	}
	
	/**
	 * Esecuzione del comando JumpExtCommand. L'esecuzione si concretizza con la restituzione
	 * al workflow di struts del result GO_TO_EX_<codice della location>.
	 * sara' poi il result (di tipo redirect) a ridirigere il flusso all'url corretto.
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		// clear page scoped appdata
		strutsAction.clearPageScopedAppData(null);
		return "GO_TO_EX_"+locationCode;
	}
	
	/**
	 * codice della location a cui saltare
	 */
	public String getLocationCode() {
		return locationCode;
	}
	
	/**
	 * codice della location a cui saltare
	 */
	public void setLocationCode(String locationCode) {
		this.locationCode = locationCode;
	}
	
	/**
	 * url statico a cui saltare
	 */
	public String getStaticUrl() {
		return staticUrl;
	}
	
	/**
	 * url statico a cui saltare
	 */
	public void setStaticUrl(String staticUrl) {
		this.staticUrl = staticUrl;
	}
	
	/**
	 * nome dell'appdata contnenente l'url a cui saltare
	 */
	public String getRuntimeUrlProviderAppaData() {
		return runtimeUrlProviderAppaData;
	}
	
	/**
	 * nome dell'appdata contnenente l'url a cui saltare
	 */
	public void setRuntimeUrlProviderAppaData(String runtimeUrlProviderAppaData) {
		this.runtimeUrlProviderAppaData = runtimeUrlProviderAppaData;
	}
	
	/**
	 * l'url a cui saltare produrra' uno stream binario?
	 */
	public boolean isBinaryStream() {
		return binaryStream;
	}
	
	/**
	 * l'url a cui saltare produrra' uno stream binario?
	 */
	public void setBinaryStream(boolean binaryStream) {
		this.binaryStream = binaryStream;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ActivateMultiPanelItemCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comnado ActivateMultiPanelItemCommand
 */
public class ActivateMultiPanelItemCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String contentPanelName;
	String containerName; 
	String itemName;
	
	/**
	 * @param contentPanelName il nome del content panel
	 * @param containerName il nome del multi-panel contenitore
	 * @param itemName il nome dell'item da attivare (se null => non mostrare
	 *  nessun pannello
	 */
	public ActivateMultiPanelItemCommand(String contentPanelName, String containerName, String itemName) {
		assert contentPanelName!=null && contentPanelName.length()>0;
		assert containerName!=null && containerName.length()>0;
		// item name puo essere nullo => deselect
		
		this.contentPanelName = contentPanelName;
		this.containerName = containerName;
		this.itemName = itemName;
	}
	
	/**
	 * Esecuzione del comando ActivateMultiPanelItem. L'indicazione del nome dell'item 
	 * correntemente attivo e' mantenuta in sessione: 
	 * - chiave: <contentPanelName>_<containerName>_selectedMultiPanel" 
	 * - valore: <contentPanelName>_<containerName>_<itemName> oppure null per disattivare 
	 * tutti gli item
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		if (itemName!=null){
			strutsAction.getSession().put(
				contentPanelName+"_"+containerName+"_selectedMultiPanel", 
				contentPanelName+"_"+containerName+"_"+itemName);
		}
		else{
			strutsAction.getSession().remove(contentPanelName+"_"+containerName+"_selectedMultiPanel");
		}
		return null;
	}
};
«ENDFILE»


«FILE getPresentationJavaSrcDir(true)+"/ScreenStateCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

/**
 * Implementazione del comando ScreenStateCommand
 */
public class ScreenStateCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String containerName = null;
	String stateName = null;
	String[] widgetsOn = null;
	String[] widgetsOff = null;
	String[] widgetsShown = null;
	String[] widgetsHidden = null;


	/**
	 * @param containerName nome del content panel a cui fanno riferimento gli screen state
	 * @param stateName nome dello ScreenState da attivare
	 * @param widgetsOn elenco dei nomi dei widget da abilitare
	 * @param widgetsOff elenco dei nomi dei widget da disabilitare
	 * @param widgetsShown elenco dei nomi dei widget da mostrare
	 * @param widgetsHidden elenco dei nomi dei widget da nascondere
	 */
	public ScreenStateCommand(
			String containerName,
			String stateName, 
			String widgetsOn[],
			String widgetsOff[],
			String widgetsShown[],
			String widgetsHidden[]
			) {
		this.containerName = containerName;
		this.stateName = stateName;
		this.widgetsOn = widgetsOn;
		this.widgetsOff = widgetsOff;
		this.widgetsShown = widgetsShown;
		this.widgetsHidden = widgetsHidden;
	}

	/**
	 * Esecuzione del comando ScreenStateCommand. L'esecuzione di questo comando e' concretizzata
	 * tramite l'esecuzione di una serie di comnadi ONOFF e Visibility a seconda di quanto descritto
	 * iun widgetsOn/Off, widgetShown/Hidden.  
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		OnOffCommand turnOn = new OnOffCommand(this.containerName, this.widgetsOn, true);
		OnOffCommand turnOff = new OnOffCommand(this.containerName, this.widgetsOff, false);
		VisibilityCommand show = new VisibilityCommand(this.containerName, this.widgetsShown, true);
		VisibilityCommand hide = new VisibilityCommand(this.containerName, this.widgetsHidden, false);
		turnOn.doCommand(strutsAction);
		turnOff.doCommand(strutsAction);
		show.doCommand(strutsAction);
		hide.doCommand(strutsAction);
		if (this.stateName != null){
			strutsAction.getSession().put(this.containerName+"_currentState",this.stateName);
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/PDefStateCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

public class PDefStateCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String containerName = null;
	String stateName = null;
	String[] widgetsOn = null;
	String[] widgetsOff = null;
	String[] widgetsShown = null;
	String[] widgetsHidden = null;

	public PDefStateCommand(
			String containerName,
			String stateName, 
			String widgetsOn[],
			String widgetsOff[],
			String widgetsShown[],
			String widgetsHidden[]
			) {
		this.containerName = containerName;
		this.stateName = stateName;
		this.widgetsOn = widgetsOn;
		this.widgetsOff = widgetsOff;
		this.widgetsShown = widgetsShown;
		this.widgetsHidden = widgetsHidden;
	}

	
	/**
	 * La logica &egrave; l astessa di ScreenStateCommand, poich&egrave; i nomi dei widget sono espansi
	 * all'inizializzazione del comando.
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		OnOffCommand turnOn = new OnOffCommand(this.containerName, this.widgetsOn, true);
		OnOffCommand turnOff = new OnOffCommand(this.containerName, this.widgetsOff, false);
		VisibilityCommand show = new VisibilityCommand(this.containerName, this.widgetsShown, true);
		VisibilityCommand hide = new VisibilityCommand(this.containerName, this.widgetsHidden, false);
		turnOn.doCommand(strutsAction);
		turnOff.doCommand(strutsAction);
		show.doCommand(strutsAction);
		hide.doCommand(strutsAction);
		if (this.stateName != null){
			strutsAction.getSession().put(this.containerName+"_currentState",this.stateName);
		}
		return null;
	}
}
«ENDFILE»



«FILE getPresentationJavaSrcDir(true)+"/OnOffCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;

/**
 * Implementazione del comando OnOffCommand 
 */
public class OnOffCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	private static final String SESSION_MENU_ONOFF = "menuOnOffMap";

	String containerName = null;
	String[] targetsWidgets = null;
	String[] targetsMenuElement = null;
	boolean enable = true;

	/**
	 * @param containerName il nome del content panel che contiene i widget da abilitare/disabilitare
	 * @param targetWidgets nomi dei widget da abilitare/disabilitare
	 * @param enable se vale true i widget saranno abilitati, altrimenti saranno disabilitati
	 */
	public OnOffCommand(String containerName, String targetsWidgets[], boolean enable) {
		this.containerName = containerName;
		this.targetsWidgets = targetsWidgets;
		this.enable = enable;
	}
	
	/**
	 * @param containerName il nome del content panel che contiene i widget da abilitare/disabilitare
	 * @param targetWidgets nomi dei widget da abilitare/disabilitare
	 * @param targetsMenuElement nomi dei menu da abilitare/disabilitare
	 * @param enable se vale true i widget/menu saranno abilitati, altrimenti saranno disabilitati
	 */
	public OnOffCommand(String containerName, String targetsWidgets[], String targetsMenuElement[], boolean enable) {
		this.containerName = containerName;
		this.targetsWidgets = targetsWidgets;
		this.targetsMenuElement = targetsMenuElement;
		this.enable = enable;
	}
	
	/**
	 * esecuzione del comando OnOffCommand. Lo stato di abilitazione dei widget/menu e' contenuto in
	 * sessione.
	 */
	public String doCommand(BaseAction strutsAction)
			throws CommandExecutionException {
		if (this.targetsWidgets != null) {
			Map<String, Boolean> cpWidgetsStatus = (Map<String, Boolean>) strutsAction.session
					.get(this.containerName);
			if (cpWidgetsStatus == null) {
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(this.containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < this.targetsWidgets.length; i++) {
				cpWidgetsStatus.put(this.targetsWidgets[i] + "_enabled",
						Boolean.valueOf(this.enable));
			}
		}
		
		
		if (this.targetsMenuElement != null) {
			Map<String, Boolean> menuOnOffMap = (Map<String, Boolean>) strutsAction.session
					.get(SESSION_MENU_ONOFF);
			if (menuOnOffMap == null) {
				menuOnOffMap = new HashMap<String, Boolean>();
				strutsAction.session.put(SESSION_MENU_ONOFF, menuOnOffMap);
			}
			for (int i = 0; i < this.targetsMenuElement.length; i++) {
				menuOnOffMap.put(this.targetsMenuElement[i] + "_enabled",
						Boolean.valueOf(this.enable));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/VisibilityCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.Map;
import java.util.HashMap;


/**
 * Implementazione dle comando VisibilityCommand
 */
public class VisibilityCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	/**
	 * nome dell'attributo in sessione che contiene la mappa di visibilita' dei menu
	 */
	private static final String SESSION_MENU_VISIBILITY = "menuVisibilityMap";

	/**
	 * containerName
	 */
	String containerName = null;
	
	/**
	 * targetsWidgets
	 */
	String[] targetsWidgets = null;
	
	/**
	 * targetsMenuElement
	 */
	String[] targetsMenuElement = null;
	
	/**
	 * show?
	 */
	boolean show = true;

	/**
	 * @param containerName il nome del content panel che contiene i widget da mostrare/nascondere
	 * @param targetWidgets nomi dei widget da mostrare/nascondere
	 * @param targetsMenuElement nomi dei menu da mostrare/nascondere
	 * @param show se vale true i widget/menu saranno abilitati, altrimenti saranno disabilitati
	 */
	public VisibilityCommand(String containerName, String targetsWidgets[], String targetsMenuElement[],
			boolean show) {
		this.containerName = containerName;
		this.targetsWidgets = targetsWidgets;
		this.targetsMenuElement = targetsMenuElement;
		this.show = show;
	}
	
	/**
	 * @param containerName il nome del content panel che contiene i widget da mostrare/nascondere
	 * @param targetWidgets nomi dei widget da mostrare/nascondere
	 * @param show se vale true i widget/menu saranno abilitati, altrimenti saranno disabilitati
	 */
	public VisibilityCommand(String containerName, String targetsWidgets[], 
			boolean show) {
		this.containerName = containerName;
		this.targetsWidgets = targetsWidgets;
		this.show = show;
	}

    /**
	 * esecuzione del comando VisibilityCommand. Lo stato di visibilita' dei widget/menu e' contenuto in
	 * sessione.
	 */
	public String doCommand(BaseAction strutsAction)
			throws CommandExecutionException {
		
		//Definzione Visibility Widgets per ContentPanel
		if (this.targetsWidgets != null) {
			// lo stato di visibilita' dei widget e' mantenuto in sessione
			// in una mappa a due livelli:
			// - il primo livello contiene <nome cp, mappa per il cp>
			// - il secondo livello contiene <[widget]_visible, true|false>
			Map<String, Boolean> cpWidgetsStatus = (Map<String, Boolean>) strutsAction.session
					.get(this.containerName);
			if (cpWidgetsStatus == null) {
				cpWidgetsStatus = new HashMap<String, Boolean>();
				strutsAction.session.put(this.containerName, cpWidgetsStatus);
			}
			for (int i = 0; i < this.targetsWidgets.length; i++) {
				cpWidgetsStatus.put(this.targetsWidgets[i] + "_visible",
						Boolean.valueOf(this.show));
			}
			
		
		}
		
		//Definzione Visibility MenuElement 
		if(this.targetsMenuElement !=null){
			// lo stato di visibilita' di una voce di menu e' contenuta in sessione
			// in una mappa
			Map<String, Boolean> menuVisibilityMap = (Map<String, Boolean>) strutsAction.session
					.get(SESSION_MENU_VISIBILITY);

			if (menuVisibilityMap == null) {
				// se la mappa non esiste ancora la creo
				menuVisibilityMap = new HashMap<String, Boolean>();
				strutsAction.session
						.put(SESSION_MENU_VISIBILITY, menuVisibilityMap);
			}
			// inserisco lo stato di visibilita' di tutti i target menu
			// inserendo la coppia <[menu]_visible, true|false>
			for (int i = 0; i < this.targetsMenuElement.length; i++) {
				menuVisibilityMap.put(this.targetsMenuElement[i] + "_visible",
						Boolean.valueOf(this.show));
			}
		}
		return null;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ExecCommand.java"»
package «getPresentationJavaPackage()»;

import java.util.*;
import com.opensymphony.xwork2.ActionSupport;
import «getDTOBaseJavaPackage()».*;
import «getSpringBEFQN(this)»;
import java.lang.reflect.Method;
import «getSpringBEExcFQN(this)»;
import java.lang.reflect.InvocationTargetException;



/**
 * Implementazione del comando ExecCommand.
 */
public class ExecCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	/**
	 * gli esiti possibili
	 */
	String esiti[] = null;
	
	/**
	 * le azioni corrispondenti agli esiti possibili
	 */
	ICommand azioni[] = null;
	
	/**
	 * il nome del metodo da eseguire
	 */
	String nomeMetodo = null;
	
	/**
	 * gli appdata che la logica modifica
	 */
	String appDataToStore[] = null;
	
	/**
	 * mappa <result,azione>
	 */
	java.util.Hashtable resultAzioni = new java.util.Hashtable();

	/**
	 * @param esiti elenco dei possibili esiti (restituiti dal metodo di business effettivo
	 * @param azioni elenco degli oggeti ICommand da eseguire a fronte di ciascun esito
	 * @param nomeMetodo nome del metodo del bean dello strato di business logic da eseguire
	 * @param appDataToStore elenco dei nomi degli application data modificati dalla logica di business
	 */
	public ExecCommand(String esiti[], ICommand[] azioni, String nomeMetodo, String appDataToStore[]) {
		this.esiti = esiti;
		this.azioni = azioni;
		this.nomeMetodo = nomeMetodo;
		this.appDataToStore = appDataToStore;
		if (this.esiti != null) {
			// riempio la mappa <esiti,azioni>
			for (int i = 0; i < this.esiti.length; i++)
				this.resultAzioni.put(this.esiti[i], this.azioni[i]);
		}
	}

	/**
	 * Esecuzione della logica di business.
	 * Il model su cui lavorera' il metodo di business e' estratto dalla action.
	 * viene quindi invocato il metodo di business tramite introspection e viene
	 * preparato il risultato da restituire al workflow di struts (aggiornando anche i
	 * messaggi con quanto eventualmente contenuto nell'oggetto ExecResult restituito 
	 * dal metodo di business.
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		// action --> model
		Object theModel = strutsAction.toModel();
		// esecuzione azione
		ExecResults execResults = doLogic(theModel, strutsAction.getSpringBackEnd()); 
		String result = execResults.getResultCode();
		BaseSessionAwareDTO outModel = (BaseSessionAwareDTO)execResults.getModel();
		
		// model --> action
		strutsAction.fromModel(outModel);
		// impostazione degli appData
		storeAppData(execResults, strutsAction);
		// impostazione degli eventuali messaggi
		updateMessages(
			execResults.getFldErrors(), 
			execResults.getGlobalErrors(), 
			execResults.getGlobalMessages(), 
			strutsAction);
		// determinazione esito e azione corrispondente
		ICommand resultAction = null;
		for (int i = 0; i<this.esiti.length; i++){
			if (this.esiti[i].equals(result))
				resultAction = this.azioni[i];
		}
		// esecuzione azione conseguente all'esito
		if(resultAction!=null){
			return resultAction.doCommand(strutsAction);
		}
		else
			throw new IllegalStateException("Il result code "+result+" non e' tra quelli previsti ("+(this.esiti)+")");
	}
	
	/**
	 * inserisce negli appositi campi della action struts2 gli errori/messaggi provenienti dalla
	 * business logic.
	 */
	public void updateMessages(Map<String,String> fieldErrors, Collection<String> globalErrors, Collection<String> globalMessages, ActionSupport action){
		if (fieldErrors!=null){
			Iterator<String> fieldKey_it = fieldErrors.keySet().iterator();
			while(fieldKey_it.hasNext()){
				String currKey = fieldKey_it.next();
				action.addFieldError(currKey, fieldErrors.get(currKey));
			}
		}
		if (globalErrors!=null){
			Iterator<String> it = globalErrors.iterator();
			while(it.hasNext()){
				action.addActionError(it.next());
			}
		}
		if (globalMessages!=null){
			Iterator<String> it = globalMessages.iterator();
			while(it.hasNext()){
				action.addActionMessage(it.next());
			}
		}
	}
	
	/**
	 * Imposta in sessione o action i valori
	 * degli app data previsti dalla exec action
	 */
	public void storeAppData(ExecResults res, BaseAction strutsAction) throws CommandExecutionException {
		for (int i = 0; i < this.appDataToStore.length; i++) {
				storeSpecificAppData(this.appDataToStore[i], res.getModel(), strutsAction);
			}
	}
	
	/**
	 * Imposta in sessione o action il valore
	 * dell'app data previsto dalla exec action
	 */
	private void storeSpecificAppData(String nomeAppData, Object sourceModel, BaseAction targetAction) throws CommandExecutionException {
		
		try {
				java.lang.reflect.Method srcReadMethod = targetAction.findReadMethod(nomeAppData, sourceModel.getClass());
				if (srcReadMethod != null) {
					Object srcVal = srcReadMethod.invoke(sourceModel, new Object[]{});
					java.lang.reflect.Method currWriteMethod = targetAction.findWriteMethod(nomeAppData, targetAction.getClass());
					if (currWriteMethod != null) {
						currWriteMethod.invoke(targetAction, new Object[]{srcVal});
					}
				}
			} catch (Exception ioe){
				throw new CommandExecutionException(
						"errore non gestito nell'esecuzione del metodo ["+ (this.nomeMetodo) + "]:"
								+ ioe.getMessage(), ioe);
		      } 
	}
		
	/**	
	 * Esegue la logica e restituisce il result_code corretto
	 */ 
	public  ExecResults doLogic(Object theModel, BackEndFacade backEnd )
			throws CommandExecutionException {

		
		it.csi.util.performance.StopWatch watcher = new it.csi.util.performance.StopWatch(«getBaseJavaPackage(this)».util.Constants.APPLICATION_CODE);
		ExecResults result = null;

		try {
		
			watcher.start();
			Class cl = backEnd.getClass();
			Method m = cl.getMethod(this.nomeMetodo, new Class[]{theModel.getClass()});
			result = (ExecResults) m.invoke(backEnd, new Object[]{theModel});
			

			watcher.stop();
			watcher.dumpElapsed("ExecCommand", "readOne()",
					"chiamata verso BackEnd", this.nomeMetodo);
			return result;

		} catch (NoSuchMethodException ensm){
			throw new CommandExecutionException(
					"errore non gestito nell'esecuzione del metodo ["+ this.nomeMetodo + "]:"
							+ ensm.getMessage(), ensm);
		} catch (IllegalAccessException eiacc){
			throw new CommandExecutionException(
					"errore non gestito nell'esecuzione del metodo ["+ this.nomeMetodo + "]:"
							+ eiacc.getMessage(), eiacc);
		} catch (IllegalArgumentException eiarg){
			throw new CommandExecutionException(
					"errore non gestito nell'esecuzione del metodo ["+ this.nomeMetodo + "]:"
							+ eiarg.getMessage(), eiarg);
		} catch (InvocationTargetException einvoc){
			if (einvoc.getTargetException() instanceof BEException ) {
				throw new CommandExecutionException(
						"errore non gestito nell'esecuzione del metodo ["+ this.nomeMetodo + "]:"
								+ einvoc.getMessage(), einvoc);
			} else {
				throw new CommandExecutionException(
						"errore non gestito nell'esecuzione del metodo ["+ this.nomeMetodo + "]:"
								+ einvoc.getMessage(), einvoc);
			}
		}
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ClearAppDataCommand.java"»
package «getPresentationJavaPackage()»;


import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Implementazione del comando ClearAppDataCommand.
 */
public class ClearAppDataCommand implements ICommand {
	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	private String[] attributesToBeRemovedFromSession = null;
	
	/**
	 * @param nomi degli application data da cancellare
	 */
	public ClearAppDataCommand(String[] attributesToBeRemovedFromSession) {
		this.attributesToBeRemovedFromSession = attributesToBeRemovedFromSession;
	}
	
	/**
	 * Implementazione del comando clearAppdataCommand. 
	 * Il comando rimuove dalla sessione gli attributi corrispondenti
	 * agli application data elencati in attributesToBeRemovedFromSession
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		if (this.attributesToBeRemovedFromSession!=null && this.attributesToBeRemovedFromSession.length!=0){
			for (int i = 0; i < this.attributesToBeRemovedFromSession.length; i++) {
				clearAppDataFromModel(strutsAction.getModel(), "appData" + (this.attributesToBeRemovedFromSession[i]));				
			}			 
		}
		return null;
	}
	
	private void clearAppDataFromModel(Object model, String name){
		Class modelClass = model.getClass();
		try {
			BeanInfo bi = Introspector.getBeanInfo(modelClass);
			PropertyDescriptor[] pds = bi.getPropertyDescriptors();
			for (int i = 0; i < pds.length; i++) {
				PropertyDescriptor currPD = pds[i];
				if (currPD.getName().equals(name)){
					Method writeMethod = currPD.getWriteMethod();
					writeMethod.invoke(model, new Object[]{(Object)null});
				}
			}
		} catch (IntrospectionException e) {
			;;
		} catch (IllegalArgumentException e) {
			;;
		} catch (IllegalAccessException e) {
			;;
		} catch (InvocationTargetException e) {
			;;
		}
	}
};
«ENDFILE»

«FILE getDTOBaseSrcDir(this)+"/ExecResults.java"»
package «getDTOBaseJavaPackage()»;

import java.util.*;
 
/**
 * Contiene i risultati dell'esecuzione di un metodo di business
 * @generated
 */
public class ExecResults {

	/**
	 * il codice di outcome
	 * @generated
	 */
	private String resultCode;
	
	/**
	 * l'elenco degli errori associati ai field della schermata eventualmente inseriti 
	 * da business logic
	 * @generated
	 */
	private Map<String, String> fldErrors = new HashMap<String, String>();
	
	/**
	 * l'elenco degli errori globali eventualmente inseriti da business logic
	 * @generated
	 */
	private Collection<String> globalErrors=new ArrayList<String>();
	
	/**
	 * l'elenco dei messaggi globali eventualmente inseriti da business logic
	 * @generated
	 */
	private Collection<String> globalMessages=new ArrayList<String>();
	private Object model;
	
	/**
	 * imposta il model del content panel
	 * @param  model 
	 * @generated
	 */
	public void setModel(Object model){
		this.model=model;
	}
	
	/**
	 * restutuisce il model del content panel
	 * @generated
	 */
	public Object getModel(){
		return this.model;
	}
	
	
	/**
	 * imposta il codice di outcome
	 * @generated
	 */
	public void setResultCode(String code){
		this.resultCode = code; 
	}
	
	/** 
	 * restutuisce il codice di outcome
	 * @generated
	 */
	public String getResultCode(){
		return this.resultCode;
	}
	
	/**
	 * restituisce l'elenco degli errori associati al campo eventualmente inseriti nella
	 * business logic
	 * @generated
	 */
	public Map<String, String> getFldErrors() {
		return fldErrors;
	}

	public void setFldErrors(Map<String, String> fldErrors) {
		this.fldErrors = fldErrors;
	}

	/**
	 * restituisce l'elenco degli errori globali eventualmente inseriti nella
	 * business logic
	 * @generated
	 */
	public Collection<String> getGlobalErrors() {
		return globalErrors;
	}

	public void setGlobalErrors(Collection<String> globalErrors) {
		this.globalErrors = globalErrors;
	}

	/**
	 * restituisce l'elenco dei messaggi globali eventualmente inseriti nella
	 * business logic
	 * @generated
	 */
	public Collection<String> getGlobalMessages() {
		return globalMessages;
	}

	public void setGlobalMessages(Collection<String> globalMessages) {
		this.globalMessages = globalMessages;
	}
}
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/SequenceCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando SequenceCommand.
 */
public class SequenceCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	ICommand[] actions;
	
	/** 
	 * @param actions elenco degli ICommand da eseguire in sequenza
	 */
	public SequenceCommand(ICommand[] actions) {
		this.actions = actions;
	}
	
	/**
	 * La sequence action esegue in sequenza tutte le azioni atomiche
	 * incluse come step, mantenendo il pi&ugrave; recente risultato non nullo restituito
	 * dagli step (per determinare al termine quale debba essere la pagina successiva
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException{
		String result=null;
		if (this.actions != null) {
			for (int i = 0; i < this.actions.length; i++) {
				ICommand currAct = this.actions[i];
				String currResult = currAct.doCommand(strutsAction);
				if (currResult!=null)
					result=currResult;
			}
		}
		return result;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ShowDialogCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando ShowDialogCommnad
 */
public class ShowDialogCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String name;
	
	/**
	 * @param panelName il nome del DialogPanel da visualizzare
	 */
	public ShowDialogCommand(String panelName) {
		name = panelName;
	}
	
	/**
	 * Esecuzione del comando ShowDialogCommand. 
	 * Si concretizza con la restituzione al workflow di struts del result SHOW_<nome dialog>.
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		return "SHOW_"+name;
	}
};
«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/BeginEditCommand.java"»
package «getPresentationJavaPackage()»;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * Implementazione del comando BeginEditCommand.
 */
public class BeginEditCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String [] targetAppDataNames;
	
	/**
	 * @param targetAppDataNames i nomi degli applicaiton data da includere nella
	 * sessione
	 */
	public BeginEditCommand(String [] targetAppDataNames) {
		this.targetAppDataNames = targetAppDataNames;
	}
	
	/**
	 * Esecuzione del comando BeginEditCommand. 
	 * Salva un backup (deep copy) degli appdata specificati
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		if (targetAppDataNames != null){
			for (int i = 0; i < targetAppDataNames.length; i++) {
				String currADName = targetAppDataNames[i];
				try{
					storeBackup(currADName, strutsAction);
				}
				catch(CloneNotSupportedException cnse){
					throw new CommandExecutionException(
						"Errore nella creazioene del backup dell'appdata ["+currADName+"]:"+cnse.getMessage(),cnse);
				}
			}
		}
		return null;
	}
	
	/**
	 * Effettua il salvataggio di un backup del singolo applicationData
	 * @param adName il nome dell'application data
	 * @param strutsAction la action su cui si scatena il comando
	 */
	public static void storeBackup(String adName, BaseAction strutsAction) throws CloneNotSupportedException
	{
		Object currADVal = strutsAction.getSession().get(adName);
		Object currADValClone = deepClone(currADVal);
		if (currADVal != null) {
			strutsAction.getSession().put(adName + "_bckp", currADValClone);
		}
	}
	
	/**
	 * Effettua un clone ricorsivo delle strutture dati in input.
	 * Il clone viene fatto tramite serializzazione in memory e successiva deserializzazione.
	 */
	public static Object deepClone(Object orig) throws CloneNotSupportedException{
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos;
		try {
			oos = new ObjectOutputStream(baos);
			oos.writeObject(orig);
			ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
			ObjectInputStream ois = new ObjectInputStream(bais);
			Object clone = ois.readObject();
			return clone;
		} catch (IOException e) {
			throw new CloneNotSupportedException();
		} catch (ClassNotFoundException e) {
			throw new CloneNotSupportedException();
		}
	}
};

«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/EndEditCommand.java"»
package «getPresentationJavaPackage()»;


/**
 * Implementazione del comando EndEditSession.
 */
public class EndEditCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	String [] targetAppDataNames;
	boolean undo;
	
	/**
	 * @param targetAppDataNames i nomi degli application data da ripristinare (eventualmente)
	 * @param undo se valorizzato a true, il valore degli appdata referenziati viene ripristinato a partire
	 * dal valore di backup effettuato durante l'esecuzione del BeginEditCommand corrispondente
	 */
	public EndEditCommand(String [] targetAppDataNames, boolean undo) {
		this.targetAppDataNames = targetAppDataNames;
		this.undo=undo;
	}
	
	/**
	 * Elimina i backup (deep copy) degli appdata specificati, ripristinando il
	 * valore se undo==true; 
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		if (targetAppDataNames != null){
			for (int i = 0; i < targetAppDataNames.length; i++) {
				String currADName = targetAppDataNames[i];
				endEditForAppdata(currADName, undo, strutsAction);
			}
		}
		return null;
	}
	
	/**
	 * Rimuove i backup e se necessario effettua il restore del valore del singolo application data
	 * @param adName
	 * @param undo
	 * @param strutsAction
	 */
	public static void endEditForAppdata(String adName, boolean undo,
			BaseAction strutsAction) {
		if (undo) {
			// undo del dato
			Object currADValBkp = strutsAction.getSession().get(
					adName + "_bckp");
			if (currADValBkp != null) {
				strutsAction.getSession().put(adName, currADValBkp);
			}
		}
		// rimuove il backup 
		strutsAction.getSession().remove(adName + "_bckp");
	}
	
};


«ENDFILE»

«FILE getPresentationJavaSrcDir(true)+"/ChkEditStatusCommand.java"»
package «getPresentationJavaPackage()»;

/**
 * Implementazione del comando ChkEditStatusCommand. Permette di esaminare se il valore
 * di un ApplicationData coinvolto in una sessione di editing (tramite BeginEditSessionCommand)
 * e' stato modificato.
 */
public class ChkEditStatusCommand implements ICommand {

	// il serial version uid e' fisso in quanto la classe in oggetto e' serializzabile
	// solo per poter essere inserita in sessione web e non viene scambiata con altre
	// componenti.
	private static final long serialVersionUID = 1L;
	
	ICommand doIfChanged;
	ICommand doIfNotChanged;
	String checkAggr;
	String [] checkedData;
	
	/**
	 * @param checkedData il nome deli application data da esaminare
	 * @param checkAggregation modalita' di aggregazione dei risultati dei singoli check.
	 * puo' valere "AND", "OR" o "XOR"
	 * @param doIfChanged ICommand da eseguire se il check e' positivo (dati variati)
	 * @param doIfNotChanged ICommand da eseguire se il check e' negativo (dati non variati) 
	 */
	public ChkEditStatusCommand(
			String [] checkedData, 
			String checkAggregation, 
			ICommand doIfChanged,
			ICommand doIfNotChanged) {
		this.checkedData=checkedData;
		this.checkAggr=checkAggregation;
		this.doIfChanged=doIfChanged;
		this.doIfNotChanged=doIfNotChanged;
	}

	/**
	 * Esecuzione del comando. 
	 * A seconda del risultato del check (che tiene conto del tipo di aggregazione)
	 * viene eseguito il comando contenuto in doIfChanged o doIfNotchanged
	 */
	public String doCommand(BaseAction strutsAction) throws CommandExecutionException {
		boolean changed = checkAppdata4Changes(this.checkedData, this.checkAggr, strutsAction);
		if (changed)
			return this.doIfChanged.doCommand(strutsAction);
		else
			return this.doIfNotChanged.doCommand(strutsAction);
	}

	/**
	 * Verifica variazioni sugli appdata con la politica di aggregazione specificata
	 * @param checkedData
	 * @param checkAggr
	 * @param strutsAction
	 * @return
	 */
	boolean checkAppdata4Changes(String[] checkedData, String checkAggr, BaseAction strutsAction) {
		if (checkedData==null || checkedData.length==0)
			return false;
		// else
		boolean ris = "OR".equals(checkAggr) ? false : ("AND".equals(checkAggr) ? true : false);
		for (int i = 0; i < checkedData.length; i++) {
			String currADName = checkedData[i];
			boolean currChanged = checkAppdata4Changes(currADName, strutsAction);
			if (currChanged && "OR".equals(checkAggr))
				return true; // al primo esco con true
			else if (!currChanged && "AND".equals(checkAggr))
				return false; // al primo falso esco con falso
			else if ("XOR".equals(checkAggr)){
				if (currChanged && ris)
					return false; // secondo match: rompe lo xor
			}
		}
		return ris;
	}

	/**
	 * verifica se il singolo appdata e' variato
	 * @param currADName
	 * @param strutsAction
	 * @return
	 */
	private boolean checkAppdata4Changes(String currADName,
			BaseAction strutsAction) {
		Object adVal = strutsAction.getSession().get(currADName);
		Object adBkp = strutsAction.getSession().get(currADName+"_bckp");
		if (adBkp != null){
			«getDTOBaseJavaPackage()».DTOUtils dtoUtils = «getDTOBaseJavaPackage()».DTOUtils.getInstance();
			return !(dtoUtils.deepEquals(adVal, adBkp));
		}
		else
			return false;
	}
	
	
};

«ENDFILE»

«EXPAND dtoUtilsFile FOR this»

«ENDDEFINE»

«REM»sarebbe da spostare in "model"«ENDREM»
«DEFINE dtoUtilsFile FOR GUIModel»
«FILE getDTOBaseSrcDir()+"/DTOUtils.java"»package «getDTOBaseJavaPackage()»;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

/**
 * classe di utilita' varia per operare sugli oggetti DTO.
 */
public class DTOUtils {

	/**
	 * singleton
	 */
	private static DTOUtils instance;
	
	static{
		// creazione del singleton
		instance = new DTOUtils();
	}
	
	/**
	 * singleton instance
	 */
	public static DTOUtils getInstance(){
		return instance;
	}
	
	/**
	 * Effettua una verifica di uguaglianza in profondita' tra i due
	 * oggetti in input
	 * @param o1
	 * @param o2
	 */
	public boolean deepEquals(Object o1, Object o2){
		if ((o1==null || o2==null) && (o1!=null || o2!=null)){
			// se uno solo dei due oggetti e' nullo allora non 
			// possono essere uguali
			return false;
		}else if (List.class.isAssignableFrom(o1.getClass())) {
			// se sono array effettuo la verifica specifica
			return deepEqualsArray(o1, o2);
		}else if (!(o1.getClass().equals(o2.getClass()))){
			// se i due oggetti non sono della stessa classe
			// non possono essere uguali
			return false;
		// else: stesso tipo e nessuno dei due nullo
		}
		else if (o1 instanceof Integer || o1 instanceof Long
				|| o1 instanceof Float || o1 instanceof Double
				|| o1 instanceof String || o1 instanceof Byte 
				|| o1 instanceof Boolean) {
			// se sono tipi semplici utilizzo la funzione equals prevista
			// per quei tipi
			return o1.equals(o2);
		}
		else {
			// se sono oggetti complessi effettuo la verifica specifica
			return deepEqualsBean(o1, o2);
		}
	}
	
	/**
	 * verifica di uguaglianza specifica per bean
	 * @param o1
	 * @param o2
	 */
	private boolean deepEqualsBean(Object o1, Object o2) {
		BeanInfo bi;
		try {
			// l'accesso agli oggetti avviene mediante introspection
			bi = Introspector.getBeanInfo(o1.getClass());
		} catch (IntrospectionException e) {
			throw new IllegalArgumentException("errore in lettura campi di "+o1.getClass()+":"+e);
		}
		PropertyDescriptor [] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPD = pds[i];
			// ottengo il metodo di lettura della property corrente dai metadati
			Method getter = currPD.getReadMethod();
			// ottengo il metodo di scrittura della property corrente dai metadati
			Method setter = currPD.getWriteMethod();
			if (getter != null && setter != null){
				// se la property non e' read only..
				try {
					// valore della property nell'oggetto 1
					Object v1 = getter.invoke(o1, new Object[]{});
					// valore della property nell'oggetto 2
					Object v2 = getter.invoke(o2, new Object[]{});
					// richiamo ricorsivamente la verifica sui due valori
					if (!deepEquals(v1, v2))
						return false; // basta uno diverso => false
				} 
				catch (IllegalAccessException e) {
					throw new IllegalArgumentException("errore in lettura campi di "+o1.getClass()+":"+e);
				}
				catch (InvocationTargetException e) {
					throw new IllegalArgumentException("errore in lettura campi di "+o1.getClass()+":"+e);
				}
			}
		}
		return true;
	}
	
	/**
	 * metodo di verifica di uguaglianza profonda, specifico per oggetti di
	 * tipo array
	 * @param o1
	 * @param o2
	 */
	private boolean deepEqualsArray(Object o1, Object o2) {
		List l1 = (List)o1;
		List l2 = (List)o2;
		if (l1.size() != l2.size()) {
			// se le due collezioni non hanno lo stesso numero di elementi
			// non possono essere uguali, percio' non proseguo la verifica
			// sugli elementi
			return false;
		}
		else{
			// se le due collezioni hanno lo stesso numero di elementi proseguo
			// la verifica sui singoli elementi
			for (int i = 0; i < l1.size(); i++) {
				// oggetto i-esimo della prima collezione
				Object curr1 = l1.get(i);
				// oggetto i-esimo della seconda collezione
				Object curr2 = l2.get(i);
				// effettuo la verifica sulla coppia di elementi, sempre tramite
				// il metodo deepEquals
				if (!deepEquals(curr1, curr2))
					return false; // al primo diverso mi fermo
			}
			return true;
		}
	}
	
		/**
	 * 
	 * @param lista
	 *            di oggetti in cui effettuare la ricerca
	 * @param lista
	 *            delle chiavi usate per individuare gli elementi
	 * @param nome
	 *            del campo che rappresenta la chiave
	 * @return l'array degli oggetti corrispondenti alle chiavi. Se non c'e'
	 *         nessuna corrispondenza viene restituito un array vuoto.
	 */
	public static ArrayList findElementInListById(ArrayList lista,
			ArrayList listaKeys, String nomeCampoKey) {
		ArrayList res = new ArrayList();
		if (listaKeys == null || listaKeys.size() == 0)
			return res; // no keys => no results
		else if (lista == null || lista.size() == 0)
			return res; // no elements => no results
		else if (nomeCampoKey == null || nomeCampoKey.length() == 0)
			throw new IllegalArgumentException("nomeCampoKey is null or empty");
		else {
			String propMethodName = "get"+(nomeCampoKey.substring(0,1).toUpperCase())+nomeCampoKey.substring(1);
			for (Object elemento : lista) {
				Class classe = elemento.getClass();
				try {
					Method getCodice = classe.getMethod(propMethodName,
							null);
					Object codice = getCodice.invoke(elemento, new Object[] {});
					if (listaKeys != null && listaKeys.contains(codice)) {
						res.add(elemento);
					}
				} catch (NoSuchMethodException e) {
					throw new IllegalArgumentException(
							"Il metodo richiesto non è stato trovato, controlla il nome del campo Key inserito: "
									+ nomeCampoKey + e);
				} catch (IllegalAccessException e) {
					throw new IllegalArgumentException(
							"errore in lettura campi di " + elemento.getClass()
									+ ":" + e);
				} catch (InvocationTargetException e) {
					throw new IllegalArgumentException(
							"errore in lettura campi di " + elemento.getClass()
									+ ":" + e);
				}
			}
		}
		return res;
	}
	
	/**
	 * Effettua un clone ricorsivo delle strutture dati in input.
	 * Il clone viene fatto tramite serializzazione in memory e successiva deserializzazione.
	 */
	public static Object deepClone(Object orig)
			throws CloneNotSupportedException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos;
		try {
			oos = new ObjectOutputStream(baos);
			oos.writeObject(orig);
			ByteArrayInputStream bais = new ByteArrayInputStream(
					baos.toByteArray());
			ObjectInputStream ois = new ObjectInputStream(bais);
			Object clone = ois.readObject();
			return clone;
		} catch (IOException e) {
			throw new CloneNotSupportedException();
		} catch (ClassNotFoundException e) {
			throw new CloneNotSupportedException();
		}
	}
}
«ENDFILE»
«ENDDEFINE»

