«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT guigen»

«IMPORT template::struts2::actionImplJavaFiles»
«IMPORT template::struts2::security»
«IMPORT template::struts2::typeConversion»
«IMPORT template::struts2::eventHandlers»
«IMPORT template::struts2::controller::dataProvider»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«REM»
==========================================================================================================================
STRUTS2 ACTIONS FILES
===========================================================================================================================
«ENDREM»

«REM»
Genera una Base Action Struts2 che contiene gli elementi comuni all'applicazione.
Tutte le altre Action dell'applicazione dovranno ereditare da questa
in modo da ottenere le parti comuni, e dovranno implementare in proprio
le funzionalità specifiche della pagina.
«ENDREM»
«DEFINE struts2BaseActionJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsBaseActionJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;
import java.lang.reflect.Method;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;

import org.apache.log4j.Logger;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.Preparable;
import org.apache.struts2.interceptor.SessionAware;
import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.ActionSupport;

import «getBaseJavaPackage(this)».util.*;
import «getDTOBaseJavaPackage(this)».*;
import «getBaseJavaPackage()».business.*;

import «getSecurityJavaPackage(this)».*;

«IF this.targetPlatform.enableRichUIBehavior-»
import «getInterceptorsJavaPackage(this)».FatClientOnly;
import «getUIUtilsJavaPackage(this)».*;
import flexjson.JSON;
«ENDIF-»

«IF hasGisMap()»
import «getDTOBaseJavaPackage(this)».greasemapfacade.*;
import it.csi.jeegia.jeegfw.dto.jeegweb.mappa.OpenLayerMapConfig;
import it.csi.splugesf.jtsutil.utils.json.GeometryTransformer;
import com.vividsolutions.jts.geom.*;
«ENDIF»

/**
 * Base Action che contiene gli elementi comuni all'applicazione.
 * Tutte le altre Action dell'applicazione dovranno ereditare da questa
 * in modo da ottenere le parti comuni, e dovranno implementare in proprio
 * le funzionalit&agrave; specifiche della pagina.
 * <p/>
 * La classe eredita da {@link com.opensymphony.xwork2.ActionSupport} i
 * metodi di utilit&agrave; necessari ad eseguire le principali operazioni
 * (ad esempio conversione, validazione, ecc...) ed implementa l'interfaccia
 * {@link org.apache.struts2.interceptor.SessionAware}, che permette
 * alla Action di accedere alla sessione. 
 * 
 * @author GuiGen
 */
public abstract class «getStrutsBaseActionClassName(this)» <T extends BaseSessionAwareDTO> extends ActionSupport implements SessionAware, Preparable {

	/**  */
	protected static final Logger log =								«noSonarTag("EIAS")» 
	Logger.getLogger(Constants.APPLICATION_CODE + ".presentation"); «noSonarTag("EIAS")»

	/** Riferimento alla sessione corrente */
	protected Map session;

	public void setSession(Map session) {
		this.session = session;
	}
	public Map getSession() {
		return this.session;
	}
	
	private String backActionName;
	
	private String backNamespace;

	
	public void setBackActionName(String value) {
		this.backActionName = value;
	}
	public String getBackActionName() {
		return this.backActionName;
	}

	public void setBackNamespace(String value) {
		this.backNamespace = value;
	}
	public String getBackNamespace() {
		return this.backNamespace;
	}
	
	public void setAppDataNavigationQueue(
			java.util.LinkedList<java.lang.String> value) {
		getSession().put("appDataNavigationQueue", value);
	}

	public java.util.LinkedList<java.lang.String> getAppDataNavigationQueue() {
		return (java.util.LinkedList<java.lang.String>) (getSession()
				.get("appDataNavigationQueue"));
	}
	
	public void setCurrentContentPanel(java.lang.String value) {
		getSession().put("currentContentPanel", value);
	}

	public java.lang.String getCurrentContentPanel() {
		return (java.lang.String) (getSession()
				.get("currentContentPanel"));
	}
	
	«IF hasGisMap(this)»
	public static int ERROR_LEVEL_WARNING = 0;
	public static int ERROR_LEVEL_ERROR = 1;
	public static int ERROR_LEVEL_FATAL = 2;
	public static int ERROR_LEVEL_NO_ERROR = -1;
	«ENDIF»

	
	protected Map<String, UISecConstraint> allMenuVisibilityConstraints = null;
	protected Map<String, UISecConstraint> allMenuOnOffConstraints = null;
	
	
	
	public void prepare() throws CommandExecutionException{
	
		«IF getActualSecurityModel(this)!=null»
	    // caricamento struttura di constraints
	    if (allMenuVisibilityConstraints==null)
	    	allMenuVisibilityConstraints = getMenuVisibilityUIConstraints();
	    if (allMenuOnOffConstraints==null)
	    	allMenuOnOffConstraints = getMenuONOFFUIConstraints();
	
		«ENDIF»
	}
	
    ////////////////////////////////////////////////////////////////////////
    //// costruzione/lettura strato model da passare allo strato di logica
    ////////////////////////////////////////////////////////////////////////
    public abstract Class modelClass();
    
    public abstract T getModel() ;
	
	public abstract void setModel(T t);
	
	public T toModel()  {
		return getModel();
	}

	public void fromModel(T t) {
		setModel(t);	
	}
    
	protected java.lang.reflect.Method findReadMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getReadMethod();
		}
		return null;
	}

	protected java.lang.reflect.Method findWriteMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getWriteMethod();
		}
		return null;
	}

	
    
	///////////////////////////////////
	/**
	 * Metodi per visibilita'/abilitazione dei Widget
	 */
	
	/**
	 * @return true se il widget deve essere reso visibile
	 */
	public boolean isWidgetVisible(String cpName, String widgShortName){
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean visibleFlag=(Boolean)cpData.get(widgShortName+"_visible");
			if (visibleFlag!=null){
				return visibleFlag.booleanValue();
			}
			else
				return true;
		}
		else
			return true;
		
	}
	
	/**
	 * @return true se il widget deve essere disabilitato
	 */
	public boolean isWidgetDisabled(String cpName, String widgShortName){
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean enabledFlag=(Boolean)cpData.get(widgShortName+"_enabled");
			if (enabledFlag!=null){
				return !enabledFlag.booleanValue();
			}
			else
				return false;
		}
		else
			return false;
		
	}


	///////////////////////////////////
	/**
	 * Metodi per visibilita'/abilitazione del menu
	 */

	«IF structure.appWindow.appArea.menubar != null»
	static List<MenuStructure> menuMap = new ArrayList<MenuStructure>();
	static {
		«EXPAND submenuMap FOR structure.appWindow.appArea.menubar»
	}
	«ENDIF»

	
	/**
	 * Metodi per visibilita'/abilitazione dei MenuElemnt
	 */

		
	/**
	 * @return true se il menu deve essere reso visibile
	 */
	public boolean isMenuVisible(String menuName) {
	«IF getActualSecurityModel(this)!=null-»
		UISecConstraint ctr = allMenuVisibilityConstraints.get(menuName);
		boolean status;
		if (ctr!=null){
			try{
				status = ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsBaseActionClassName(this)»::isMenuVisible] errore durante verifica->false");
				return false;
			}
		}
		else
			status = isMenuElementVisible(menuName);
		return status;
	«ELSE-»
		return isMenuElementVisible(menuName);
	«ENDIF-»
	}

	/**
	 * @return true se il MenuElement deve essere reso visibile
	 */
	
	private static final String SESSION_MENU_VISIBILITY = "menuVisibilityMap";
	
	public boolean isMenuElementVisible(String menuName) {
		Map cpData = (Map) session.get(SESSION_MENU_VISIBILITY);
		if (cpData != null) {
			Boolean visibleFlag = (Boolean) cpData.get(menuName
					+ "_visible");
			if (visibleFlag != null) {
				return visibleFlag.booleanValue();
			} else
				return true;
		} else
			return true;

	}
	
	/**
	 * @return true se almeno uno dei sottomenu del menu dato &egrave; vissibile, false altrimenti
	 */
	public boolean isAtLeastOneSubMenuVisible(String menuName) {
		«IF getActualSecurityModel(this) != null»
		MenuStructure menuStructure = searchMenuItem(menuName, menuMap, null);
		List<MenuStructure> mstr = menuStructure.getSubmenus();
		for (MenuStructure subMenu : mstr) {
			if (isMenuVisible(subMenu.getMenuName())) {
				return true;
			}
		}
		return false;
		«ELSE»
		return true;
		«ENDIF»
	}
	«IF getActualSecurityModel(this) != null»
	private MenuStructure searchMenuItem(String menuName,
			List<MenuStructure> menuTmp, MenuStructure menuStructureCurr) {
		MenuStructure res = menuStructureCurr;
		for (MenuStructure menuStructure : menuTmp) {
			if (menuName.equalsIgnoreCase(menuStructure.getMenuName())) 
				return menuStructure;

			res = searchMenuItem(menuName, menuStructure.getSubmenus(), res);
		}

		return res;
	}
	«ENDIF»
	/**
	 * @return true se il menu deve essere reso abilitato
	 */
	public boolean isMenuEnabled(String menuName) {
	«IF getActualSecurityModel(this)!=null-»
		UISecConstraint ctr = allMenuOnOffConstraints.get(menuName);
		boolean status;
		if (ctr!=null){
			try{
				status = ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsBaseActionClassName(this)»::isMenuEnabled] errore durante verifica->false");
				return false;
			}
		}
		else
			status = isMenuElementEnabled(menuName);
		return status;
	«ELSE»
		return isMenuElementEnabled(menuName);
	«ENDIF»
	}
	
	
	private static String SESSION_MENU_ONOFF = "menuOnOffMap";
	
	/**
	 * @return true se il menuElement deve essere disabilitato
	 */
	public boolean isMenuElementEnabled(String menuName) {
		Map cpData = (Map) session.get(SESSION_MENU_ONOFF);
		if (cpData != null) {
			Boolean enabledFlag = (Boolean) cpData.get(menuName
					+ "_enabled");
			if (enabledFlag != null) {
				return enabledFlag.booleanValue();
			} else
				return true;
		} else
			return true;

	}
	
	/**
	 * @return true se il menu deve essere reso attivo (ovvero &grave; stato cliccato)
	 */
	public boolean isMenuActive(String menuName) {
		String menu = "menu_items_" + menuName;
		return menu.equals((String)session.get("active_menu"));
	}

	/**
	 * @return true se un sottomenu del menu dato (a qualunque livello) &egrave; attivo (ovvero &grave; stato cliccato)
	 */
	public boolean isSubMenuActive(String menuName) {
		for (MenuStructure menuStructure : menuMap) {
			if (menuName.equals(menuStructure.getMenuName())) {
				List<MenuStructure> mstr = menuStructure.getSubMenuFlattenList(menuStructure, menuName);
				for (MenuStructure subMenu : mstr) {
					if (isMenuActive(subMenu.getMenuName())) {
						return true;
					}
				}
			}
		}
		return false;
	}


	/**
     * Gestione del reset della paginazione/sorting delle tabelle (Displaytag)
     * @param tableName nome della tabella
     * @return true se bisogna resettare paginazione/sorting, false altrimenti
     */
    public boolean isTableClearStatus(String tableName) {
    	String sessionValue = tableName + "_clearStatus";
    	Boolean clearStatus = (Boolean)session.get(sessionValue);
    	if ( clearStatus == null ) {
    		clearStatus = true;
    	}
    	if ( clearStatus ) {
    		// la proprieta' e' "usa e getta"
    		session.put(sessionValue, Boolean.valueOf(false));
    	}
    	return clearStatus;
    }
	
	«EXPAND provideMenuStatus FOR this»
	
	«IF this.targetPlatform.enableFatClient-»
	«EXPAND provideWidgetsStatus FOR this»
	«EXPAND setWidgetsOnOffStatus FOR this»
	«EXPAND setWidgetsVisibilityStatus FOR this»
	«EXPAND provideMultiPanelStatus FOR this»
	«ENDIF-»

	/**
	 * metodo astratto per il dump visivo del model (da riscrivere nelle action dei singoli
	 * ContentPanel
	 */
	abstract protected void dumpModel(boolean pre);
	
	/**
	 * deve essere ridefinito nelle action relative ai ContentPanel
	 */
	abstract protected void doBeforeEventCommand();
	
	/**
	 * deve essere ridefinito nelle action relative ai ContentPanel
	 */
	abstract protected void doAfterEventCommand();
	
	/**
	 * metodo astratto che deve essere sovrascritto nelle action dei singoli ContentPanel per
	 * l'inizializzazione dei vari comandi presenti nella schermata
	 * @param widgName il nome del widget a cui e' associato l'evento
	 * @param eventName il nome dell'evento (es. CLICKED)
	 */
	abstract protected ICommand initCommand(String widgName, String eventName);
	
«IF targetPlatform.enableRichUIBehavior-»
	«EXPAND getJSONSerializerMethod FOR this»
«ENDIF-»

	/**
	 * Metodo generico per l'esecuzione della logica associata ad un evento
	 * @param widgName il nome del widget a cui e' associato l'evento
	 * @param eventName il nome dell'evento (es. CLICKED)
	 */
	protected String handleEventInternal(String widgName, String eventName)
			throws CommandExecutionException {
		ICommand action = initCommand(widgName, eventName);
		if (log.isDebugEnabled()) {
			log.debug("["+getClass().getName()+"::handle"+widgName+"_"+eventName+"] dump model before");
			dumpModel(false);
		}
		
		// Before event commands...
		doBeforeEventCommand();
		// event commands
		String result = action.doCommand(this);
		// After event commands...
		doAfterEventCommand();

		if (result != null) {
			if (log.isDebugEnabled()) {
				log.debug("["+getClass().getName()+"::handle"+widgName+"_"+eventName+"] dump model after");
				dumpModel(false);
				log.debug("["+getClass().getName()+"::handle"+widgName+"_"+eventName+"] returning result ["
						+ result + "]");
			}

			return result;

		} else {
			if (log.isDebugEnabled()) {
				log.debug("["+getClass().getName()+"::handle"+widgName+"_"+eventName+"] dump model after");
				dumpModel(false);
				log.debug("["+getClass().getName()+"::handle"+widgName+"_"+eventName+"] returning default result [SUCCESS]");
			}
			return SUCCESS;

		}
	}

«IF targetPlatform.enableRichUIBehavior-»
	«EXPAND dataProvider::dataProviderInternalMethod FOR this»
«ENDIF»	

	/**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. Deve essere implementato in tutte le sottoclassi associate
	 *  ad un content panel. 
	 */
	 public abstract void clearPageScopedAppData(String targetContentPanelName);
	 
	 «REM»STDMDD-407«ENDREM»
	 /**
	  * Ripulisce gli eventuali errori di conversione se il metodo richiamato
	  * dichiarava @skipValidation 
	  */
	 protected void clearConversionErrorsIfSkipValidation() {
		ActionContext ctx = ActionContext.getContext();
		String methodName = ctx.getActionInvocation().getProxy().getMethod();
		Method m;
		try {
			boolean skipValidation = true;
			m = this.getClass().getDeclaredMethod(methodName, new Class[]{});
			if (m != null) {
				skipValidation = m.isAnnotationPresent(SkipValidation.class);
			}
			if (skipValidation && !m.getName().equalsIgnoreCase("execute")) {
				removeFailedParamsFromRequest(ctx);
				clearErrorsAndMessages();
			}
		} catch (SecurityException e) {
			log.error("[BaseAction::clearConversionErrorsIfSkipValidation] Errore interno: " + e
					+ ", ignoro");
		} catch (NoSuchMethodException e) {
			log.error("[BaseAction::clearConversionErrorsIfSkipValidation] Errore interno: " + e
					+ ", ignoro");
		}
	}
	
	private void removeFailedParamsFromRequest(ActionContext ctx){
		ctx.getContextMap();
		ctx.getContextMap().remove("original.property.override");
	}
	 
	«EXPAND springBEProperties FOR this»
	
	«IF targetPlatform.enableRichUIBehavior-»
	«EXPAND template::struts2::view::richFeatures::dataProviderStreamProperty FOR this-»
	«ENDIF-»
	
	«IF getActualSecurityModel(this)!=null && structure.appWindow.appArea.menubar!=null»
	«EXPAND template::struts2::security::securityConstraints::getMenuUIConstraintDef(this) FOR structure.appWindow.appArea.menubar»
	«ENDIF»
	
	«IF isMultiPortal(this)»
	«EXPAND template::struts2::multiPortal::baseActionMethods FOR this-»
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE getJSONSerializerMethod FOR GUIModel-»
	protected flexjson.JSONSerializer getJSONSerializer(boolean jtsAware){
		flexjson.JSONSerializer serializer = null;
«IF hasGisMap()-»
		if (jtsAware){
			GeometryTransformer geoTransformer = new GeometryTransformer();
			serializer = new flexjson.JSONSerializer().transform(geoTransformer, Geometry.class);
		}
		else{
			serializer = new flexjson.JSONSerializer();
		}
«ELSE-»
		serializer = new flexjson.JSONSerializer();
«ENDIF-»
		return serializer;
	}
«ENDDEFINE»

«DEFINE springBEProperties FOR GUIModel»
	private «getSpringBEFQN()» _backEnd = null;
	
	public void setSpringBackEnd(«getSpringBEFQN()» be){
		_backEnd = be;
	}
	
	public «getSpringBEFQN()» getSpringBackEnd(){
		return _backEnd;
	}
	
	
	private «getSpringSecurityHelperFQN()» _securityHelper = null;
	
	public void setSpringSecurityHelper(«getSpringSecurityHelperFQN()» sh){
		_securityHelper = sh;
	}
	
	public «getSpringSecurityHelperFQN()» getSpringSecurityHelper(){
		return _securityHelper;
	}
	
«ENDDEFINE»


«REM»
[DM] STDMDD-241: razionalizzazione del menu
Esteso a qualunque livello di annidamento
«ENDREM»
«DEFINE submenuMap FOR Menubar»
«FOREACH this.topLevelMenu AS topLevelMenu»
MenuStructure «topLevelMenu.name»Menu = new MenuStructure("«topLevelMenu.name»");
«EXPAND submenuList FOR topLevelMenu»
menuMap.add(«topLevelMenu.name»Menu);
«ENDFOREACH»
«ENDDEFINE»


«DEFINE submenuList FOR Menu»
«IF this.submenu.size > 0»
	«FOREACH this.submenu AS subMenu-»
	MenuStructure «subMenu.name»Menu = new MenuStructure("«subMenu.name»");
	«EXPAND submenuList FOR subMenu»
	«this.name»Menu.getSubmenus().add(«subMenu.name»Menu);
	«ENDFOREACH-»
«ENDIF»
«ENDDEFINE»

«DEFINE provideMenuStatus FOR GUIModel»
	/**
	 * Restituisce lo stato del menu
	 * @return List<MenuStructure>
	 */
	protected List<MenuStructure> getMenuStatus(){
		
		List<MenuStructure> menus = new ArrayList<MenuStructure>();
		for (MenuStructure menuStructure : menuMap) {
			//***sul fatclient non ho bisogno dello stato attivo per cui lo imposto a false
			menus.add(new MenuStructure(menuStructure.getMenuName(),
					isMenuVisible(menuStructure.getMenuName()),
					isMenuEnabled(menuStructure.getMenuName()), false));

			for (String subMenu : menuStructure.getAllSubMenu()) {

				menus.add(new MenuStructure(subMenu, isMenuVisible(subMenu),
						isMenuEnabled(subMenu), false));

			}
		}
		return menus;
	}
«ENDDEFINE»

«DEFINE provideWidgetsStatus FOR GUIModel»
	/**
	 * restituisce lo stato di tutti i widgets presenti nel contentpanel
	 */
	protected List<WidgetsStructure> getWidgetsStatus(List<String> listaWidgets,
			String cpName) {
		List<WidgetsStructure> widgets = new ArrayList<WidgetsStructure>();
		for (String widget : listaWidgets) {
			widgets.add(new WidgetsStructure(widget, isWidgetVisible(cpName, widget), isWidgetDisabled(cpName,widget)));
		}
		return widgets;
	}
«ENDDEFINE»

«DEFINE provideMultiPanelStatus FOR GUIModel»
	/**
	 * restituisce i pannelli attivi nel contentPanel
	 */
	protected List<MultiPanelStructure> getMultiPanelStatus(
			List<String> listaMultiPanel, String cpName) {
		List<MultiPanelStructure> widgets = new ArrayList<MultiPanelStructure>();
		for (String panel : listaMultiPanel) {
			widgets.add(new MultiPanelStructure(panel, (String) session.get(cpName+"_"+panel+"_selectedMultiPanel")));
		}
		return widgets;
	}
«ENDDEFINE»

«DEFINE setWidgetsOnOffStatus FOR GUIModel»
	/**
	 * setta lo stato di OnOff dei widgets passati
	 */
	protected void setWidgetsOnOffStatus(String cpName, String[] nomiWidgets, boolean enableWidget) throws CommandExecutionException{
		
		OnOffCommand onOffCmd = new OnOffCommand(
				cpName,
				 nomiWidgets,
				enableWidget);
		onOffCmd.doCommand(this);
				
	}
«ENDDEFINE»

«DEFINE setWidgetsVisibilityStatus FOR GUIModel»
	/**
	 * setta lo stato di visibility dei widgets passati
	 */
	protected void setWidgetsVisibilitytatus(String cpName, String[] nomiWidgets, boolean showWidget) throws CommandExecutionException{
		
		VisibilityCommand visibilityCmd = new VisibilityCommand(
				cpName,
				 nomiWidgets,
				showWidget);
		visibilityCmd.doCommand(this);
				
	}
«ENDDEFINE»