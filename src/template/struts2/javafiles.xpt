«IMPORT guigen»

«IMPORT template::struts2::actionImplJavaFiles»
«IMPORT template::struts2::security»
«IMPORT template::struts2::typeConversion»
«IMPORT template::struts2::eventHandlers»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»


«DEFINE javaFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND applicationConstantsJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2BaseActionJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2MenuJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2HomeJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2LogoutJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND sessionListenerJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::actionCommands::actionImplClasses FOR this»
	«EXPAND template::struts2::model::modelJavaFiles::modelClasses FOR this»
	«EXPAND template::struts2::model::modelJavaFiles::springBEClasses FOR this»
	«EXPAND strutsCustomValidatorsJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND strutsCustomDecoratorsJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND security::securityJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::conversionClassesFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::decoratorsClassesFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::comparatorsClassesFiles(skip_component_dir_creation) FOR this»
	«REM»«EXPAND viewFragmentResultJavaFile FOR this»«ENDREM»
«ENDDEFINE»

«DEFINE sessionListenerJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(skip_component_dir_creation) + "/util/SessionListener.java" »package «getBaseJavaPackage(this)».util;

import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.extraimports")»
«ENDPROTECT»

public class SessionListener implements HttpSessionListener {

	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.attributes")»
	«ENDPROTECT»

  public SessionListener() {
 	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.cntr")»
	«ENDPROTECT»
  }

  public void sessionCreated(HttpSessionEvent se) {
    «PROTECT CSTART '/*' CEND '*/' ID getRegionUID("sessionlistener.created")»
	«ENDPROTECT»
  }

  public void sessionDestroyed(HttpSessionEvent se) {
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("sessionlistener.destroyed")»
	«ENDPROTECT»
  }
}

«ENDFILE»
«ENDDEFINE»

«REM»
==========================================================================================================================
STRUTS2 BASE FILES
===========================================================================================================================
«ENDREM»

«REM»Crea una Base action«ENDREM»
«DEFINE applicationConstantsJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(this, skip_component_dir_creation) + "/util/Constants.java" »package «getBaseJavaPackage(this)».util;

/**
 * <p>Classe delle costanti applicative.</p>
 *
 * @author GuiGen
 */
public final class Constants
{
    /**
     * identificativo dell'applicativo.
     */
    public static final String APPLICATION_CODE = "«codComponente»";
    
    «PROTECT CSTART '/*' CEND '*/' ID getRegionUID("Constants")»
    // Add here your constants
    «ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»


«REM»
Genera una Base Action Struts2 che contiene gli elementi comuni all'applicazione.
Tutte le altre Action dell'applicazione dovranno ereditare da questa
in modo da ottenere le parti comuni, e dovranno implementare in proprio
le funzionalità specifiche della pagina.
«ENDREM»
«DEFINE struts2BaseActionJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsBaseActionJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;

import org.apache.log4j.Logger;
import com.opensymphony.xwork2.Preparable;
import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

import «getBaseJavaPackage(this)».util.*;
import «getDTOBaseJavaPackage(this)».*;
import «getBaseJavaPackage()».business.*;

import «getSecurityJavaPackage(this)».*;

/**
 * Base Action che contiene gli elementi comuni all'applicazione.
 * Tutte le altre Action dell'applicazione dovranno ereditare da questa
 * in modo da ottenere le parti comuni, e dovranno implementare in proprio
 * le funzionalit&agrave; specifiche della pagina.
 * <p/>
 * La classe eredita da {@link com.opensymphony.xwork2.ActionSupport} i
 * metodi di utilit&agrave; necessari ad eseguire le principali operazioni
 * (ad esempio conversione, validazione, ecc...) ed implementa l'interfaccia
 * {@link org.apache.struts2.interceptor.SessionAware}, che permette
 * alla Action di accedere alla sessione. 
 * 
 * @author GuiGen
 */
public abstract class «getStrutsBaseActionClassName(this)» extends ActionSupport implements SessionAware, Preparable {

	/**  */
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE + ".presentation");

	/** Riferimento alla sessione corrente */
	protected Map session;

	public void setSession(Map session) {
		this.session = session;
	}
	public Map getSession() {
		return this.session;
	}

	
	protected Map<String, UISecConstraint> allMenuVisibilityConstraints = null;
	protected Map<String, UISecConstraint> allMenuOnOffConstraints = null;
	
	
	
	public void prepare() throws Exception{
	
		«IF this.securityModel!=null»
	    // caricamento struttura di constraints
	    if (allMenuVisibilityConstraints==null)
	    	allMenuVisibilityConstraints = getMenuVisibilityUIConstraints();
	    if (allMenuOnOffConstraints==null)
	    	allMenuOnOffConstraints = getMenuONOFFUIConstraints();
	
		«ENDIF»
	}
	
    ////////////////////////////////////////////////////////////////////////
    //// costruzione/lettura strato model da passare allo strato di logica
    ////////////////////////////////////////////////////////////////////////
    public abstract Class modelClass();
    
	private java.lang.reflect.Method findReadMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getReadMethod();
		}
		return null;
	}

	private java.lang.reflect.Method findWriteMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getWriteMethod();
		}
		return null;
	}

	public Object toModel() {
		try {
			Object modelObj = modelClass().newInstance();
			// imposto prima di tutto la session per evitare errori nei setter
			// degli oggetti a scope Session
			((BaseSessionAwareDTO)modelObj).setSession(this.getSession());
			BeanInfo targetBI = java.beans.Introspector
					.getBeanInfo(modelClass());
			PropertyDescriptor[] targetPds = targetBI.getPropertyDescriptors();
			for (int i = 0; i < targetPds.length; i++) {
				PropertyDescriptor currTargetPD = targetPds[i];
				java.lang.reflect.Method srcReadMethod = findReadMethod(currTargetPD.getReadMethod().getName(),this.getClass());
				if (srcReadMethod != null) {
					Object srcVal = srcReadMethod.invoke(this, new Object[]{});
					java.lang.reflect.Method currWriteMethod = currTargetPD.getWriteMethod();
					if (currWriteMethod!=null){
						currTargetPD.getWriteMethod().invoke(modelObj,
								new Object[]{srcVal});
					}
				}
			}
			return modelObj;
		} catch (Exception e) {
			log.error("[«getStrutsBaseActionClassName(this)»::toModel] Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e, e);
			throw new IllegalArgumentException(
					"Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);

		}
	}
    
    public void fromModel(Object modelObj) {
		try {
			BeanInfo srcBI = java.beans.Introspector.getBeanInfo(modelClass());
			PropertyDescriptor[] srcPds = srcBI.getPropertyDescriptors();
			for (int i = 0; i < srcPds.length; i++) {
				PropertyDescriptor currSrcPD = srcPds[i];
				java.lang.reflect.Method srcReadMethod = currSrcPD
						.getReadMethod();
				if (srcReadMethod != null) {
					Object srcVal = srcReadMethod.invoke(modelObj,
							new Object[]{});
					java.lang.reflect.Method targetWriteMethod = findWriteMethod(
							currSrcPD.getReadMethod().getName(), this
									.getClass());
					if (targetWriteMethod!=null){
						targetWriteMethod.invoke(this, new Object[]{srcVal});
					}
				}
			}
		} catch (Exception e) {
			log.error("[«getStrutsBaseActionClassName(this)»::fromModel] Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e, e);
			throw new IllegalArgumentException(
					"Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);

		}
	}
    
    
	///////////////////////////////////
	/**
	 * Metodi per visibilita'/abilitazione dei Widget
	 */
	
	/**
	 * @return true se il widget deve essere reso visibile
	 */
	public boolean isWidgetVisible(String cpName, String widgShortName){
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean visibleFlag=(Boolean)cpData.get(widgShortName+"_visible");
			if (visibleFlag!=null){
				return visibleFlag.booleanValue();
			}
			else
				return true;
		}
		else
			return true;
		
	}
	
	/**
	 * @return true se il widget deve essere disabilitato
	 */
	public boolean isWidgetDisabled(String cpName, String widgShortName){
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean enabledFlag=(Boolean)cpData.get(widgShortName+"_enabled");
			if (enabledFlag!=null){
				return !enabledFlag.booleanValue();
			}
			else
				return false;
		}
		else
			return false;
		
	}


	///////////////////////////////////
	/**
	 * Metodi per visibilita'/abilitazione del menu
	 */

	«IF structure.appWindow.appArea.menubar != null»
	static Map<String, List<String>> submenuMap = new HashMap<String, List<String>>();
	static {
		«EXPAND actionImplJavaFiles::submenuMap FOR structure.appWindow.appArea.menubar»
	}
	«ENDIF»

	/**
	 * @return true se il menu deve essere reso visibile
	 */
	public boolean isMenuVisible(String menuName) {
	«IF securityModel!=null-»
		UISecConstraint ctr = allMenuVisibilityConstraints.get(menuName);
		boolean status;
		if (ctr!=null){
			try{
				status = ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsBaseActionClassName(this)»::isMenuVisible] errore durante verifica->false");
				return false;
			}
		}
		else
			status = true;
		return status;
	«ELSE-»
		return true;
	«ENDIF-»
	}

	/**
	 * @return true se almeno uno dei sottomenu del menu dato &egrave; vissibile, false altrimenti
	 */
	public boolean isAtLeastOneSubMenuVisible(String menuName) {
	«IF securityModel != null»
		List<String> subMenuList = submenuMap.get(menuName);
		if ( subMenuList != null ) {
			for (String subMenu : subMenuList) {
				if (isMenuVisible(subMenu)) {
					return true;
				}
			}
		}
		return false;
	«ELSE»
		return true;
	«ENDIF»
	}

	/**
	 * @return true se il menu deve essere reso abilitato
	 */
	public boolean isMenuEnabled(String menuName) {
	«IF securityModel!=null-»
		UISecConstraint ctr = allMenuOnOffConstraints.get(menuName);
		boolean status;
		if (ctr!=null){
			try{
				status = ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
			}
			catch(BEException ex){
				log.error("[«getStrutsBaseActionClassName(this)»::isMenuEnabled] errore durante verifica->false");
				return false;
			}
		}
		else
			status = true;
		return status;
	«ELSE»
		return true;
	«ENDIF»
	}
	
	/**
	 * @return true se il menu deve essere reso attivo (ovvero &grave; stato cliccato)
	 */
	public boolean isMenuActive(String menuName) {
		String menu = "menu_items_" + menuName;
		return menu.equals((String)session.get("active_menu"));
	}

	/**
	 * @return true se un sottomenu del menu dato (a qualunque livello) &egrave; attivo (ovvero &grave; stato cliccato)
	 */
	public boolean isSubMenuActive(String menuName) {
		List<String> subMenuList = submenuMap.get(menuName);
		if ( subMenuList != null ) {
			for ( String subMenu : subMenuList ) {
				if ( isMenuActive(subMenu) ) {
					return true;
				}
				if ( isSubMenuActive(subMenu) ) {
					return true;
				}
			}
		}
		return false;
	}


	/**
     * Gestione del reset della paginazione/sorting delle tabelle (Displaytag)
     * @param tableName nome della tabella
     * @return true se bisogna resettare paginazione/sorting, false altrimenti
     */
    public boolean isTableClearStatus(String tableName) {
    	String sessionValue = tableName + "_clearStatus";
    	Boolean clearStatus = (Boolean)session.get(sessionValue);
    	if ( clearStatus == null ) {
    		clearStatus = true;
    	}
    	if ( clearStatus ) {
    		// la proprieta' e' "usa e getta"
    		session.put(sessionValue, new Boolean(false));
    	}
    	return clearStatus;
    }
	

	/**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. Deve essere implementato in tutte le sottoclassi associate
	 *  ad un content panel.
	 */
	 public abstract void clearPageScopedAppData();
	 
	«EXPAND actionImplJavaFiles::springBEProperties FOR this»
	
	«IF securityModel!=null && structure.appWindow.appArea.menubar!=null»
	«EXPAND security::getMenuUIConstraintDef(this) FOR structure.appWindow.appArea.menubar»
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»


«REM»Genera una Action Struts2 per mappare il menu.«ENDREM»
«DEFINE struts2MenuJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsMenuJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(this)».*;
import «getBaseJavaPackage()».business.*;

/**
 * «getStrutsMenuClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsMenuClassName(this)» extends «getStrutsBaseActionClassName(this)» {

	«EXPAND actionImplJavaFiles::storedAppDataProperties(this) FOR this.structure.appWindow.appArea.menubar»
	
	
	/**
	 * classe model associata
	 */
	public Class modelClass(){
		return «getModelDTOFQN(null, true, false, this)».class;
	}
	 
	/**
	 *
	 * @return Il risultato delle azioni, SUCCESS altrimenti.
	 */
	@SkipValidation
	public String execute() throws Exception {
		return SUCCESS;
	}

	«FOREACH this.structure.appWindow.appArea.menubar.topLevelMenu AS tlmenu»
		«IF tlmenu.eventHandler!=null»
	/**
	 * 
	 * @return SUCCESS result.
	 */
	public String goTo«tlmenu.name.toFirstUpper()»() throws Exception{
	    
		// gestione degli eventi di tipo CLICKED
		ICommand action = initCommand("«tlmenu.name»","CLICKED");
		String result = action.doCommand(this);
		if (result != null) {
			if (log.isDebugEnabled()){
				log.debug("[«getStrutsMenuClassName(this)»::goTo«tlmenu.name.toFirstUpper()»] returning result [" + result + "]");
			}
			setActiveMenu("«tlmenu.name»");
			return result;
		} else {
			if (log.isDebugEnabled()){
				log.debug("[«getStrutsMenuClassName(this)»::goTo«tlmenu.name.toFirstUpper()»] returning default result [SUCCESS]");
			}
			setActiveMenu("«tlmenu.name»");
			return SUCCESS;
		}
	}		
		«ENDIF»
		
		«FOREACH (List[Menu])getAllMenuRecursive(tlmenu) AS currMenu»
		«IF currMenu.eventHandler.eventType == EventTypes::CLICKED»
		«LET currMenu.eventHandler.command AS currAction»
	/**
	 * 
	 * @return SUCCESS result.
	 */
	public String goTo«currMenu.name.toFirstUpper()»() throws Exception{
	    
		// gestione degli eventi di tipo CLICKED
		ICommand action = initCommand("«currMenu.name»","CLICKED");
		String result = action.doCommand(this);
		if (result != null) {
			if (log.isDebugEnabled()){
				log.debug("[«getStrutsMenuClassName(this)»::goTo«currMenu.name.toFirstUpper()»] returning result [" + result + "]");
			}
			setActiveMenu("«currMenu.name»");
			return result;
		} else {
			if (log.isDebugEnabled()){
				log.debug("[«getStrutsMenuClassName(this)»::goTo«currMenu.name.toFirstUpper()»] returning default result [SUCCESS]");
			}
			setActiveMenu("«currMenu.name»");
			return SUCCESS;
		}
	}

		«ENDLET»
		«ENDIF»
		«ENDFOREACH»		
		
		
	«ENDFOREACH»

    public static final String ACTIVE_MENU_ATTRNAME = "active_menu";
    
	public void setActiveMenu(String menuName){
		session.put(ACTIVE_MENU_ATTRNAME, "menu_items_" + menuName);
	}
	
    «EXPAND template::struts2::controller::eventHandlers::actionStructureInit(this) FOR this.structure.appWindow.appArea.menubar»
    
    
   	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsMenuClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}
    
    /**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. 
	 */
	 public void clearPageScopedAppData(){
	 	// non sapendo quale content panel si sta abbandonando vengono rimossi tutti
	 	// gli appdata a scope PAGE
	 	«FOREACH this.structure.appWindow.appArea.contentPanels.appData.select(ad|ad.lifetimeExtent==DataLifetimeType::SAME_PAGE) AS currAD»
	 	getSession().remove("«getAppDataKey(currAD)»");
	 	«ENDFOREACH»
	 }
}
«ENDFILE»
«ENDDEFINE»


«REM»Genera la Action di Struts che gestisce la Home Page«ENDREM»
«DEFINE struts2HomeJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsHomeJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(this)».*;

/**
 * «getStrutsHomeClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsHomeClassName(this)» extends «getStrutsBaseActionClassName(this)» {

	«IF this.structure.appWindow.appArea.onInitCommand != null»
    «EXPAND actionImplJavaFiles::storedAppDataProperties(this) FOR this.structure.appWindow.appArea.onInitCommand»
    «ENDIF»
    
    /**
	 * classe model associata
	 */
	public Class modelClass() {
		«IF this.structure.appWindow.appArea.onInitCommand != null»
		return «getModelDTOFQN(null, false, true, this)».class;
		«ELSE»
		return java.lang.Object.class;
		«ENDIF»
	}
    
    
    «IF this.structure.appWindow.appArea.onInitCommand != null»
	/**
	 *
	 * @return Il risultato delle azioni, SUCCESS altrimenti.
	 */
	public String execute() throws Exception {
		
		log.debug("[«getStrutsHomeClassName(this)»::execute] START");
		
		ICommand action = initCommand();
		String result = action.doCommand(this);
		if (result != null) {
			return result;
		} else {
			log.debug("[«getStrutsHomeClassName(this)»::execute] END");
			return SUCCESS;
		}
	}
	«ENDIF»


	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsHomeClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}

	/**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. 
	 */
	 public void clearPageScopedAppData(){
	 	// TODO: nel caso dell'on-init command non si ha ancora un 
	 	// "content panel corrente" -> NOP
	 }

	«LET this.structure.appWindow.appArea.onInitCommand AS onInitAction»
	«IF onInitAction != null»
    «EXPAND template::struts2::controller::eventHandlers::actionStructureInit1(this) FOR onInitAction»
    «ENDIF»
	«ENDLET»
}
«ENDFILE»
«ENDDEFINE»


«REM»Genera la Action di Struts che gestisce l'azione di Logout«ENDREM»
«DEFINE struts2LogoutJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsLogoutJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;

import «getDTOBaseJavaPackage(this)».*;

/**
 * «getStrutsLogoutClassName(this)» Action Class.
 *
 * @author GuiGen
 */
public class «getStrutsLogoutClassName(this)» extends «getStrutsBaseActionClassName(this)» {

    
    /**
	 * nessuna classe model associata
	 */
	public Class modelClass() {
		return null;
	}
    
    
	/**
	 * Mostra la pagina di conferma del logout
	 * @return SSO_LOGOUT.
	 */    
    public String confirmLogout() throws Exception {
    	return "confirmLogout";
    }
    
    
	/**
	 *
	 * @return SSO_LOGOUT.
	 */
	public String ssoLogout() throws Exception {
		
		log.debug("[«getStrutsLogoutClassName(this)»::ssoLogout] START");
		
		invalidateLocalSession();
		log.debug("[«getStrutsLogoutClassName(this)»::ssoLogout] START");
		return "SSO_LOGOUT";
	}

	
	/**
	 *
	 * @return LOCAL_LOGOUT.
	 */
	public String localLogout() throws Exception {
		
		log.debug("[«getStrutsLogoutClassName(this)»::localLogout] START");
		invalidateLocalSession();
		log.debug("[«getStrutsLogoutClassName(this)»::localLogout] START");
		return "LOCAL_LOGOUT";
	}

	«IF securityModel!=null && securityModel.autenticationMethod!=null-»
		«EXPAND invalidateLocalSession(this) FOR this.securityModel.autenticationMethod-»
	«ELSE-»
		«EXPAND invalidateLocalSessionNoAuth FOR this-»
	«ENDIF-»
	
	/**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. 
	 */
	public void clearPageScopedAppData() {
		//NOP
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE invalidateLocalSession(GUIModel model) FOR AutenticationMethod»
«ERROR ""+this+ "non supportato"»
«ENDDEFINE»

«DEFINE invalidateLocalSessionNoAuth FOR GUIModel»
	protected void invalidateLocalSession(){
		/// NOP
	}
«ENDDEFINE»


«DEFINE invalidateLocalSession(GUIModel model) FOR OPAUTHSSO»
	/**
	 * Invalida gli attributi di autenticazione contenuti in sessione
	 */
	protected void invalidateLocalSession(){
		session.remove(«getIrideIdAdapterFilterFQN(model)».AUTH_ID_MARKER);
		session.remove(«getIrideIdAdapterFilterFQN(model)».IRIDE_ID_SESSIONATTR);
	}
«ENDDEFINE»

«DEFINE invalidateLocalSession(GUIModel model) FOR SSOBARTSSO»
	/**
	 * Invalida gli attributi di autenticazione contenuti in sessione
	 */
	protected void invalidateLocalSession(){
		session.remove(«getIrideIdAdapterFilterFQN(model)».AUTH_ID_MARKER);
		session.remove(«getIrideIdAdapterFilterFQN(model)».IRIDE_ID_SESSIONATTR);
	}
«ENDDEFINE»

«DEFINE invalidateLocalSession(GUIModel model) FOR ShibbolethSSO»
	/**
	 * Invalida gli attributi di autenticazione contenuti in sessione
	 */
	protected void invalidateLocalSession(){
		session.remove(«getIrideIdAdapterFilterFQN(model)».IRIDE_ID_SESSIONATTR);
	}
«ENDDEFINE»

«REM»
==========================================================================================================================
STRUTS2 ACTIONS FILES
===========================================================================================================================
«ENDREM»

«REM»Mappa un ContentPanel con una Action Struts«ENDREM»
«DEFINE actionJavaFile(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FILE getStrutsActionJavaFile(this, model, skip_component_dir_creation)»package «getPresentationJavaPackage(model)+getAppModuleAsPkg(this, true, false)»;

«IF hasFileUpload(this)»import java.io.File;«ENDIF»
import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(model)».*;

import «getSecurityJavaPackage(model)».*;

import «getBaseJavaPackage(model)».business.*;

import «getBaseJavaPackage(model)».presentation.«model.codComponente.toLowerCase()».action.*;

/**
 * «getStrutsActionClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsActionClassName(this)» extends «getStrutsBaseActionClassName(model)» 
	implements Preparable{

    «EXPAND actionImplJavaFiles::widgetsProperties(model, true) FOR this»
	«EXPAND actionImplJavaFiles::storedAppDataProperties(model, true) FOR this»
	«EXPAND actionImplJavaFiles::commonProperties FOR this»
	/**
	 * classe model associata
	 */
	public Class modelClass(){
		return «getModelDTOFQN(this, false, false, model)».class;
	}
 
 	«LET getAllEventSourceWidgets() AS allEventSources»
	«REM»«LET allEventSources.select(w|((Widget)w).eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size>0) AS allClickSources»«ENDREM»
	/**
	 * I singoli eventi sui singoli widget sono gestiti dai metodi specifici
	 * @return SUCCESS.
	 */
	@SkipValidation
	public String execute() throws Exception {
		return SUCCESS;
	}
	
	«LET allEventSources.typeSelect(TabSwitcher) AS allTabSwitchers-»
	«IF allTabSwitchers.size>0-»
	//////////////////////////////////////////////////////////////////////////////////
	/// metodi specifici per la gestione del click sui Tab
	/// contenuto nel contentPanel
	/// metodo: handle<id_completo_tab_item>_CLICKED
	/// 
	//////////////////////////////////////////////////////////////////////////////////
	
	«FOREACH allTabSwitchers AS currTabSwitcher-»
	«LET (TabSetPanel)(currTabSwitcher.eContainer) AS currTabSet-»
	
	«REM»TODO PANELDEF: trasformare in define ricorsive«ENDREM»
	«FOREACH currTabSet.panels AS currTab-»
		«EXPAND template::struts2::controller::eventHandlers::tabSwitcherClickForTabHandler(currTabSet, this, "") FOR currTab»
	«ENDFOREACH-»
	«ENDLET-»
	«ENDFOREACH-»
	
	«ENDIF-»
	«ENDLET-»
	
	//////////////////////////////////////////////////////////////////////////////////
	/// metodi specifici per la gestione del singolo tipo di evento sul singolo widget
	/// contenuto nel contentPanel
	/// metodo: handle<nomeWidget>_<NOME_EVENTO>
	/// es: handletreeVoci_CLICKED
	//////////////////////////////////////////////////////////////////////////////////
	«FOREACH allEventSources AS currEventSource»
	«LET (Widget)currEventSource AS currEventWidget»
	«REM»TODO PANELDEF: trasformare in define ricorsive«ENDREM»
	«FOREACH currEventWidget.eventHandlers AS currEventHandler»
		«EXPAND template::struts2::controller::eventHandlers::handlerMethod(currEventWidget, this, "") FOR currEventHandler»
	«ENDFOREACH»
	«ENDLET»
	«ENDFOREACH»
	
	«ENDLET»
	
	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsActionClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}
	
	
	protected Map<String, UISecConstraint> allVisibilityConstraints = null;
	protected Map<String, UISecConstraint> allOnOffConstraints = null;
	
	
	/**
	 * Metodo di preparazione della schermata/action
	 */
	public void prepare() throws Exception{
	    super.prepare();
	    
	    // caricamento struttura di constraints
	    if (allVisibilityConstraints==null)
	    	allVisibilityConstraints = getPageVisibilityUIConstraints();
	    if (allOnOffConstraints==null)
	    	allOnOffConstraints = getPageONOFFUIConstraints();
	    
		«IF defaultState!=null-»
		«EXPAND defaultStateCode FOR this»
		«ENDIF-»
		      
		«IF this.onRefreshCommand!=null»
		// comandi eseguiti ad ogni refresh
		ICommand cmd = initOnRefreshCommand();
		String res= cmd.doCommand(this);
		«ENDIF»
	}
	
	
	«EXPAND security::securedWidgetCheck(model) FOR this»

	
	«LET this.onRefreshCommand AS onRefreshAction»
	«IF onRefreshAction != null»
    «EXPAND template::struts2::controller::eventHandlers::actionStructureInit2(model, this) FOR onRefreshAction»
    «ENDIF»
	«ENDLET»
	
	
	«EXPAND security::getPageUIConstraintDef(model) FOR this»
	
	
	/**  */
	void dumpModel(boolean pre) {
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] START");
			
		
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] #### DUMP del model della action "+this.getClass()+(pre?" prima dell'azione":" dopo l'azione"));
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] [a] campi pubblici del model");
		try {
			java.beans.BeanInfo bi = java.beans.Introspector.getBeanInfo(this.getClass());
			java.beans.PropertyDescriptor[] props = bi.getPropertyDescriptors();
			for (int i = 0; i < props.length; i++) {
				java.beans.PropertyDescriptor pd = props[i];
				java.lang.reflect.Method m = pd.getReadMethod();
				if (m != null) {
					Object pval = m.invoke(this, new Object[]{});
					log.debug("[«getStrutsActionClassName(this)»::dumpmodel] "+pd.getName() + ":" + pval);
				}
			}
		}
		catch(Exception e) {
			log.error("[«getStrutsActionClassName(this)»::dumpmodel] Errore nel dump"+e+", ignoro");
		}
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] [b] stato dei widget");
		Object cpWidgetStatus = session.get("«this.name»");
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] "+cpWidgetStatus);
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] [c] sessione");
		log.debug("[«getStrutsActionClassName(this)»::dumpmodel] "+session);
	}
	
	/**
	 *	Metodo per la rimozione dalla sessione degli application data a scope
	 *  SAME_PAGE. 
	 */
	 public void clearPageScopedAppData(){
	 	«FOREACH appData.select(ad|ad.lifetimeExtent==DataLifetimeType::SAME_PAGE) AS currAd-»
	 	getSession().remove("«getAppDataKey(currAd)»");
	 	«ENDFOREACH-»
	 }

	«REM»Espande la struttura della InitAction«ENDREM»
    «EXPAND template::struts2::controller::eventHandlers::actionStructureInit(model) FOR this»
    
    @SkipValidation
    public String handleChangeTab() throws Exception {
		if (this.hasActionErrors() || this.hasFieldErrors() || this.hasErrors())
			return INPUT;
		else{
			session.put(selectedTabKey, selectedTabValue);
			return SUCCESS;
		}
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE defaultStateCode FOR ContentPanel»
	// gestione dello stato di default
	if (getSession().get("«name»_currentState")==null){
	// Screen State Command begin
    //prepara i nomi dei componenti target da abilitare/disabilitare
    String[] default_widgets_on = new String[]{
    «FOREACH defaultState.widgetsOn AS currWidgOn SEPARATOR ","-»
    "«currWidgOn.name»"
    «ENDFOREACH-»
    };
    
    String[] default_widgets_off = new String[]{
    «FOREACH findAllWidgetsInContentPanel().select(w| !defaultState.widgetsOn.contains(w)) AS currWidgOff SEPARATOR ","-»
    "«((Widget)currWidgOff).name»"
    «ENDFOREACH-»
    };
    
    String[] default_widgets_show = new String[]{
    «FOREACH defaultState.widgetsVisible AS currWidgVisible SEPARATOR ","-»
    "«currWidgVisible.name»"
    «ENDFOREACH-»
    };
    
    String[] default_widgets_hide = new String[]{
    «FOREACH findAllWidgetsInContentPanel().select(w| !defaultState.widgetsVisible.contains(w)) AS currWidgHidden SEPARATOR ","-»
    "«((Widget)currWidgHidden).name»"
    «ENDFOREACH-»
    };
    
	ScreenStateCommand defaultScreenStateCmd = new ScreenStateCommand(
		"«name»",null, 
		default_widgets_on,
		default_widgets_off,
		default_widgets_show,
		default_widgets_hide);
	//Screen State Command end
	
	defaultScreenStateCmd.doCommand(this);
	}
	
«ENDDEFINE»

«REM»
==========================================================================================================================
STRUTS2 CUSTOM DECORATORS CLASSES
===========================================================================================================================
«ENDREM»
«DEFINE strutsCustomDecoratorsJavaFiles(boolean skip_component_dir_creation) FOR GUIModel»

	«REM»Validatori custom definiti dal generatore«ENDREM»
	«FOREACH (List[ContentPanel])getAllContentPanels(this) AS currCP»
		«LET findAllWidgetsInContentPanel(currCP).typeSelect(Table) AS allTables»
			«EXPAND tableDecoratorJavaFile(this) FOREACH allTables»
		«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE tableDecoratorJavaFile(GUIModel model) FOR Table»
«IF customDecorator»
«FILE getTableDecoratorJavaFile(model, this)»package «getPresentationRootJavaPackage(model)+".decorator"+getAppModuleAsPkg(findParentContentPanel(this),true,false)»;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getTableDecoratorClassName(this)+"Decorator.import")»
/// inserire qui eventuali import aggiuntive
«ENDPROTECT»

import org.displaytag.decorator.TableDecorator;

public class «getTableDecoratorClassName(this)» extends TableDecorator {

	
	public «getTableDecoratorClassName(this)»() {
		super();
		
	}

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getTableDecoratorClassName(this)+"Decorator.body")»
    /// Questo spazio e' destinato alla definizione del Decorator.
    /// La documentazione sull'utilizzo dei decoratori della display tag e' disponibile all'url:
    /// http://displaytag.sourceforge.net/1.2  
«ENDPROTECT»

}

«ENDFILE»
«ENDIF»
«ENDDEFINE»



«REM»
==========================================================================================================================
STRUTS2 CUSTOM VALIDATORS CLASSES
===========================================================================================================================
«ENDREM»

«REM»Crea le classi dei validatori custom di Struts 2 definiti«ENDREM»
«DEFINE strutsCustomValidatorsJavaFiles(boolean skip_component_dir_creation) FOR GUIModel»

	«REM»Validatori custom definiti dal generatore«ENDREM»
	«EXPAND strutsCsiDateValidatorJavaFile(skip_component_dir_creation) FOR this»
	
	«REM»Validatori custom modellati dall'utente«ENDREM»
	«FOREACH (List[String])getUserCustomValidatorsName() AS currValidator»
		«EXPAND strutsCustomValidatorJavaFile(currValidator, skip_component_dir_creation) FOR this»
	«ENDFOREACH»

«ENDDEFINE»


«REM»Crea la struttura di un validatore custom di Struts 2 come definito dall'utente. 
Spettera' all'utente inserire nelle regioni protette il codice del validatore«ENDREM»
«DEFINE strutsCustomValidatorJavaFile(String validatorName, boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsCustomValidatorJavaFile(validatorName, this, skip_component_dir_creation)»package «getValidationJavaPackage(this)»;

import com.opensymphony.xwork2.validator.ValidationException;
import com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".import")»
/* Inserire qui gli altri import necessari al validatore */
«ENDPROTECT»

/**
 * «validatorName.toUpperCase()» Custom Validation Class.
 *
 * @author GuiGen
 */
public class «validatorName.toUpperCase()» extends FieldValidatorSupport {

	@Override
	public void validate (Object object) throws ValidationException {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".validate")»
		/* Inserire qui il codice che implementa la logica del validatore */
		
		// nome del campo
		String fieldName = getFieldName();

		// valore del campo, come generico Object da castare nel tipo desiderato/atteso
		Object value = this.getFieldValue(fieldName, object);

		«ENDPROTECT»
	}
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".other")»
	/* Inserire qui proprieta' e metodi del validatore */
	«ENDPROTECT»
}
«ENDFILE»
«ENDDEFINE»


«REM»Crea un validatore custom di Struts 2 per la gestione delle date«ENDREM»
«DEFINE strutsCsiDateValidatorJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«LET ((List[String])getGuigenCustomValidators()).get(0) AS validatorName»
«FILE getStrutsCustomValidatorJavaFile(validatorName, this, skip_component_dir_creation)»package «getValidationJavaPackage(this)»;

import java.text.SimpleDateFormat;

import com.opensymphony.xwork2.validator.ValidationException;
import com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;

/**
 * Controlla che la data sia nel formato atteso.
 *
 * @author GuiGen
 */
public class «validatorName.toFirstUpper()» extends FieldValidatorSupport {

	/** Formato atteso della data (obbligatorio) */
	private String format;


	public String getFormat() {
		return format;
	}
	public void setFormat(String format) {
		this.format = format;
	}


	public void validate(Object object) throws ValidationException {
		// nome del campo
		String fieldName = getFieldName();

		// valore del campo
		String value = (String) this.getFieldValue(fieldName, object);

		if ( format == null || format.trim().length() == 0 ) {
			throw new ValidationException("Nessun formato specificato");
		} else {
			if ( value != null && value.trim().length() > 0 ) {
				SimpleDateFormat sdf = new SimpleDateFormat(format);
				try {
					sdf.parse(value);
				} catch (Exception e) {
					addFieldError(fieldName, object);
				}
			}
		}
	}

}
«ENDFILE»
«ENDLET»
«ENDDEFINE»

«REM»
«DEFINE viewFragmentResultJavaFile FOR GUIModel»
«FILE getViewFragResultJavaFile(true)»package «getResultJavaPackage()»;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;
import java.util.Map;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;


import org.apache.log4j.Logger;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.ServletDispatcherResult;
import org.apache.struts2.views.util.UrlHelper;

import sun.security.action.GetLongAction;

import com.opensymphony.xwork2.ActionInvocation;



public class «getViewFragResultClassName()» extends ServletDispatcherResult{
	public class DummyServletOutputStream extends ServletOutputStream{

		@Override
		public void write(int b) throws IOException {
			System.out.print((char)b);
			
		}
		
	}
	
	public class DummyResponse implements ServletResponse{

		public void flushBuffer() throws IOException {
			// TODO Auto-generated method stub
			
		}

		public int getBufferSize() {

			return bufferSize;
		}

		String characterEncoding=null;
		
		public String getCharacterEncoding() {

			return characterEncoding;
		}

		public String getContentType() {

			return contentType;
		}

		public Locale getLocale() {
			
			return locale;
		}

		public ServletOutputStream getOutputStream() throws IOException {
		 System.out.println("gertOutputStream");
			return new DummyServletOutputStream();
		}

		public PrintWriter getWriter() throws IOException {
			System.out.println("getWriter");
			return new PrintWriter(System.out);
		}

		public boolean isCommitted() {
			// TODO Auto-generated method stub
			return false;
		}

		public void reset() {
			// TODO Auto-generated method stub
			
		}

		public void resetBuffer() {
			// TODO Auto-generated method stub
			
		}

		int bufferSize = 1024;
		
		public void setBufferSize(int arg0) {
			bufferSize=arg0;
			
		}

		public void setCharacterEncoding(String arg0) {
			characterEncoding=arg0;
			
		}

		int contentLength;
		public void setContentLength(int arg0) {
			contentLength=arg0;
			
		}

		String contentType;
		public void setContentType(String arg0) {
			contentType=arg0;
			
		}

		Locale locale;
		public void setLocale(Locale arg0) {
			locale=arg0;
			
		}
    	
    }
	public static Logger LOG = Logger.getLogger(ViewFragmentResult.class);

	public «getViewFragResultClassName()»() {
		super();
	}

	public «getViewFragResultClassName()»(String location) {
		super(location);
	}

	@Override
	public void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Forwarding to location " + finalLocation);
        }

        PageContext pageContext = ServletActionContext.getPageContext();

        if (pageContext != null) {
            pageContext.include(finalLocation);
        } else {
            HttpServletRequest request = ServletActionContext.getRequest();
            HttpServletResponse response = ServletActionContext.getResponse();
            RequestDispatcher dispatcher = request.getRequestDispatcher(finalLocation);

            //add parameters passed on the location to #parameters
            // see WW-2120
            if (invocation != null && finalLocation != null && finalLocation.length() > 0
                    && finalLocation.indexOf("?") > 0) {
                String queryString = finalLocation.substring(finalLocation.indexOf("?") + 1);
                Map parameters = (Map) invocation.getInvocationContext().getContextMap().get("parameters");
                Map queryParams = UrlHelper.parseQueryString(queryString);
                if (queryParams != null && !queryParams.isEmpty())
                    parameters.putAll(queryParams);
            }

            // if the view doesn't exist, let's do a 404
            if (dispatcher == null) {
                response.sendError(404, "result '" + finalLocation + "' not found");

                return;
            }

            // If we're included, then include the view
            // Otherwise do forward
            // This allow the page to, for example, set content type
            if (!response.isCommitted() && (request.getAttribute("javax.servlet.include.servlet_path") == null)) {
                request.setAttribute("struts.view_uri", finalLocation);
                request.setAttribute("struts.request_uri", request.getRequestURI());

                ViewFragmentResult.DummyResponse dr  = new  ViewFragmentResult.DummyResponse();
                dr.setBufferSize(response.getBufferSize());
                dr.setCharacterEncoding(response.getCharacterEncoding());
                dr.setContentType(response.getContentType());
                dr.setLocale(response.getLocale());
                
                response.getWriter().write(getLastFinalLocation());
                dr.getWriter().write(getLastFinalLocation());
                System.out.println("\n\nforward:"+getLastFinalLocation());
                dispatcher.forward(request, dr);
            } else {
            	ViewFragmentResult.DummyResponse dr  = new  ViewFragmentResult.DummyResponse();
                dr.setBufferSize(response.getBufferSize());
                dr.setCharacterEncoding(response.getCharacterEncoding());
                dr.setContentType(response.getContentType());
                dr.setLocale(response.getLocale());
                
            	response.getWriter().write(getLastFinalLocation());
            	System.out.println("\n\ninclude:"+getLastFinalLocation());
                dispatcher.include(request, dr);
            }
        }
        
        
    }


}

«ENDFILE»

«ENDDEFINE»
«ENDREM»