«IMPORT guigen»

«IMPORT template::struts2::actionImplJavaFiles»
«IMPORT template::struts2::security»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»

«DEFINE javaFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND applicationConstantsJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2BaseActionJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2MenuJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND struts2HomeJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::actionImplJavaFiles::actionImplClasses FOR this»
	«EXPAND template::struts2::modelJavaFiles::modelClasses FOR this»
	«EXPAND template::struts2::modelJavaFiles::springBEClasses FOR this»
	«EXPAND strutsCustomValidatorsJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND security::securityJavaFiles(skip_component_dir_creation) FOR this»
«ENDDEFINE»


«REM»
==========================================================================================================================
STRUTS2 BASE FILES
===========================================================================================================================
«ENDREM»

«REM»Crea una Base action«ENDREM»
«DEFINE applicationConstantsJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(this, skip_component_dir_creation) + "/util/Constants.java" »package «getBaseJavaPackage(this)».util;

/**
 * <p>Classe delle costanti applicative.</p>
 *
 * @author GuiGen
 */
public final class Constants
{
    /**
     * identificativo dell'applicativo.
     */
    public static final String APPLICATION_CODE = "«codComponente»";
    
    «PROTECT CSTART '/*' CEND '*/' ID getRegionUID("Constants")»
    // Add here your constants
    «ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»


«REM»
Genera una Base Action Struts2 che contiene gli elementi comuni all'applicazione.
Tutte le altre Action dell'applicazione dovranno ereditare da questa
in modo da ottenere le parti comuni, e dovranno implementare in proprio
le funzionalità specifiche della pagina.
TODO: implementare se necessario
«ENDREM»
«DEFINE struts2BaseActionJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsBaseActionJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;

import org.apache.log4j.Logger;
import com.opensymphony.xwork2.Preparable;
import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

import «getBaseJavaPackage(this)».util.*;
import «getDTOBaseJavaPackage(this)».*;
«IF ((GUIModel)(this.eRootContainer)).securityModel!=null-»
import «getSecurityJavaPackage(this)».*;
«ENDIF-»

/**
 * Base Action che contiene gli elementi comuni all'applicazione.
 * Tutte le altre Action dell'applicazione dovranno ereditare da questa
 * in modo da ottenere le parti comuni, e dovranno implementare in proprio
 * le funzionalit&agrave; specifiche della pagina.
 * <p/>
 * La classe eredita da {@link com.opensymphony.xwork2.ActionSupport} i
 * metodi di utilit&agrave; necessari ad eseguire le principali operazioni
 * (ad esempio conversione, validazione, ecc...) ed implementa l'interfaccia
 * {@link org.apache.struts2.interceptor.SessionAware}, che permette
 * alla Action di accedere alla sessione. 
 * 
 * @author GuiGen
 */
public abstract class «getStrutsBaseActionClassName(this)» extends ActionSupport implements SessionAware, Preparable {

	/**  */
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE + ".presentation");

	/** Riferimento alla sessione corrente */
	protected Map session;

	public void setSession(Map session) {
		this.session = session;
	}
	public Map getSession() {
		return this.session;
	}

	«IF securityModel.autenticationMethod!=null»
	protected Map<String, UISecConstraint> allMenuVisibilityConstraints = null;
	protected Map<String, UISecConstraint> allMenuOnOffConstraints = null;
	«ENDIF»
	
	
	public void prepare(){
	«IF securityModel.autenticationMethod!=null»
	    // caricamento struttura di constraints
	    if (allMenuVisibilityConstraints==null)
	    	allMenuVisibilityConstraints = getMenuVisibilityUIConstraints();
	    if (allMenuOnOffConstraints==null)
	    	allMenuOnOffConstraints = getMenuONOFFUIConstraints();
	«ENDIF»
	}
	
    ////////////////////////////////////////////////////////////////////////
    //// costruzione/lettura strato model da passare allo strato di logica
    ////////////////////////////////////////////////////////////////////////
    public abstract Class modelClass();
    
	private java.lang.reflect.Method findReadMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getReadMethod();
		}
		return null;
	}

	private java.lang.reflect.Method findWriteMethod(String name, Class cl)
			throws IntrospectionException {
		name=(name.startsWith("get")||name.startsWith("set") ? name.substring(3)
			:
			name.startsWith("is")? name.substring(2) : name);
		BeanInfo bi = java.beans.Introspector.getBeanInfo(cl);
		PropertyDescriptor[] pds = bi.getPropertyDescriptors();
		for (int i = 0; i < pds.length; i++) {
			PropertyDescriptor currPd = pds[i];
			if (currPd.getName().equalsIgnoreCase(name))
				return currPd.getWriteMethod();
		}
		return null;
	}

	public Object toModel() {
		try {
			Object modelObj = modelClass().newInstance();
			// imposto prima di tutto la session per evitare errori nei setter
			// degli oggetti a scope Session
			((BaseSessionAwareDTO)modelObj).setSession(this.getSession());
			BeanInfo targetBI = java.beans.Introspector
					.getBeanInfo(modelClass());
			PropertyDescriptor[] targetPds = targetBI.getPropertyDescriptors();
			for (int i = 0; i < targetPds.length; i++) {
				PropertyDescriptor currTargetPD = targetPds[i];
				java.lang.reflect.Method srcReadMethod = findReadMethod(currTargetPD.getReadMethod().getName(),this.getClass());
				if (srcReadMethod != null) {
					Object srcVal = srcReadMethod.invoke(this, new Object[]{});
					java.lang.reflect.Method currWriteMethod = currTargetPD.getWriteMethod();
					if (currWriteMethod!=null){
						currTargetPD.getWriteMethod().invoke(modelObj,
								new Object[]{srcVal});
					}
				}
			}
			return modelObj;
		} catch (Exception e) {
			System.out
					.println("Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);
			e.printStackTrace();
			throw new IllegalArgumentException(
					"Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);

		}
	}
    
    public void fromModel(Object modelObj) {
		try {
			BeanInfo srcBI = java.beans.Introspector.getBeanInfo(modelClass());
			PropertyDescriptor[] srcPds = srcBI.getPropertyDescriptors();
			for (int i = 0; i < srcPds.length; i++) {
				PropertyDescriptor currSrcPD = srcPds[i];
				java.lang.reflect.Method srcReadMethod = currSrcPD
						.getReadMethod();
				if (srcReadMethod != null) {
					Object srcVal = srcReadMethod.invoke(modelObj,
							new Object[]{});
					java.lang.reflect.Method targetWriteMethod = findWriteMethod(
							currSrcPD.getReadMethod().getName(), this
									.getClass());
					if (targetWriteMethod!=null){
						targetWriteMethod.invoke(this, new Object[]{srcVal});
					}
				}
			}
		} catch (Exception e) {
			System.out
					.println("Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);
			throw new IllegalArgumentException(
					"Errore interno nella costruzione del modello, classe:"
							+ modelClass() + ": " + e);

		}
	}
    
    
	///////////////////////////////////
	/**
	 * Metodi per visibilità/abilitazione
	 */
	

	/**
	 * @return true se il widget deve essere reso visibile
	 */
	public boolean isWidgetVisible(String cpName, String widgShortName){
		System.out.println("\n\nis visible "+cpName+" "+widgShortName+"\n\n");
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean visibleFlag=(Boolean)cpData.get(widgShortName+"_visible");
			if (visibleFlag!=null){
				return visibleFlag.booleanValue();
			}
			else
				return true;
		}
		else
			return true;
		
	}
	
	/**
	 * @return true se il widget deve essere disabilitato
	 */
	public boolean isWidgetDisabled(String cpName, String widgShortName){
		System.out.println("\n\nis disabled "+cpName+" "+widgShortName+"\n\n");
		Map cpData = (Map)session.get(cpName);
		if (cpData!=null){
			Boolean enabledFlag=(Boolean)cpData.get(widgShortName+"_enabled");
			if (enabledFlag!=null){
				return !enabledFlag.booleanValue();
			}
			else
				return false;
		}
		else
			return false;
		
	}

	/**
	 * @return true se il menu/menuItem deve essere reso visibile
	 */
	public boolean isMenuVisible(String menuName) {
	«IF securityModel!=null-»
		System.out.println("\n\nis visible " + menuName + "\n\n");
		UISecConstraint ctr = allMenuVisibilityConstraints.get(menuName);
		boolean status;
		if (ctr!=null)
			status = ctr.verifyConstraint(session, UISecConstraint.VISIB_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
		else
			status = true;
		return status;
	«ELSE-»
		return true;
	«ENDIF-»
	}

	/**
	 * @return true se il menu/menuItem deve essere reso abilitato
	 */
	public boolean isMenuEnabled(String menuName) {
	«IF securityModel!=null-»
		System.out.println("\n\nis enabled " + menuName + "\n\n");
		UISecConstraint ctr = allMenuOnOffConstraints.get(menuName);
		boolean status;
		if (ctr!=null)
			status = ctr.verifyConstraint(session, UISecConstraint.ONOFF_CONSTRAINED_BEHAVIOR, getSpringSecurityHelper());
		else
			status = true;
		return status;
	«ELSE»
		return true;
	«ENDIF»
	}
	
	«EXPAND actionImplJavaFiles::springBEProperties FOR this»
	
	«IF securityModel!=null && structure.appWindow.appArea.menubar!=null»
	«EXPAND security::getMenuUIConstraintDef(this) FOR structure.appWindow.appArea.menubar»
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»


«REM»
Genera una Action Struts2 per mappare il menu.
TODO: Vedere se è necessario estendere la BaseAction.
«ENDREM»
«DEFINE struts2MenuJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsMenuJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.Validateable;
import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(this)».*;

/**
 * «getStrutsMenuClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsMenuClassName(this)» extends «getStrutsBaseActionClassName(this)» {

	«EXPAND actionImplJavaFiles::storedAppDataProperties(this) FOR this.structure.appWindow.appArea.menubar»
	
	
	/**
	 * classe model associata
	 */
	public Class modelClass(){
		return «getModelDTOFQN(null, true, false, this)».class;
	}
	 
	/**
	 *
	 * @return Il risultato delle azioni, SUCCESS altrimenti.
	 */
	@SkipValidation
	public String execute() throws Exception {
		return SUCCESS;
	}

	«FOREACH this.structure.appWindow.appArea.menubar.topLevelMenu AS tlmenu»
	«FOREACH getAllMenuItemRecursive(tlmenu) AS currMenuItem»
	«IF ((MenuItem)currMenuItem).eventHandler.eventType == EventTypes::CLICKED»
	«LET ((MenuItem)currMenuItem).eventHandler.command AS currAction»
	/**
	 * 
	 * @return SUCCESS result.
	 */
	public String goTo«((MenuItem)currMenuItem).name.toFirstUpper()»() {
		//dumpModel(true); // TODO mettere solo se log=debug
	    
		// gestione degli eventi di tipo CLICKED
		ICommand action = initCommand("«((MenuItem)currMenuItem).name»","CLICKED");
		String result = action.doCommand(this);
		if (result != null) {
			//dumpModel(false);
			//System.out.println("=====> 1 - RETURNING RESULT [" + result + "]");
			setActiveMenu("«((MenuItem)currMenuItem).name»");
			return result;
		} else {
			//dumpModel(false);
			//System.out.println("=====> 2 - RETURNING DEFAULT RESULT {" + SUCCESS + "}");
			setActiveMenu("«((MenuItem)currMenuItem).name»");
			return SUCCESS;
		}
	}

	«ENDLET»
	«ENDIF»
	«ENDFOREACH»
	«ENDFOREACH»

    public static final String ACTIVE_MENU_ATTRNAME = "active_menu";
    
	public void setActiveMenu(String menuName){
		session.put(ACTIVE_MENU_ATTRNAME, "menu_items_" + menuName);
	}
	
    «EXPAND actionImplJavaFiles::actionStructureInit(this) FOR this.structure.appWindow.appArea.menubar»
    
    
   	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsMenuClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}
    
}
«ENDFILE»
«ENDDEFINE»


«DEFINE struts2HomeJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsHomeJavaFile(this, skip_component_dir_creation)»package «getPresentationJavaPackage(this)»;

import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.Validateable;
import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(this)».*;

/**
 * «getStrutsHomeClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsHomeClassName(this)» extends «getStrutsBaseActionClassName(this)» {

	«IF this.structure.appWindow.appArea.onInitCommand != null»
    «EXPAND actionImplJavaFiles::storedAppDataProperties(this) FOR this.structure.appWindow.appArea.onInitCommand»
    «ENDIF»
    
    /**
	 * classe model associata
	 */
	public Class modelClass() {
		«IF this.structure.appWindow.appArea.onInitCommand != null»
		return «getModelDTOFQN(null, false, true, this)».class;
		«ELSE»
		return java.lang.Object.class;
		«ENDIF»
	}
    
    
    «IF this.structure.appWindow.appArea.onInitCommand != null»
	/**
	 *
	 * @return Il risultato delle azioni, SUCCESS altrimenti.
	 */
	public String execute() throws Exception {
		//dumpModel(true); // TODO mettere solo se log=debug
	    
		// gestione degli eventi di tipo CLICKED
		ICommand action = initCommand();
		String result = action.doCommand(this);
		if (result != null) {
			//dumpModel(false);
			//System.out.println("=====> 1 - RETURNING RESULT [" + result + "]");
			return result;
		} else {
			//dumpModel(false);
			//System.out.println("=====> 2 - RETURNING DEFAULT RESULT {" + SUCCESS + "}");
			return SUCCESS;
		}
	}
	«ENDIF»


	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsHomeClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}


	«LET this.structure.appWindow.appArea.onInitCommand AS onInitAction»
	«IF onInitAction != null»
    «EXPAND actionImplJavaFiles::actionStructureInit1(this) FOR onInitAction»
    «ENDIF»
	«ENDLET»
}
«ENDFILE»
«ENDDEFINE»


«REM»
==========================================================================================================================
STRUTS2 ACTIONS FILES
===========================================================================================================================
«ENDREM»

«REM»Mappa un ContentPanel con una Action Struts«ENDREM»
«DEFINE actionJavaFile(GUIModel model, boolean skip_component_dir_creation) FOR ContentPanel»
«FILE getStrutsActionJavaFile(this, model, skip_component_dir_creation)»package «getPresentationJavaPackage(model)»;

import java.util.*;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.Validateable;
import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.*;

import «getDTOBaseJavaPackage(model)».*;
«IF ((GUIModel)(this.eRootContainer)).securityModel!=null-»
import «getSecurityJavaPackage(model)».*;
«ENDIF-»
import «getBaseJavaPackage(model)».business.*;

/**
 * «getStrutsActionClassName(this)» Action Class.
 *
 * @author GuiGen
 */
@Validation()
public class «getStrutsActionClassName(this)» extends «getStrutsBaseActionClassName(model)» 
	implements Preparable{

    «EXPAND actionImplJavaFiles::widgetsProperties(model, true) FOR this»
	«EXPAND actionImplJavaFiles::storedAppDataProperties(model) FOR this»
	«EXPAND actionImplJavaFiles::commonProperties FOR this»
	/**
	 * classe model associata
	 */
	public Class modelClass(){
		return «getModelDTOFQN(this, false, false, model)».class;
	}
 
 	«LET getAllEventSourceWidgets() AS allEventSources»
	«REM»«LET allEventSources.select(w|((Widget)w).eventHandlers.select(eh|eh.eventType==EventTypes::CLICKED).size>0) AS allClickSources»«ENDREM»
	/**
	 * I singoli eventi sui singoli widget sono gestiti dai metodi specifici
	 * @return SUCCESS.
	 */
	@SkipValidation
	public String execute() throws Exception {
		return SUCCESS;
	}
	
	//////////////////////////////////////////////////////////////////////////////////
	/// metodi specifici per la gestione del singolo tipo di evento sul singolo widget
	/// contenuto nel contentPanel
	/// metodo: handle<nomeWidget>_<NOME_EVENTO>
	/// es: handletreeVoci_CLICKED
	//////////////////////////////////////////////////////////////////////////////////
	«FOREACH allEventSources AS currEventSource»
	«LET (Widget)currEventSource AS currEventWidget»
	«FOREACH currEventWidget.eventHandlers AS currEventHandler»
	/**
	 * Gestione dell'evento CLICKED sul widget [«currEventWidget.name»]
	 */
	«IF currEventHandler.skipValidation-»
	@SkipValidation
	«ENDIF-»
	public String «getHandlerMethodName(currEventWidget, currEventHandler)»()
		throws Exception
	{
		ICommand action = initCommand("«(currEventWidget).name»","«currEventHandler.eventType»");
		String result = action.doCommand(this);
		if (result != null) {
			//dumpModel(false);
			//System.out.println("=====> 1 - RETURNING RESULT [" + result + "]");
			return result;
		} else {
			//dumpModel(false);
			//System.out.println("=====> 2 - RETURNING DEFAULT RESULT {" + SUCCESS + "}");
			return SUCCESS;
		}
	}
	«ENDFOREACH»
	«ENDLET»
	«ENDFOREACH»
	
	«ENDLET»
	
	/**
	 * Gestione della validazione
	 */
	public void validate() {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getStrutsActionClassName(this) + "_validate")»
		/* Inserire la validazione */
		«ENDPROTECT»
	}
	
	«IF model.securityModel.autenticationMethod!=null»
	protected Map<String, UISecConstraint> allVisibilityConstraints = null;
	protected Map<String, UISecConstraint> allOnOffConstraints = null;
	«ENDIF»
	
	/**
	 * Metodo di preparazione della schermata/action
	 */
	public void prepare(){
	    super.prepare();
	    «IF model.securityModel.autenticationMethod!=null»
	    // caricamento struttura di constraints
	    if (allVisibilityConstraints==null)
	    	allVisibilityConstraints = getPageVisibilityUIConstraints();
	    if (allOnOffConstraints==null)
	    	allOnOffConstraints = getPageONOFFUIConstraints();
	    «ENDIF»
		      
		«IF this.onRefreshCommand!=null»
		// comandi eseguiti ad ogni refresh
		ICommand cmd = initOnRefreshCommand();
		String res= cmd.doCommand(this);
		System.out.println("onrefreshCommand returned:"+res+", ignoring");
		«ENDIF»
	}
	
	«IF model.securityModel.autenticationMethod!=null»
	«EXPAND security::securedWidgetCheck(model) FOR this»
	«ENDIF»
	
	«LET this.onRefreshCommand AS onRefreshAction»
	«IF onRefreshAction != null»
    «EXPAND actionImplJavaFiles::actionStructureInit2(model) FOR onRefreshAction»
    «ENDIF»
	«ENDLET»
	
	«IF model.securityModel.autenticationMethod!=null»
	«EXPAND security::getPageUIConstraintDef(model) FOR this»
	«ENDIF»
	
	/**  */
	void dumpModel(boolean pre) {
		
		System.out.println("#### DUMP del model della action "+this.getClass()+(pre?" prima dell'azione":" dopo l'azione"));
		System.out.println("[a] campi pubblici del model");
		try {
			java.beans.BeanInfo bi = java.beans.Introspector.getBeanInfo(this.getClass());
			java.beans.PropertyDescriptor[] props = bi.getPropertyDescriptors();
			for (int i = 0; i < props.length; i++) {
				java.beans.PropertyDescriptor pd = props[i];
				java.lang.reflect.Method m = pd.getReadMethod();
				if (m != null) {
					Object pval = m.invoke(this, new Object[]{});
					System.out.println(pd.getName() + ":" + pval);
				}
			}
		}
		catch(Exception e) {
			System.out.println("Errore nel dump"+e);
		}
		System.out.println("[b] stato dei widget");
		Object cpWidgetStatus = session.get("«this.name»");
		System.out.println(""+cpWidgetStatus);
		System.out.println("[c] sessione");
		System.out.println(""+session);
	}
	

	«REM»Espande la struttura della InitAction«ENDREM»
    «EXPAND actionImplJavaFiles::actionStructureInit(model) FOR this»
}
«ENDFILE»
«ENDDEFINE»


«REM»
==========================================================================================================================
STRUTS2 CUSTOM VALIDATORS CLASSES
===========================================================================================================================
«ENDREM»

«REM»Crea le classi dei validatori custom di Struts 2 definiti«ENDREM»
«DEFINE strutsCustomValidatorsJavaFiles(boolean skip_component_dir_creation) FOR GUIModel»

	«REM»Validatori custom definiti dal generatore«ENDREM»
	«EXPAND strutsCsiDateValidatorJavaFile(skip_component_dir_creation) FOR this»
	
	«REM»Validatori custom modellati dall'utente«ENDREM»
	«FOREACH getUserCustomValidatorsName() AS currValidator»
		«EXPAND strutsCustomValidatorJavaFile((String)currValidator, skip_component_dir_creation) FOR this»
	«ENDFOREACH»

«ENDDEFINE»


«REM»Crea la struttura di un validatore custom di Struts 2 come definito dall'utente. 
Spettera' all'utente inserire nelle regioni protette il codice del validatore«ENDREM»
«DEFINE strutsCustomValidatorJavaFile(String validatorName, boolean skip_component_dir_creation) FOR GUIModel»
«FILE getStrutsCustomValidatorJavaFile(validatorName, this, skip_component_dir_creation)»package «getValidationJavaPackage(this)»;

import com.opensymphony.xwork2.validator.ValidationException;
import com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".import")»
/* Inserire qui gli altri import necessari al validatore */
«ENDPROTECT»

/**
 * «validatorName.toUpperCase()» Custom Validation Class.
 *
 * @author GuiGen
 */
public class «validatorName.toUpperCase()» extends FieldValidatorSupport {

	@Override
	public void validate (Object object) throws ValidationException {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".validate")»
		/* Inserire qui il codice che implementa la logica del validatore */
		
		// nome del campo
		String fieldName = getFieldName();

		// valore del campo, come generico Object da castare nel tipo desiderato/atteso
		Object value = this.getFieldValue(fieldName, object);

		«ENDPROTECT»
	}
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(validatorName + ".other")»
	/* Inserire qui proprieta' e metodi del validatore */
	«ENDPROTECT»
}
«ENDFILE»
«ENDDEFINE»


«REM»Crea un validatore custom di Struts 2 per la gestione delle date«ENDREM»
«DEFINE strutsCsiDateValidatorJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«LET getGuigenCustomValidators().get(0) AS validatorName»
«FILE getStrutsCustomValidatorJavaFile((String)validatorName, this, skip_component_dir_creation)»package «getValidationJavaPackage(this)»;

import java.text.SimpleDateFormat;

import com.opensymphony.xwork2.validator.ValidationException;
import com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;

/**
 * Controlla che la data sia nel formato atteso.
 *
 * @author GuiGen
 */
public class «((String)validatorName).toFirstUpper()» extends FieldValidatorSupport {

	/** Formato atteso della data (obbligatorio) */
	private String format;


	public String getFormat() {
		return format;
	}
	public void setFormat(String format) {
		this.format = format;
	}


	public void validate(Object object) throws ValidationException {
		// nome del campo
		String fieldName = getFieldName();

		// valore del campo
		String value = (String) this.getFieldValue(fieldName, object);

		if ( format == null || format.trim().length() == 0 ) {
			throw new ValidationException("Nessun formato specificato");
		} else {
			if ( value != null && value.trim().length() > 0 ) {
				SimpleDateFormat sdf = new SimpleDateFormat(format);
				try {
					sdf.parse(value);
				} catch (Exception e) {
					addFieldError(fieldName, object);
				}
			}
		}
	}

}
«ENDFILE»
«ENDLET»
«ENDDEFINE»
