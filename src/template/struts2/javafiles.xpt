«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT guigen»

«IMPORT template::struts2::actionImplJavaFiles»
«IMPORT template::struts2::security»
«IMPORT template::struts2::typeConversion»
«IMPORT template::struts2::eventHandlers»
«IMPORT template::struts2::interceptor»
«EXTENSION template::GenericExtensions»
«EXTENSION template::struts2::Struts2Extensions»


«DEFINE javaFiles(boolean skip_component_dir_creation) FOR GUIModel»
	«EXPAND applicationConstantsJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND servletStreamJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::common::resourceStreamJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::baseAction::struts2BaseActionJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::baseAction::struts2AbstractCPActionJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::menuAction::struts2MenuJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::homeAction::struts2HomeJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::logoutAction::struts2LogoutJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND sessionListenerJavaFile(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::controller::actionCommands::actionImplClasses FOR this»
	«EXPAND template::struts2::controller::commandFactory::commandFactoryFiles FOR this»
	«EXPAND template::struts2::controller::dispatcher::dispatcherClasses FOR this»
	«EXPAND template::struts2::model::modelJavaFiles::modelClasses FOR this»
	«EXPAND template::struts2::model::businessLogic::springBEClasses FOR this»
	«EXPAND template::struts2::validation::strutsCustomValidatorsJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND template::struts2::view::tableDecorator::strutsCustomDecoratorsJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND security::securityJavaFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::conversionClassesFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::decoratorsClassesFiles(skip_component_dir_creation) FOR this»
	«EXPAND typeConversion::comparatorsClassesFiles(skip_component_dir_creation) FOR this»
	«EXPAND interceptor::interceptorsClassesFiles(skip_component_dir_creation) FOR this»
	«IF targetPlatform.enableRichUIBehavior»
		«EXPAND uiutils::uiutilsClassesFiles(skip_component_dir_creation) FOR this»
	«ENDIF»
	«IF hasGisMap()»
		«EXPAND gisMapScaleDefinitionJavaFile(skip_component_dir_creation) FOR this»
		«EXPAND gisMapManagerJavaFile(skip_component_dir_creation) FOR this»
	«ENDIF»
	«EXPAND beanMappingUtils FOR this»
	«REM»«EXPAND viewFragmentResultJavaFile FOR this»«ENDREM»
	«IF isMultiPortal(this)»
		«EXPAND multiPortal::multiPortalClassesFiles(skip_component_dir_creation) FOR this»
	«ENDIF»
	«IF this.targetPlatform.code==TargetPlatformCodes::JBoss43»
		«EXPAND EncodingFixFilter FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE sessionListenerJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(skip_component_dir_creation) + "/util/SessionListener.java" »package «getBaseJavaPackage(this)».util;

import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.extraimports")»
«ENDPROTECT»

public class SessionListener implements HttpSessionListener {

	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.attributes")»
	«ENDPROTECT»

  public SessionListener() {
 	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("seesionlistener.cntr")»
	«ENDPROTECT»
  }

  public void sessionCreated(HttpSessionEvent se) {
    «PROTECT CSTART '/*' CEND '*/' ID getRegionUID("sessionlistener.created")»
	«ENDPROTECT»
  }

  public void sessionDestroyed(HttpSessionEvent se) {
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("sessionlistener.destroyed")»
	«ENDPROTECT»
  }
}

«ENDFILE»
«ENDDEFINE»

«REM»
==========================================================================================================================
STRUTS2 BASE FILES
===========================================================================================================================
«ENDREM»

«REM»Crea una Base action«ENDREM»
«DEFINE applicationConstantsJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(this, skip_component_dir_creation) + "/util/Constants.java" »package «getBaseJavaPackage(this)».util;

/**
 * <p>Classe delle costanti applicative.</p>
 *
 * @author GuiGen
 */
public final class Constants
{
    /**
     * identificativo dell'applicativo.
     */
    public static final String APPLICATION_CODE = "«codComponente»";
    
    «PROTECT CSTART '/*' CEND '*/' ID getRegionUID("Constants")»
    // Add here your constants
    «ENDPROTECT»
}

«ENDFILE»
«ENDDEFINE»


«REM»Crea la servlet stream dati«ENDREM»
«DEFINE servletStreamJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«ENDDEFINE»


«REM»Crea la servlet stream dati«ENDREM»
«DEFINE resourceStreamJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«ENDDEFINE»

«REM»
==========================================================================================================================
DEFINIZIONE UTILITY GIS PER LE MAPPE
===========================================================================================================================
«ENDREM»
«DEFINE gisMapScaleDefinitionJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(this, skip_component_dir_creation) + "/business/greaseutils/GisMapScaleDefinition.java" »package «getBaseJavaPackage(this)».business.greaseutils;
import it.csi.jeegia.jeegfw.dto.jeegweb.EnvelopeWeb;
import it.csi.jeegia.jeegfw.dto.jeegweb.geometry.PuntoWeb;
import it.csi.jeegia.jeegfw.util.managers.ScalePredefiniteDefinitionImpl;

/**
 * Classe di utilita' utilizzata dalle funzionalita' GIS
 */
public class GisMapScaleDefinition extends ScalePredefiniteDefinitionImpl {

	/**
	 * @param logger
	 * @param numLivelli
	 * @param scaleEnvelopeSudOvestX
	 * @param scaleEnvelopeSudOvestY
	 * @param scaleEnvelopeNordEstX
	 * @param scaleEnvelopeNordEstY
	 */
	public GisMapScaleDefinition(String logger, String numLivelli, String scaleEnvelopeSudOvestX, 
			String scaleEnvelopeSudOvestY, String scaleEnvelopeNordEstX, String scaleEnvelopeNordEstY) {
		super(logger);
		log
				.debug("[GisMapScaleDefinition::ScalePredefiniteDefinitionImpl] BEGIN");
		try {
			// effettua i calcoli necessari a determinare correttamente la
			// definizione di scala utilizzata per la visualizzazione della mappa
			numLevels = Integer.parseInt(numLivelli);
			envelopeLivZero = new EnvelopeWeb();
			envelopeLivZero.setSudovest(new PuntoWeb(new Double(
					scaleEnvelopeSudOvestX), new Double(
					scaleEnvelopeSudOvestY)));
			envelopeLivZero.setNordest(new PuntoWeb(new Double(
					scaleEnvelopeNordEstX), new Double(
					scaleEnvelopeNordEstY)));
			double deltaUtmPiramide = (envelopeLivZero.getNordest().getCoordX()
					.doubleValue() - envelopeLivZero.getSudovest().getCoordX()
					.doubleValue());
			scaleFactors = new double[numLevels];
			for (int i = 0; i < numLevels; i++) {
				int numTasselliPerLato = new Double(Math.pow(2, i)).intValue();
				int largPiramidePixel = numTasselliPerLato * dimTassello;
				scaleFactors[i] = deltaUtmPiramide / largPiramidePixel;
			}
		} catch (Exception e) {
			log.error(
					"[GisMapScaleDefinition::ScalePredefiniteDefinitionImpl] ",
					e);
		} finally {
			log
					.debug("[GisMapScaleDefinition::ScalePredefiniteDefinitionImpl] END");
		}

	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE gisMapManagerJavaFile(boolean skip_component_dir_creation) FOR GUIModel»
«FILE getBaseJavaSrcDir(this, skip_component_dir_creation) + "/business/greaseutils/GisMapManager.java" »package «getBaseJavaPackage(this)».business.greaseutils;
import it.csi.jeegia.jeegfw.dto.jeegweb.EnvelopeWeb;
import it.csi.jeegia.jeegfw.dto.jeegweb.geometry.PuntoWeb;
import it.csi.jeegia.jeegfw.presentation.managers.helper.MapManager;

/**
 * Classe di utilita' utilizzata dal framework GREASE, per la visualizzaizone di mappe GIS.
 * 
 */
public class GisMapManager extends MapManager {

	/**
	 * @param rootLogger
	 */
	public GisMapManager(String rootLogger) {
		super(rootLogger);
	}
	
	private String startEnvelopeSudOvestX;
	private String startEnvelopeSudOvestY;
	private String startEnvelopeNordEstX;
	private String startEnvelopeNordEstY;
	private String maxEnvelopeSudOvestX;
	private String maxEnvelopeSudOvestY;
	private String maxEnvelopeNordEstX;
	private String maxEnvelopeNordEstY;

	/**
	 * coordinata X dell'angolo sud/ovest dell'envelope della mappa
	 */
	public void setStartEnvelopeSudOvestX(String startEnvelopeSudOvestX) {
		this.startEnvelopeSudOvestX = startEnvelopeSudOvestX;
	}
	
	/**
	 * coordinata Y dell'angolo sud/ovest dell'envelope della mappa
	 */
	public void setStartEnvelopeSudOvestY(String startEnvelopeSudOvestY) {
		this.startEnvelopeSudOvestY = startEnvelopeSudOvestY;
	}

	/**
	 * coordinata X dell'angolo nord/est dell'envelope della mappa
	 */
	public void setStartEnvelopeNordEstX(String startEnvelopeNordEstX) {
		this.startEnvelopeNordEstX = startEnvelopeNordEstX;
	}

	/**
	 * coordinata Y dell'angolo nord/est dell'envelope della mappa
	 */
	public void setStartEnvelopeNordEstY(String startEnvelopeNordEstY) {
		this.startEnvelopeNordEstY = startEnvelopeNordEstY;
	}
	/**
	 * coordinata X dell'angolo sud/ovest dell'envelope massimo della mappa
	 */
	public void setMaxEnvelopeSudOvestX(String maxEnvelopeSudOvestX) {
		this.maxEnvelopeSudOvestX = maxEnvelopeSudOvestX;
	}

	/**
	 * coordinata Y dell'angolo sud/ovest dell'envelope massimo della mappa
	 */
	public void setMaxEnvelopeSudOvestY(String maxEnvelopeSudOvestY) {
		this.maxEnvelopeSudOvestY = maxEnvelopeSudOvestY;
	}

	/**
	 * coordinata X dell'angolo nord/est dell'envelope massimo della mappa
	 */
	public void setMaxEnvelopeNordEstX(String maxEnvelopeNordEstX) {
		this.maxEnvelopeNordEstX = maxEnvelopeNordEstX;
	}

	/**
	 * coordinata Y dell'angolo nord/est dell'envelope massimo della mappa
	 */
	public void setMaxEnvelopeNordEstY(String maxEnvelopeNordEstY) {
		this.maxEnvelopeNordEstY = maxEnvelopeNordEstY;
	}

	/**
	 * Costruisce l'envelope iniziale a partire dai punti forniti
	 */
	protected EnvelopeWeb getStartEnvelope() throws Exception {
		EnvelopeWeb envelopeLivZero = new EnvelopeWeb();
		// ppunto sud/ovest
		envelopeLivZero.setSudovest(new PuntoWeb(new Double(this.startEnvelopeSudOvestX),
				new Double(this.startEnvelopeSudOvestY)));
		// punto nord/est
		envelopeLivZero.setNordest(new PuntoWeb(new Double(this.startEnvelopeNordEstX), new Double(
				this.startEnvelopeNordEstY)));
		return cloneEnvelope(envelopeLivZero);
	}

	/**
	 * costruisce l'envelope massimo a partire dai punti forniti
	 */
	protected EnvelopeWeb getMaxEnvelope() throws Exception {
		EnvelopeWeb envelopeLivZero = new EnvelopeWeb();
		// punto sud/ovest
		envelopeLivZero.setSudovest(new PuntoWeb(new Double(this.maxEnvelopeSudOvestX),
				new Double(this.maxEnvelopeSudOvestY)));
		// punto nord/est
		envelopeLivZero.setNordest(new PuntoWeb(new Double(this.maxEnvelopeNordEstX), new Double(
				this.maxEnvelopeNordEstY)));
		return cloneEnvelope(envelopeLivZero);
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE beanMappingUtils FOR GUIModel»
«FILE getDTOBaseSrcDir()+"/BeanMapping.java"»package «getDTOBaseJavaPackage()»;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Map.Entry;

/**
 * Questa classe usa la reflection per mappare un set di bean simili tra loro.
 * <p>
 * Questa classe espone un solo metodo pubblico statico, convert, che prende in input un oggetto
 * di tipo properties per mappare le informazioni tra bean.
 * </p>
 * <p>
 * L'oggetto di ripo properties e' nel formato:
 * com.package.SomeClass=com.otherpackage.OtherClass
 * 
 * oppure se ci sono due packages con un set di classi che hanno lo stesso nome
 * si puo' specificare cosi':
 * com.package.*=com.otherpackage.*
 * </p>
 * <p>
 * Quando la classe in input viene passata e un mapping viene trovato, le properties e
 * gli attributi public non-final nel bean vengono matchati con le properties e
 * gli attributi non-final sull'oggetto target. Ogni properties che non matcha viene ignorata.
 * Properties e attributes vengono considerati intercambiabili
 * per cui un public attribute su un bean puo' essere una property sull'altro.
 * </p>
 */
public class BeanMapping {

	/**
	 * Elenco dei nomi dei tipi base gestiti
	 */
	@SuppressWarnings("unchecked")
	static final Class[] BASE_TYPES = { java.lang.Integer.class,
			java.lang.Long.class, java.lang.Byte.class,
			java.lang.Character.class, java.lang.Boolean.class,
			java.lang.Double.class, java.lang.Float.class,
			java.lang.String.class, java.lang.Number.class,
			java.lang.CharSequence.class };
			
	/**
	 * Elenco dei tipi base gestiti
	 */		
	@SuppressWarnings("unchecked")
	private static final Map<Class, Map<String, Object>> inspections = new HashMap<Class, Map<String, Object>>();

	/** Creates a new instance of BeanMapping */
	private BeanMapping() {
		super();
	}

	/**
	 * Converte un bean nel suo tipo mappato.
	 * 
	 * @param mappings
	 *            rappresenta le mappings properties
	 * @param bean
	 *            rappresenta il bean da convertire nel suo tipo mappato
	 * @throws java.beans.IntrospectionException
	 * @throws java.lang.ClassNotFoundException
	 * @throws java.lang.InstantiationException
	 * @throws java.lang.IllegalAccessException
	 * @throws java.lang.reflect.InvocationTargetException
	 * @throws com.totsp.gwt.beans.server.MappingException
	 * @return l'oggetto mappato.
	 */
	public static Object convert(Properties mappings, Object bean)
			throws IntrospectionException, ClassNotFoundException,
			InstantiationException, IllegalAccessException,
			InvocationTargetException, MappingException {
		IdentityHashMap<Object, Object> instances = new IdentityHashMap<Object, Object>();

		return convertInternal(instances, mappings, bean);
	}

	/**
	 * restituisce true se le due classi coincidono oppure se check contiene
	 * interfaceClass tra le sue interfacce
	 * @param interfaceClass
	 * @param check
	 */
	@SuppressWarnings("unchecked")
	private static boolean isInterface(Class interfaceClass, Class check) {
		return check.equals(interfaceClass)
				|| arrayContains(check.getInterfaces(), interfaceClass);
	}

	/**
	 * verifica se "find" e' contenuto in "array"
	 * @param array
	 * @param find 
	 */
	private static boolean arrayContains(Object[] array, Object find) {
		for (Object match : array) {
			if ((match == find) || match.equals(find)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * converte una collezione
	 * @param instances l'elenco delgi oggetti gia' convertiti (per evitare loop)
	 * @param mappings la descrizione dei mapping classe-classe
	 * @param source la collezione da convertire
	 * @param destination la collezione da riempire cpon gli elementi convertiti
	 */
	@SuppressWarnings("unchecked")
	private static void convertCollection(
			IdentityHashMap<Object, Object> instances, Properties mappings,
			Collection source, Collection destination)
			throws IntrospectionException, ClassNotFoundException,
			InstantiationException, IllegalAccessException,
			InvocationTargetException, MappingException {
		if (source == null) {
			return;
		}

		for (Iterator it = source.iterator(); it.hasNext();) {
			Object o = it.next();

			if (!arrayContains(BASE_TYPES, o.getClass())) {
				o = convertInternal(instances, mappings, o);
			}

			destination.add(o);
		}
	}

	/**
	 * metodo intero per la conversione degli oggetti
	 * @param instances
	 * @param mappings
	 * @param bean il bean da convertire
	 */
	@SuppressWarnings("unchecked")
	private static Object convertInternal(
			IdentityHashMap<Object, Object> instances, Properties mappings,
			Object bean) throws IntrospectionException, ClassNotFoundException,
			InstantiationException, IllegalAccessException,
			InvocationTargetException, MappingException {
		// se nullo
		if (bean == null) {
			return null;
		}

		// if we have already seen this instance.
		if (instances.containsKey(bean)) {
			return instances.get(bean);
		}

		// if this is an array, backstep the array and return it.
		if (bean.getClass().isArray()) {
			Object[] beans = (Object[]) bean;
			Class arrayClass = resolveArray(mappings, bean);
			Object[] destination = (Object[]) Array.newInstance(arrayClass,
					beans.length);

			for (int i = 0; i < beans.length; i++) {
				destination[i] = convertInternal(instances, mappings, beans[i]);
			}

			return destination;
		}

		// if this is a primitve or a common type, just return it.
		if (bean.getClass().isPrimitive()
				|| arrayContains(BASE_TYPES, bean.getClass())) {
			return bean;
		}

		if (isInterface(Map.class, bean.getClass())) {
			Map map = (Map) resolveMapType(bean.getClass(), bean.getClass())
					.newInstance();
			convertMap(instances, mappings, (Map) bean, map);
			return map;
		} else if (isInterface(List.class, bean.getClass())
				|| isInterface(ArrayList.class, bean.getClass())) {
			List list = (List) resolveListType(bean.getClass(), bean.getClass())
					.newInstance();
			convertCollection(instances, mappings, (List) bean, list);
			return list;
		} else if (isInterface(Collection.class, bean.getClass())) {
			Collection collection = (Collection) resolveCollecitonType(
					bean.getClass(), bean.getClass()).newInstance();
			convertCollection(instances, mappings, (Collection) bean,
					collection);
			return collection;
		}
		// if we have gotten here,
		// this is a class that requires resolution mapping.
		Class destinationClass = resolveClass(mappings, bean.getClass());

		if (destinationClass == null) {
			throw new MappingException("Unable to resolve class"
					+ bean.getClass().getName());
		}

		Object dest = destinationClass.newInstance();

		// store the instance so it is there when we recurse into the
		// properties.
		instances.put(bean, dest);

		Map<String, Object> sourceProperties = inspectObject(bean);
		Map<String, Object> destinationProperties = inspectObject(dest);

		for (Iterator<String> it = sourceProperties.keySet().iterator(); it
				.hasNext();) {
			String propertyName = it.next();

			if (!destinationProperties.containsKey(propertyName)) {
				continue;
			}

			Object sourceAccessor = sourceProperties.get(propertyName);
			Object destinationAccessor = destinationProperties
					.get(propertyName);
			Class valueClass = null;
			Object valueObject = null;

			if (sourceAccessor instanceof Field) {
				Field f = (Field) sourceAccessor;
				valueClass = f.getType();
				valueObject = f.get(bean);
			} else {
				PropertyDescriptor pd = (PropertyDescriptor) sourceAccessor;
				valueClass = pd.getPropertyType();
				valueObject = pd.getReadMethod().invoke(bean);
			}

			Class valueDestinationClass = null;

			if (destinationAccessor instanceof Field) {
				Field f = (Field) destinationAccessor;
				valueDestinationClass = f.getType();

				if (valueClass.isArray() && valueObject != null
						&& valueDestinationClass.isArray()) {
					Object[] beans = (Object[]) valueObject;
					Class arrayClass = resolveArray(mappings,
							valueObject);
					Object[] destination = (Object[]) Array.newInstance(
							arrayClass, beans.length);

					for (int i = 0; i < beans.length; i++) {
						destination[i] = convertInternal(instances, mappings,
								beans[i]);
					}

					f.set(dest, new Object[]{destination});
				} else if (valueObject != null && valueClass.isArray()
						&& isInterface(ArrayList.class, valueDestinationClass)) {
					Object[] beans = (Object[]) valueObject;
					List list = (ArrayList) valueDestinationClass.newInstance();
					for (int i = 0; i < beans.length; i++) {
						list
								.add(convertInternal(instances, mappings,
										beans[i]));
					}
					f.set(dest, list);
				} else if (isInterface(ArrayList.class, valueClass)
						&& valueDestinationClass.isArray()) {
					List list = (ArrayList) valueObject;
					Object[] destination = (Object[]) Array.newInstance(
							valueDestinationClass.getComponentType(),list.size());
					
					for (int i = 0; i < list.size(); i++) {
						destination[i] = convertInternal(instances, mappings,
								list.get(i));
					}

					f.set(dest, new Object[]{destination});
				} else if (isInterface(ArrayList.class, valueClass)
						&& isInterface(HashSet.class, valueDestinationClass)) {
					Set set = (HashSet) valueDestinationClass.newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							set);
					f.set(dest, set);
				} else if (isInterface(Map.class, valueClass)
						&& isInterface(Map.class, valueDestinationClass)) {
					Map map = (Map) resolveMapType(valueClass,
							valueDestinationClass).newInstance();
					convertMap(instances, mappings, (Map) valueObject, map);
					f.set(dest, map);
				} else if (isInterface(List.class, valueClass)
						&& isInterface(List.class, valueDestinationClass)) {
					List list = (List) resolveListType(valueClass,
							valueDestinationClass).newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							list);
					f.set(dest, list);
				} else if (isInterface(ArrayList.class, valueClass)
						&& isInterface(ArrayList.class, valueDestinationClass)) {
					List list = (List) resolveListType(valueClass,
							valueDestinationClass).newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							list);
					f.set(dest, list);
				} else if (isInterface(Collection.class, valueClass)
						&& isInterface(Collection.class, valueDestinationClass)) {
					Collection collection = (Collection) resolveCollecitonType(
							valueClass, valueDestinationClass).newInstance();
					convertCollection(instances, mappings,
							(Collection) valueObject, collection);
					f.set(dest, collection);
				} else if (valueClass == valueDestinationClass) {
					f.set(dest, valueObject);
				} else if ((valueDestinationClass == resolveClass(mappings,
						valueClass))
						|| (valueDestinationClass.isArray() && valueClass
								.isArray())) {
					f.set(dest, convertInternal(instances, mappings,
							valueObject));
				} else {
					continue;
				}
			} else {
				PropertyDescriptor pd = (PropertyDescriptor) destinationAccessor;
				valueDestinationClass = pd.getPropertyType();

				if (valueClass.isArray() && valueObject != null
						&& valueDestinationClass.isArray()) {
					Object[] beans = (Object[]) valueObject;
					Object[] destination = (Object[]) Array.newInstance(
							valueDestinationClass.getComponentType(), beans.length);

					for (int i = 0; i < beans.length; i++) {
						destination[i] = convertInternal(instances, mappings,
								beans[i]);
					}

					pd.getWriteMethod().invoke(dest, new Object[]{destination});
				} else if (valueObject != null && valueClass.isArray()
						&& isInterface(ArrayList.class, valueDestinationClass)) {
					Object[] beans = (Object[]) valueObject;
					List list = (ArrayList) valueDestinationClass.newInstance();
					for (int i = 0; i < beans.length; i++) {
						list
								.add(convertInternal(instances, mappings,
										beans[i]));
					}

					pd.getWriteMethod().invoke(dest, list);
				} else if (isInterface(ArrayList.class, valueClass)
						&& valueDestinationClass.isArray()) {
					List list = (ArrayList) valueObject;
					if(list.size() > 0){
						Object[] destination = (Object[]) Array.newInstance(
								valueDestinationClass.getComponentType(), list.size());
	
						for (int i = 0; i < list.size(); i++) {
							destination[i] = convertInternal(instances, mappings,
									list.get(i));
						}
	
						pd.getWriteMethod().invoke(dest, new Object[]{destination});
					}
				} else if (isInterface(ArrayList.class, valueClass)
						&& isInterface(HashSet.class, valueDestinationClass)) {
					Set set = (HashSet) valueDestinationClass.newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							set);
					pd.getWriteMethod().invoke(dest, set);
				} else if (isInterface(Map.class, valueClass)
						&& isInterface(Map.class, valueDestinationClass)) {
					Map map = (Map) resolveMapType(valueClass,
							valueDestinationClass).newInstance();
					convertMap(instances, mappings, (Map) valueObject, map);
					pd.getWriteMethod().invoke(dest, map);
				} else if (isInterface(List.class, valueClass)
						&& isInterface(List.class, valueDestinationClass)) {
					List list = (List) resolveListType(valueClass,
							valueDestinationClass).newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							list);
					pd.getWriteMethod().invoke(dest, list);
				} else if (isInterface(ArrayList.class, valueClass)
						&& isInterface(ArrayList.class, valueDestinationClass)) {
					List list = (List) resolveListType(valueClass,
							valueDestinationClass).newInstance();
					convertCollection(instances, mappings, (List) valueObject,
							list);
					pd.getWriteMethod().invoke(dest, list);
				} else if (isInterface(Collection.class, valueClass)
						&& isInterface(Collection.class, valueDestinationClass)) {
					Collection collection = (Collection) resolveCollecitonType(
							valueClass, valueDestinationClass).newInstance();
					convertCollection(instances, mappings,
							(Collection) valueObject, collection);
					pd.getWriteMethod().invoke(dest, collection);
				} else if (valueClass == valueDestinationClass) {
					pd.getWriteMethod().invoke(dest, valueObject);
				} else if ((valueDestinationClass == resolveClass(mappings,
						valueClass))
						|| (valueDestinationClass.isArray() && valueClass
								.isArray())) {
					pd.getWriteMethod().invoke(dest,
							convertInternal(instances, mappings, valueObject));
				} else {
					continue;
				}
			}
		}

		return dest;
	}
	
	/**
	 * Converte una mappa di elementi
	 * @param instances
	 * @param mappings
	 * @param source
	 * @param destination
	 */
	@SuppressWarnings("unchecked")
	private static void convertMap(IdentityHashMap<Object, Object> instances,
			Properties mappings, Map source, Map destination)
			throws IntrospectionException, ClassNotFoundException,
			InstantiationException, IllegalAccessException,
			InvocationTargetException, MappingException {
		if (source == null) {
			return;
		}

		for (Iterator<Entry<Object, Object>> it = source.entrySet().iterator(); it
				.hasNext();) {
			Entry<Object, Object> entry = it.next();
			Object key = entry.getKey();

			if (!arrayContains(BASE_TYPES, key.getClass())) {
				key = convertInternal(instances, mappings, key);
			}

			Object value = entry.getValue();

			if (!arrayContains(BASE_TYPES, value.getClass())) {
				value = convertInternal(instances, mappings, value);
			}

			destination.put(key, value);
		}
	}

	
	private static Map<String, Object> inspectObject(Object o)
			throws IntrospectionException { 
		if (inspections.containsKey(o.getClass())) {
			return inspections.get(o.getClass());
		}

		PropertyDescriptor[] pds = Introspector.getBeanInfo(o.getClass())
				.getPropertyDescriptors();
		HashMap<String, Object> values = new HashMap<String, Object>();

		for (PropertyDescriptor pd : pds) {
			if (pd.getName().equals("class")
					|| (pd.getReadMethod() == null)
					|| (pd.getWriteMethod() == null)
					|| ((pd.getReadMethod().getModifiers() & Modifier.PUBLIC) == 0)
					|| ((pd.getWriteMethod().getModifiers() & Modifier.PUBLIC) == 0)) {
				continue;
			}

			values.put(pd.getName(), pd);
		}

		for (Field field : o.getClass().getFields()) {
			if (((field.getModifiers() & Modifier.PUBLIC) != 0)
					&& ((field.getModifiers() & Modifier.FINAL) == 0)
					&& ((field.getModifiers() & Modifier.STATIC) == 0)
					&& (values.get(field.getName()) == null)) {
				values.put(field.getName(), field);
			}
		}

		inspections.put(o.getClass(), values);

		return values;
	}

	@SuppressWarnings("unchecked")
	private static Class resolveArray(Properties mappings, Object bean)
			throws ClassNotFoundException {
		int arrayDepth = 0;
		Class clazz = bean.getClass().getComponentType();
		
		if(bean.getClass().getComponentType() == null){
			clazz = bean.getClass();
		}

		while (clazz.isArray()) {
			clazz = clazz.getComponentType();
			arrayDepth++;
		}

		if (!clazz.isPrimitive() && !arrayContains(BASE_TYPES, clazz)) {
			clazz = resolveClass(mappings, clazz);

			if (clazz == null) {
				return null;
			}
		}

		Object array = null;

		for (int i = 0; i < arrayDepth; i++) {
			array = Array.newInstance(clazz, 0);
			clazz = array.getClass();
		}

		return clazz;
	}

	@SuppressWarnings("unchecked")
	private static Class resolveClass(Properties mappings, Class clazz)
			throws ClassNotFoundException {
		assert ((mappings != null) && (mappings.size() > 0));
		assert (clazz != null);

		if (mappings.containsKey(clazz.getName())) {
			return Class.forName(mappings.getProperty(clazz.getName()));
		} else if (mappings.containsValue(clazz.getName())) {
			for (Iterator<Entry<Object, Object>> it = mappings.entrySet()
					.iterator(); it.hasNext();) {
				Entry entry = it.next();

				if (entry.getValue().equals(clazz.getName())) {
					return Class.forName(entry.getValue().toString());
				}
			}
		} else if (mappings.containsKey(trimPackage(clazz.getName()) + ".*")) {
			String newClass = trimPackage(mappings
					.getProperty(trimPackage(clazz.getName()) + ".*"))
					+ "." + clazz.getSimpleName();

			return Class.forName(newClass);
		} else if (mappings.containsValue(trimPackage(clazz.getName()) + ".*")) {
			for (Iterator<Entry<Object, Object>> it = mappings.entrySet()
					.iterator(); it.hasNext();) {
				Entry entry = it.next();

				if (entry.getValue()
						.equals(trimPackage(clazz.getName()) + ".*")) {
					String newClass = trimPackage(entry.getKey().toString())
							+ "." + clazz.getSimpleName();
					return Class.forName(newClass);
				}
			}
		}

		return null;
	}

	@SuppressWarnings("unchecked")
	private static Class resolveCollecitonType(Class source, Class destination) {
		if (source.equals(Collection.class)
				&& destination.equals(Collection.class)) {
			return ArrayList.class;
		} else if (destination.equals(Collection.class)) {
			return source;
		} else {
			return destination;
		}
	}

	@SuppressWarnings("unchecked")
	private static Class resolveListType(Class source, Class destination) {
		if (source.equals(List.class) && destination.equals(List.class)) {
			return ArrayList.class;
		} else if (destination.equals(List.class)) {
			return source;
		} else {
			return destination;
		}
	}

	@SuppressWarnings("unchecked")
	private static Class resolveMapType(Class source, Class destination) {
		if (source.equals(Map.class) && destination.equals(Map.class)) {
			return HashMap.class;
		} else if (destination.equals(Map.class)) {
			return source;
		} else {
			return destination;
		}
	}

	@SuppressWarnings( { "unused", "unchecked" })
	private static Class resolveSetType(Class source, Class destination) {
		if (source.equals(Set.class) && destination.equals(Set.class)) {
			return HashSet.class;
		} else if (destination.equals(Set.class)) {
			return source;
		} else {
			return destination;
		}
	}

	private static String trimPackage(String packageString) {
		return packageString.substring(0, packageString.lastIndexOf("."));
	}

}
«ENDFILE»
«FILE getDTOBaseSrcDir()+"/MappingException.java"»package «getDTOBaseJavaPackage()»;

/**
 * Classe di eccezione sollevata in caso di problemi di mapping
 */
public class MappingException extends Exception{

	/**
	 * costruttore vuoto
	 */
	public MappingException() {
		super();
	}
    
    /**
     * @param message
     * @param cause
     */
	public MappingException(String message, Throwable cause) {
		super(message, cause);
	}

	/**
     * @param message
     */
	public MappingException(String message) {
		super(message);
	}

    /**
     * @param cause
     */
	public MappingException(Throwable cause) {
		super(cause);
	}

}
«ENDFILE»
«ENDDEFINE»

«REM»questo filter imposta l'encoding di richiesta e risposta a UTF-8 (serve su JBoss)«ENDREM»
«DEFINE EncodingFixFilter FOR GUIModel»
«FILE getEncodingFixFilterJavaFile(this, true)»package «getFiltersJavaPackage(this)»;
import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

/**
 * Forza l'encoding di richiesta e risposta a UTF-8, per evitare problemi
 * di visualizzazione di caratteri speciali/accentati 
 *
 * @author CSIPiemonte
 */
public class «getEncodingFixFilterClassName()» implements Filter {

	/**
	 * Imposta l'encoding della richiesta e della risposta a UTF-8
	 */	
	public void doFilter(ServletRequest req, ServletResponse resp,
			FilterChain fchn) throws IOException, ServletException {
		// imposta gli encoding
		resp.setCharacterEncoding("UTF-8");
		req.setCharacterEncoding("UTF-8"); 
		// continua con gli altri filtri...
		fchn.doFilter(req, resp);
		return;
	}

	/**
	 * non fa nulla alla distruzione del filter
	 */
	public void destroy() {
		
	}

	/**
	 * non fa nulla all'inizializzazione del filter
	 */
	public void init(FilterConfig arg0) throws ServletException {
		
	}


}

«ENDFILE»
«ENDDEFINE»


«REM»
«DEFINE viewFragmentResultJavaFile FOR GUIModel»
«FILE getViewFragResultJavaFile(true)»package «getResultJavaPackage()»;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;
import java.util.Map;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;


import org.apache.log4j.Logger;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.ServletDispatcherResult;
import org.apache.struts2.views.util.UrlHelper;

import sun.security.action.GetLongAction;

import com.opensymphony.xwork2.ActionInvocation;



public class «getViewFragResultClassName()» extends ServletDispatcherResult{
	public class DummyServletOutputStream extends ServletOutputStream{

		@Override
		public void write(int b) throws IOException {
			System.out.print((char)b);
			
		}
		
	}
	
	public class DummyResponse implements ServletResponse{

		public void flushBuffer() throws IOException {
			// TODO Auto-generated method stub
			
		}

		public int getBufferSize() {

			return bufferSize;
		}

		String characterEncoding=null;
		
		public String getCharacterEncoding() {

			return characterEncoding;
		}

		public String getContentType() {

			return contentType;
		}

		public Locale getLocale() {
			
			return locale;
		}

		public ServletOutputStream getOutputStream() throws IOException {
		 System.out.println("gertOutputStream");
			return new DummyServletOutputStream();
		}

		public PrintWriter getWriter() throws IOException {
			System.out.println("getWriter");
			return new PrintWriter(System.out);
		}

		public boolean isCommitted() {
			// TODO Auto-generated method stub
			return false;
		}

		public void reset() {
			// TODO Auto-generated method stub
			
		}

		public void resetBuffer() {
			// TODO Auto-generated method stub
			
		}

		int bufferSize = 1024;
		
		public void setBufferSize(int arg0) {
			bufferSize=arg0;
			
		}

		public void setCharacterEncoding(String arg0) {
			characterEncoding=arg0;
			
		}

		int contentLength;
		public void setContentLength(int arg0) {
			contentLength=arg0;
			
		}

		String contentType;
		public void setContentType(String arg0) {
			contentType=arg0;
			
		}

		Locale locale;
		public void setLocale(Locale arg0) {
			locale=arg0;
			
		}
    	
    }
	public static Logger LOG = Logger.getLogger(ViewFragmentResult.class);

	public «getViewFragResultClassName()»() {
		super();
	}

	public «getViewFragResultClassName()»(String location) {
		super(location);
	}

	@Override
	public void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Forwarding to location " + finalLocation);
        }

        PageContext pageContext = ServletActionContext.getPageContext();

        if (pageContext != null) {
            pageContext.include(finalLocation);
        } else {
            HttpServletRequest request = ServletActionContext.getRequest();
            HttpServletResponse response = ServletActionContext.getResponse();
            RequestDispatcher dispatcher = request.getRequestDispatcher(finalLocation);

            //add parameters passed on the location to #parameters
            // see WW-2120
            if (invocation != null && finalLocation != null && finalLocation.length() > 0
                    && finalLocation.indexOf("?") > 0) {
                String queryString = finalLocation.substring(finalLocation.indexOf("?") + 1);
                Map parameters = (Map) invocation.getInvocationContext().getContextMap().get("parameters");
                Map queryParams = UrlHelper.parseQueryString(queryString);
                if (queryParams != null && !queryParams.isEmpty())
                    parameters.putAll(queryParams);
            }

            // if the view doesn't exist, let's do a 404
            if (dispatcher == null) {
                response.sendError(404, "result '" + finalLocation + "' not found");

                return;
            }

            // If we're included, then include the view
            // Otherwise do forward
            // This allow the page to, for example, set content type
            if (!response.isCommitted() && (request.getAttribute("javax.servlet.include.servlet_path") == null)) {
                request.setAttribute("struts.view_uri", finalLocation);
                request.setAttribute("struts.request_uri", request.getRequestURI());

                ViewFragmentResult.DummyResponse dr  = new  ViewFragmentResult.DummyResponse();
                dr.setBufferSize(response.getBufferSize());
                dr.setCharacterEncoding(response.getCharacterEncoding());
                dr.setContentType(response.getContentType());
                dr.setLocale(response.getLocale());
                
                response.getWriter().write(getLastFinalLocation());
                dr.getWriter().write(getLastFinalLocation());
                System.out.println("\n\nforward:"+getLastFinalLocation());
                dispatcher.forward(request, dr);
            } else {
            	ViewFragmentResult.DummyResponse dr  = new  ViewFragmentResult.DummyResponse();
                dr.setBufferSize(response.getBufferSize());
                dr.setCharacterEncoding(response.getCharacterEncoding());
                dr.setContentType(response.getContentType());
                dr.setLocale(response.getLocale());
                
            	response.getWriter().write(getLastFinalLocation());
            	System.out.println("\n\ninclude:"+getLastFinalLocation());
                dispatcher.include(request, dr);
            }
        }
        
        
    }


}

«ENDFILE»

«ENDDEFINE»
«ENDREM»