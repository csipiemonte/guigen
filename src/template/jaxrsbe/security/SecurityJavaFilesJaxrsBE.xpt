«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»
«IMPORT guigen»
«EXTENSION template::jaxrsbe::JaxrsBEExtensions»

«DEFINE securityJavaFiles FOR GUIModel»
«EXPAND XSRFFilterJavaFile FOR this»
«ENDDEFINE»

«DEFINE XSRFFilterJavaFile FOR GUIModel»
«FILE getXSRFFilterFullPath()»package «getFiltersJavaPackage()»;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Il filtro agisce su tutte le richieste in input. Serve a prevenire attacchi di tipo 
 * XSRF.
 * L'idea e' che il primo accesso avvenga sulla risorsa di accesso della componente SPA
 * (es. index.html). In quell'occasione il filtro non fa verifiche ma si preoccupa di 
 * creare una nuova sessione servlet se non presente, creare un XSRF cookie, metterlo in
 * sessione e passarlo al client. 
 * Nelle successive richieste, se la rihciesta e' destinata allo strato di servizi rest,
 * viene effettuata la verifica di presenza/corrispondenza di cookie+header XSRF.
 * Questo comportamento, unito alla corretta gestione client side del protocollo, 
 * permette di evitare il richiamo dello strato rest al di fuori del contesto corretto.  
 */
public class «getXSRFFilterJavaClassName()» implements Filter{

	/**
	 * nome dell'header XSRF che la componente client deve inserire ad ogni richiesta rest
	 */
	private static final String XSRF_HEADER_NAME = "X-XSRF-TOKEN";
	
	/*
	 * nome del cookie XSRF
	 */
	private static final String XSRF_COOKIE_NAME = "XSRF-TOKEN";
	
	/**
	 * nome dell'attributo di sessione che mantiene il token XSRF 
	 */
	private static final String XSRF_INTERNAL_TOKEN_NAME = "XSRF_SESSION_TOKEN";
	
	
	@Override
	public void destroy() {
		// nothing to do
	}

	/**
	 * Azione del filtro:
	 * <ul>
	 * <li>creazione di una nuova sessione se non ancora presente</li>
	 * <li>se la richiesta corrente e' destinata alla parte SPA:
	 *   <ul>
	 *   <li>viene creato un nuovo token  che viene inserito in sessione e 
	 *   restituito come cookie</li>
	 *   </ul>
	 * </li>
	 * <li>se la richiesta corrente e' destinata alla parte REST:
	 *   <ul>
	 *   <li>se la request contiene una coppia di cookie e header XSRF validi e coincidenti con
	 *   quello corrente (contenuto in sessione) => procedo, altrimenti errore.</li>
	 *   </ul>
	 * </li>
	 * </ul> 
	 */
	@Override
	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
			throws IOException, ServletException {
		HttpServletRequest hreq = (HttpServletRequest)req;
		HttpServletResponse hresp = (HttpServletResponse)resp;
		// get current session or create a new one
		HttpSession session = hreq.getSession();
		if (!isDisabled){
			if (!isRestRequest(hreq)){
				try {
					String newToken = createNewXSRFToken(session);
					addXSRFCookie(hresp, newToken);
				} catch (NoSuchAlgorithmException e) {
					throw new ServletException(e);
				}
			}
			else{ // rest request: token must be valid
				if (isXSRFSessionAlive(session)){
					if (validXSRFCookieAndHeader(hreq, session)){
						//OK
					}
					else{
						// ERRORE!!!
						throw new ServletException("Invalid XSRF HEADER");
					}
				}
				else{
					throw new ServletException("XSRF TOKEN not already initialized");
				}
			}
		}
		
		chain.doFilter(req, resp);
	}

	/**
	 * 
	 * @param hreq
	 * @return true se il path rappresenta una richiesta alla parte REST dell'applicazione
	 * che per default deve contenere la stringa "restfacade"
	 */
	private boolean isRestRequest(HttpServletRequest hreq) {
		return hreq.getRequestURI() != null && hreq.getRequestURI().contains("restfacade");
	}

	/**
	 * aggiunge alla response il cookie XSRF
	 * @param hresp la response in cui aggiungere il cookie
	 * @param token il valore del cookie
	 */
	private void addXSRFCookie(HttpServletResponse hresp, String token) {
		
		Cookie c = new Cookie(XSRF_COOKIE_NAME, token);
		c.setPath("/");
		
		hresp.addCookie(c);
		
	}

	/**
	 * crea un nuovo token XSRF
	 * @param session
	 * @return il token creato
	 * @throws NoSuchAlgorithmException
	 */
	private String createNewXSRFToken(HttpSession session) throws NoSuchAlgorithmException{
		SecureRandom random = new SecureRandom();
		String newToken = ""+random.nextLong()+""+random.nextLong();
		session.setAttribute(XSRF_INTERNAL_TOKEN_NAME, newToken);
		return newToken;
	}

	/**
	 * 
	 * @param session
	 * @return il token XSRF presente in sessione
	 */
	private String getActualActiveXSRFToken(HttpSession session) {
		return (String)session.getAttribute(XSRF_INTERNAL_TOKEN_NAME);
	}

	/**
	 * verifica se la richiesta possiede una coppia cookie/header XSRF validi
	 * e coincidenti con quanto memorizzato in sessione (se presente)
	 * @param hreq la request
	 * @param session la sessione servlet
	 * @return il risultato della verifica
	 */
	private boolean validXSRFCookieAndHeader(HttpServletRequest hreq, HttpSession session) {
		String actualActiveToken = getActualActiveXSRFToken(session);
		String actualRequestHeader = getActualXSRFHeader(hreq);
		String actualRequestCookie = getActualXSRFCookie(hreq);
		return actualRequestHeader != null && actualActiveToken != null && actualActiveToken.equals(actualRequestHeader) && actualActiveToken.contentEquals(actualRequestCookie);
	}

	/**
	 * 
	 * @param hreq
	 * @return l'header XSRF se presente nella request
	 */
	private String getActualXSRFHeader(HttpServletRequest hreq) {
		return (String)hreq.getHeader(XSRF_HEADER_NAME);
	}

	/**
	 * 
	 * @param hreq la request
	 * @return il valore del cookie XSRF, se presente nella request; 
	 * la stringa vuota se invece non presente.
	 */
	private String getActualXSRFCookie(HttpServletRequest hreq) {
		Cookie [] cookies = hreq.getCookies();
		for (int i = 0; i < cookies.length; i++) {
			if (cookies[i].getName().contentEquals(XSRF_COOKIE_NAME)){
				return cookies[i].getValue();
			}
		}
		// if not found...
		return "";
	}
	
	/**
	 * 
	 * @param session
	 * @return true se in sessione e' presente un token valido
	 */
	private boolean isXSRFSessionAlive(HttpSession session) {
		return getActualActiveXSRFToken(session) != null;
	}

	/**
	 * di default il filter abilita le verifiche
	 */
	private boolean isDisabled = false;
	
	/**
	 * nome del parametro di inizializzazione che serve per disabilitare
	 * il meccanismo. Serve negli scenari di sviluppo in cui la parte client
	 * non e' deployata nell'ear dei servizi
	 */
	private static String DISABLED_PARAM_NAME = "disabled";
	
	@Override
	public void init(FilterConfig cfg) throws ServletException {
		String sDisabled = cfg.getInitParameter(DISABLED_PARAM_NAME);
		if ("true".equals(sDisabled)){
			isDisabled = true;
		}
	}

}
«ENDFILE»
«ENDDEFINE»